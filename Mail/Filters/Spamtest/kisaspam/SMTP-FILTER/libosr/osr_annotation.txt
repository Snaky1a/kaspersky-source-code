
encoding = Cyrillic (KOI8-R)

                         ----------------------
                         Описание алгоритма OSR
                         ----------------------

                                                            Смирнов Евгений, 
                                                            Evgeny.Smirnov@mail.ru

24.11.2006 - описание алгоритма на момент внедрения в KAS 3.0.255 MP1, KIS 6.0.

Путь к документу в CVS:
devel.kaspersky-labs.com:/projects/smtp-filter/libosr/osr_annotation.txt



Алгоритм OSR (Optical Symbols Recognition) предназначен для анализа растрового изображения 
на предмет наличия текста и оценки характеристик этого текста. 

Под текстом подразумевается набор неких графических символов, организованных в слова, 
которые организованы в строки. На размер символов (в пикселях), слов (в символах), строк (в 
словах) и количество текста (в процентах) - наложены изначальные ограничения (снизу и/или 
сверху), выбранные на основе характеристик наиболее типичного текста. Подразумевается, что 
строки текста - горизонтальны, разбивка текста на блоки и колонки не производится. Допускается, 
что, до некоторой степени, строки могут искривляться в виде волн, наклоняться, 
масштабироваться. Допускается, что на пути строки могут встречаться любые преграды (рамки, 
шум).

Алгоритм OSR реализован в библиотеке smtp-filter/libosr. Данная библиотека используется в 
библиотеке smtp-filter/libgsg2, предназначенной для анализа, и снятия характеристик (в т. ч. 
построения сигнатур) с изображений, извлечённых, из графических файлов формата gif, png, jpg. 
Библиотека libgsg2 используется в движке Антиспама а также во вспомогательных утилитах.


Описание алгоритма:

1.	Цветной растр обесцвечивается до чёрно-белого. Обесцвечивание RGB-растра до серого 
взято из библиотеки libgsg2. Обесцвечивание серого растра до чёрно-белого происходит 
следующим образом. Строится гистограмма частот серых оттенков пикселей растра, 
находится её центр тяжести, порогом чёрно-белого берется 3/4 от первого 
использованного цвета до центра тяжести, либо сам центр тяжести. 
2.	Выбирается цвет фона. Его можно задать явно, или использовать автоматическое 
определение, которое выбирает за фон цвет, которого в растре больше. Цвет фона 
условно назван <белым>. Цветом текста признаётся второй цвет - он условно назван 
<чёрным>. 
3.	На растре выделяются символы. Производится один проход по всем пикселям чёрно-
белого растра. Если встречается пиксель <чёрного> цвета, значит, обнаружен новый 
предмет (символ или шум). Производится заливка этого предмета <белым> цветом. 
Используется общеизвестный алгоритм заливки. В процессе заливки вычисляются, а по 
окончании - запоминаются координаты прямоугольника, описывающего символ. До начала 
заливки таким прямоугольником является сама начальная точка. На каждой итерации 
заливки новая точка заливания расширяет прямоугольник на 1 пиксель в ту или иную 
сторону, что легко выявить и учесть. В итоге получается массив прямоугольников, 
описывающих (в геометрическом смысле) символы. В массив не включаются 
прямоугольники, выходящие размером за пределы, заданные изначальными 
ограничениями (отсеивается шум - мелкие точки и большие предметы, в т.ч. большие 
рамки). 
4.	Символы организуются в строки. Сначала строится массив-индекс, позволяющий 
осуществлять бинарный поиск по y-координате центров символов. Производится один 
проход по всем символам. Если символ еще не участвует в какой-либо строке (у символа 
не установлен соответствующий флаг), с него начинается построение новой строки: 
инициируется <нанизывание> подстроки слева и <нанизывание> подстроки справа, затем 
формируется сама строка, которая есть <подстрока, нанизанная слева + изначальный 
символ + подстрока, нанизанная справа>. <Нанизывание> представляет собой 
рекуррентный выбор <следующего символа> и осуществляется следующим образом. Верх 
и низ прямоугольника, текущего инициирующего символа (дополнительно раздвинутые 
еще на 1/3 высоты символа), образуют собой две y-границы. Происходит отбор символов, 
y-координата центра которых, попадает в эти пределы. Символы, уже участвующие в 
другой строке, игнорируются. Для отбора не требуется перебор всех символов благодаря 
наличию у-индекса. Из отобранных символов <следующим> - выбирается самый ближний 
символ по x-координате (выбор осуществляется простым перебором, т. к. символов в 
строке не много). 
5.	Строки разбиваются на слова. Сначала строится гистограмма частот расстояний между 
всеми соседними (с т. з. строки) парами символов. Выявляется <самое частое расстояние> 
(абсцисса первого максимума гистограммы). Затем два любых соседних (с т. з. строки) 
символа разрываются на слова, если расстояние между ними больше или равно 
удвоенному <самому частому расстоянию>. 
6.	Производится отсев шума. Удаляются слова, и строки, не удовлетворяющие 
изначальным ограничениям. Если количество получившихся строк меньше 
соответствующего первоначального ограничения, то все строки удаляются. Для 
оставшихся строк, слов и символов вводится термин <хорошие>. 
7.	Оценивается  <процентное количество текста>. В процессе первоначальной обработки 
растра попутно подсчитывается общее количество <чёрных> пикселей. После отсева шума 
подсчитывается количество <чёрных> пикселей <хороших> символов. Отношение второго 
числа к первому считается <процентным количеством текста> (относительно всей 
<информативной части> изображения). 
8.	Получившиеся строки слов символов - есть выходные данные алгоритма. Существует 
возможность запроса и получения результирующей информации об этих данных: 
общее количество строк, общее количество слов, общее количество символов, количество 
слов определённой строки, количество букв определённого слова определённой строки, 
процентное количество текста. На основе этих данных выносится вердикт <есть 
текст>/<нет текста>. Вердикт <есть текст> возвращается, если выходные данные 
удовлетворяют изначальным ограничениям. 
9.	На основе выходных данных алгоритма можно построить 32-байтную сигнатуру GSG7. 
Строится сигнатура следующим образом. Если вынесен вердикт, что изображение не 
содержит текста, сигнатурой будет пустая строка и дальнейшие вычисления не 
производятся. Общее количество <хороших> слов = N. С шагом N/20 вычисляется средняя 
длина слова (в буквах) среди следующих N/10 слов. Она округляется с точностью до 2 букв 
и добавляется слагаемым в MD5-сумму. Получившаяся в итоге MD5-сумма переводится в 
строковую форму (состоящую из печатных символов) и являет собой GSG7-сигнатуру. 

