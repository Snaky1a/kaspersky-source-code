#include <string.h>
#include <sys/types.h>
#ifdef __GNUC__
#include <netinet/in.h>
#endif
//#ifdef __ICL
//#include <winsock.h>
//#endif
//#ifdef __WATCOMC__
//#include <winsock.h>
//#endif
#ifdef __CYG__
#include <sys/param.h>
#endif

union UQW {                        /* Unsigned Quad Word. */
          QWORD L;                 /* Long.               */
          DWORD S[2];              /* 2 Shorts.           */
          };
union ULW {                        /* Unsigned Long Word. */
          DWORD L;                 /* Long.               */
          WORD  S[2];              /* 2 Shorts.           */
          };
union USW {                        /* Unsigned Short Word.*/
          WORD  S;                 /* Short.              */
          BYTE  B[2];              /* 2 Bytes.            */
          };

#ifdef __ICL
           DWORD cdecl rdtick ( void  );
           DWORD cdecl htonl  (DWORD  );
            WORD cdecl htons  ( WORD  );
#define __READTSC__
#endif
#ifdef _MSC_VER
           DWORD cdecl rdtick ( void  );
           DWORD cdecl htonl  (DWORD  );
            WORD cdecl htons  ( WORD  );
#define __READTSC__
#endif
#ifdef __CCDL__
           DWORD       rdtick ( void  );
           DWORD       htonl  (DWORD  );
            WORD       htons  ( WORD  );
#define __READTSC__
#endif
#ifdef __WATCOMC__
           DWORD cdecl rdtick ( void  );
           DWORD cdecl htonl  (DWORD  );
            WORD cdecl htons  ( WORD  );
#define __READTSC__
#endif
#ifdef __GNUC__
           DWORD       rdtick ( void  );
//         DWORD       htonl  (DWORD  );
//          WORD       htons  ( WORD  );
#define __READTSC__
#endif
#ifdef __BORLANDC__
extern "C" DWORD       rdtick ( void  );
extern "C" DWORD       htonl  (DWORD  );
extern "C"  WORD       htons  ( WORD  );
#define __READTSC__
#endif
#ifndef __READTSC__
extern "C" DWORD cdecl rdtick ( void  );
extern "C" DWORD cdecl htonl  (DWORD  );
extern "C"  WORD cdecl htons  ( WORD  );
#define __READTSC__
#endif

//    Если определена симв. переменная DEBUG, то процедуры выработки и проверки
// подписей ГОСТ Р34.10-1994 и Р34.10-2001 выводят промежуточные значения
// вычисляемых переменных в контрольных точках.
//    Вычисляется только одна подпись для каждого класса (Exp512, Exp1024,Curve256).
//    При этом для 512-разрядной подписи ГОСТ Р34.10-1994 и для подписи 
// ГОСТ Р34.10-2001 вычисляются значения на эталонных параметрах, приведённых
// в контрольных примерах в приложениях к соотв. ГОСТам.
//
//#define DEBUG

/*ССыЛКИ*НА*КОНСТАНТы*ДЛЯ*ФУНКЦИЙ*ЦИФРОВОЙ*ПОДПИСИ************************BEG*/
extern struct LR34_10_2001   _LC3410_Default0256;
extern DWORD  LO_[LNP];            /* Единица длины NP слов.  */

/*ССыЛКИ*НА*КОНСТАНТы*ДЛЯ*ФУНКЦИЙ*СОВМЕСТНОГО*КЛЮЧА***********************BEG*/

#if BYTE_ORDER == LITTLE_ENDIAN
#define CrypC_NetToHost(Buffer,DWords)                                        \
                      {                                                       \
                      int I;                                                  \
                      for(I=0;I<DWords;I++)                                   \
                         ((DWORD *)Buffer)[I]=htonl(((DWORD *)Buffer)[I]);    \
                      }
#else //__BYTE_ORDER == __BIG_ENDIAN
#define CrypC_NetToHost(Buffer,DWords) ;
#endif
#define CrypC_HostToNet(Buffer,DWords)                                        \
        CrypC_NetToHost(Buffer,DWords)

/* Значения признака формы записи точки в структуре Point: аффинная форма,    */
/* проективные координаты, представление Монтгомери, коорднаты в форме Монт-  */
/* гомери по модулю некоторого простого, etc.                                 */
#define Affi 0x00                               // Точка кривой в аффинной форме.
#define Proj 0x01                               // Точка кривой в проек. координатах.
#define Mont 0x02                               // Точка кривой в форме Монтгомери.
#define MONT 0x80                               // Координаты точки в Montgomery Domain.

/*Точка*эллиптической*кривой***********************************************BEG*/
struct LPoint
       {
       DWORD  X  [LCuNP];			  /* Координата X.            */
       DWORD  Y  [LCuNP];			  /* Координата Y.            */
       DWORD  Z  [LCuNP];			  /* Координата Z.            */
       DWORD  Type;				  /* Форма записи точки.      */
       };
#define LPTSIZE sizeof(struct LPoint)

/*КОНТЕКСТ*ГЕНЕРАТОРА*СЛУЧАЙНыХ*ЧИСЕЛ**************************************BEG*/
struct RND_State
       {
       DWORD   X0_, Y0_;                /* Текущее     состояние */
       DWORD   X1_, Y1_;                /* Текущее     состояние */
       DWORD   X2_, Y2_;                /* Текущее     состояние */
       DWORD   X3_, Y3_;                /* Текущее     состояние */
       DWORD   x0_, y0_;                /* Сохраненное состояние */
       DWORD   x1_, y1_;                /* Сохраненное состояние */
       DWORD   x2_, y2_;                /* Сохраненное состояние */
       DWORD   x3_, y3_;                /* Сохраненное состояние */
       DWORD   OLZ_, F_;                /* Рабочие переменные    */
        WORD   Pass_;                   /* Текущее     состояние */
        WORD   pass_;                   /* Сохраненное состояние */
       };
/*КОНТЕКСТ*ГЕНЕРАТОРА*СЛУЧАЙНыХ*ЧИСЕЛ*************************************END*/

/*КОНТЕКСТ*БЛОЧНОГО*ШИФРАТОРА**********************************************BEG*/
struct COM_State
       {
       BYTE    Perms[8][16];            /* Подстановки на V16.         */
       DWORD   K_[4*256];               /* Перемноженные, со сдвигами. */
       BYTE    Ready;                   /* Индикатор готовности.       */
       };
/*КОНТЕКСТ*БЛОЧНОГО*ШИФРАТОРА*********************************************END*/

/*ПРОТОТИПы*ФУНКЦИЙ*НИЗКОГО*УРОВНЯ****************************************BEG*/

void    CrypC__InitGost( BYTE *Perms, DWORD *K_ );
/*───────────────────────────────────────────────────────────────────────────*/
/*       Процедура формирования  модифицированного массива перестановок      */
/*                       для криптосхемы ГОСТ 28147-89.                      */
/*───────────────────────────────────────────────────────────────────────────*/
/* Входные параметры:                                                        */
/* - Указатель на буфер Perms (8*16 байт) 8 подстановок на V16               */
/* - Указатель на буфер K_ (4*256 дв. слов) сдвинутых образов при действии   */
/*   попарно перемноженных подстановок на соотв-щие сдвинутые байты из       */
/*   входного дв. слова.                                                     */
/* ВНИМАНИЕ! Модифицированный буфер формируется, если два его первых двойных */
/* слова в момент вызова процедуры CrypC__InitGost() равно нулю.             */
/* Выход:                                                                    */
/* - Заполненный буфер K_.                                                   */
/*───────────────────────────────────────────────────────────────────────────*/

void    CrypC__ClearGost( struct COM_State *Comm );
/*───────────────────────────────────────────────────────────────────────────*/
/*         Процедура очищения  модифицированного массива подстановок         */
/*                       для криптосхемы ГОСТ 28147-89.                      */
/*───────────────────────────────────────────────────────────────────────────*/
/* Входные параметры:                                                        */
/* - Указатель на буфер контекста подстановок Comm.                          */
/* Выход:                                                                    */
/* - Очищен буфер K_ контекста Comm.                                         */
/*───────────────────────────────────────────────────────────────────────────*/

void    CrypC_InitRandom_( struct RND_State *State );
/*───────────────────────────────────────────────────────────────────────────*/
/*          Генерация случайного начального заполнения длины 256 бит         */
/*                         датчика случайных чисел                           */
/*───────────────────────────────────────────────────────────────────────────*/

void    CrypC_ForceRandom_(struct RND_State *State,
                     DWORD _X0, DWORD _Y0,
                     DWORD _X1, DWORD _Y1,
                     DWORD _X2, DWORD _Y2,
                     DWORD _X3, DWORD _Y3,
                     char  _Pass           );
/*───────────────────────────────────────────────────────────────────────────*/
/*           Установка заданного начального заполнения длины 256 бит         */
/*                         датчика случайных чисел                           */
/*                    и сохранение текущего заполнения                       */
/*───────────────────────────────────────────────────────────────────────────*/
/* Входные параметры:                                                        */
/* - Указатель *State на контекст ГСЧ.                                       */
/* - Необходимые состояния регистров Xi_, Yi_, i=0,...,3.                    */
/* - Необходимое состояние индикатора Pass_.                                 */
/* Выход:                                                                    */
/* - Текущие состояния регистров Xi_, Yi_, i=0,...,3 и индикатора Pass_      */
/*   сохраняются в контексте и заполняются содержимым соответствующих        */
/*   параметров процедуры.                                                   */
/*───────────────────────────────────────────────────────────────────────────*/

void    CrypC_RestrRandom_(struct RND_State *State);
/*───────────────────────────────────────────────────────────────────────────*/
/*            Восстановление сохраненного заполнения длины 256 бит           */
/*                         датчика случайных чисел                           */
/*───────────────────────────────────────────────────────────────────────────*/
/* Входные параметры:                                                        */
/* - Указатель *State на контекст ГСЧ.                                       */
/* Выход:                                                                    */
/* - Восстанавливаютя ранее сохраненные в контексте состояния регистров      */
/*   Xi_, Yi_, i=0,...,3 и индикатора Pass_.                                 */
/*───────────────────────────────────────────────────────────────────────────*/

int     CrypC_FillByRandom_( struct RND_State *State, void *Buf, long LenInBytes );
/*───────────────────────────────────────────────────────────────────────────*/
/*             Генерация псевдослучайного вектора заданной длины             */
/*───────────────────────────────────────────────────────────────────────────*/
/* Входные параметры:                                                        */
/* - Указатель *State на контекст ГСЧ.                                       */
/* - Указатель *Buf на буфер для псевдослучайного вектора.                   */
/* - Длина LenInBytes буфера Buf в байтах.                                   */
/* Выход:                                                                    */
/* - В поле *Buf помещается псевдослучайный вектор длины LenInBytes байт.    */
/*───────────────────────────────────────────────────────────────────────────*/

void    CrypC__Hash(DWORD *K_, BYTE *H, BYTE *M);
/*───────────────────────────────────────────────────────────────────────────*/
/*                             Шаговая хэш-функция                           */
/*───────────────────────────────────────────────────────────────────────────*/
/* Входные параметры:                                                        */
/* - Указатель K_ на массив модифицированных подстановок ГОСТ 28147.         */
/* - Начальное состояние хэш-вектора - поле H длины NQ*4 байта.              */
/* - Блок данных для хэширования - поле M длины NQ*4 байта.                  */
/* Выход:                                                                    */
/* - Модифицированное состояние хэш-вектора в поле H.                        */
/*───────────────────────────────────────────────────────────────────────────*/

int     CrypC_LCuSign(struct LR34_10_2001 *Context, DWORD *SField);
/*───────────────────────────────────────────────────────────────────────────*/
/*        Выработка цифровой подписи в одном буфере данных                   */
/*───────────────────────────────────────────────────────────────────────────*/
/* Входные параметры:                                                        */
/* - Буфер данных *SField длины 3*CuNQ 32-разрядных слов, содержа-           */
/*   щий в первом подполе длины CuNQ 32-разрядных слов хэш-вектор H.         */
/* Выход:                                                                    */
/* - Код возврата:                                                           */
/*   - 0   - подпись выработана успешно.                                     */
/* - Второе и третье подполя длины NQ 32-разрядных слов поля SField          */
/*   заполнены, соответственно, компонентами ЭЦП r'и s.                      */
/*───────────────────────────────────────────────────────────────────────────*/

int     CrypC_LCuCheck(struct LR34_10_2001 *Context, DWORD *SField);
/*───────────────────────────────────────────────────────────────────────────*/
/*        Проверка цифровой подписи в одном буфере данных                    */
/*───────────────────────────────────────────────────────────────────────────*/
/* Входные параметры:                                                        */
/* - Буфер данных *SField, содержащий в трех последовательных                */
/*   полях длины CuNQ 32-разрядных слов каждое компоненты, необ-             */
/*   ходимые для проверки подписи, соответственно:                           */
/*   - хэш-вектор H,                                                         */
/*   - компонент ЭЦП r',                                                     */
/*   - компонент ЭЦП s .                                                     */
/* - Контекст с параметрами подписи.                                         */
/* Выход:                                                                    */
/* - Код возврата:                                                           */
/*   - RET_OK             - подпись проверена, результат положительный.      */
/*   - RET_INCORRECTSIGN  - подпись проверена, результат отрицательный.      */
/*   - RET_ZERO_R         - нулевое значение компонента ЭЦП r'.              */
/*   - RET_ZERO_S         - нулевое значение компонента ЭЦП s .              */
/*   - RET_BAD_R          - некорректное значение компонента ЭЦП r'.         */
/*   - RET_BAD_S          - некорректное значение компонента ЭЦП s .         */
/*───────────────────────────────────────────────────────────────────────────*/

int     CrypC_LroundC(DWORD *C, DWORD *B, DWORD *P, int L);
/*───────────────────────────────────────────────────────────────────────────*/
/*         Вспомогательная процедура для вычисления цифровой подписи         */
/*                        C = (B * 2**(32*L))(mod P)                         */
/*───────────────────────────────────────────────────────────────────────────*/

int     CrypC_LpowerC(DWORD *Y, DWORD *M, DWORD *Out, int Ind, DWORD *P, int L);
/*───────────────────────────────────────────────────────────────────────────*/
/*    Вычисление степени: Out = ((Y ** M) * 1**Ind) (mod P), Ind = 0 или 1   */
/*───────────────────────────────────────────────────────────────────────────*/
/* Входные параметры:                                                        */
/* - Указатель *Y на буфер, содержащий основание степени.                    */
/* - Указатель *M на буфер, содержащий показатель степени.                   */
/* - Указатель *Out на буфер для результата возведения.                      */
/* - Индикатор умножения результата на 1 перед выводом: целое 0 или 1.       */
/* - Указатель *P на буфер, содержащий порядок конечного поля.               */
/* - Размер L в 32-разрядных словах полей Y, M, P и Out.                     */
/* Выход:                                                                    */
/* - Результат возведения в степень M в поле Out.                            */
/*───────────────────────────────────────────────────────────────────────────*/

void    CrypC_LCuPower(struct LPoint       *Y      ,
                               DWORD       *M      ,
                       struct LPoint       *Out    ,
                       struct LR34_10_2001 *Context);
/*───────────────────────────────────────────────────────────────────────────*/
/* Скалярное умножение точки Y кривой, описанной в Context, на целое M:      */
/* Out = (Y * M).                                                            */
/*───────────────────────────────────────────────────────────────────────────*/
/* Входные параметры:                                                        */
/* - Указатель *Y на буфер, содержащий проективное представление точки.      */
/* - Указатель *M на буфер, содержащий целый множитель (CuNQ слов).          */
/* - Указатель *Out на буфер для кратной точки.                              */
/* Выход:                                                                    */
/* - Результат умножения на скаляр M в поле Out.                             */
/*───────────────────────────────────────────────────────────────────────────*/

int     CrypC_LmultC(DWORD *B, DWORD *C, DWORD *P, int L);
/*───────────────────────────────────────────────────────────────────────────*/
/*                   Умножение больших чисел по модулю P                     */
/*───────────────────────────────────────────────────────────────────────────*/
/* Входные параметры:                                                        */
/* - Указатель *B на буфер, содержащий первый операнд умножения.             */
/* - Указатель *C на буфер, содержащий второй операнд умножения.             */
/* - Указатель *P на буфер, содержащий порядок конечного поля.               */
/* - Размер L в 32-разрядных словах полей B, C, P.                           */
/* Выход:                                                                    */
/* - Результат умножения B*C (mod P) замещает первый операнд в поле B.       */
/*───────────────────────────────────────────────────────────────────────────*/

int     CrypC_LmultCm(DWORD *B, DWORD *C, DWORD *P, int L);
/*───────────────────────────────────────────────────────────────────────────*/
/*                   Умножение больших чисел по модулю P                     */
/*───────────────────────────────────────────────────────────────────────────*/
/* Входные параметры:                                                        */
/* - Указатель *B на буфер, содержащий первый операнд умножения.             */
/* - Указатель *C на буфер, содержащий второй операнд умножения.             */
/*   Второй операнд замаскирован процедурой Mask_SecretKey_ и                */
/*   имеет двойную длину.                                                    */
/* - Указатель *P на буфер, содержащий порядок конечного поля.               */
/* - Размер L в 32-разрядных словах полей B, C, P.                           */
/* Выход:                                                                    */
/* - Результат умножения B*C (mod P) замещает первый операнд в поле B.       */
/*───────────────────────────────────────────────────────────────────────────*/

int     CrypC_Lpower2C(DWORD *B, DWORD *P, int L);
/*───────────────────────────────────────────────────────────────────────────*/
/*              Возведение в квадрат большого числа по модулю P              */
/*───────────────────────────────────────────────────────────────────────────*/
/* Входные параметры:                                                        */
/* - Указатель *B на буфер, содержащий операнд.                              */
/* - Указатель *P на буфер, содержащий порядок конечного поля.               */
/* - Размер L в 32-разрядных словах полей B, P.                              */
/* Выход:                                                                    */
/* - Результат умножения B*B (mod P) замещает операнд в поле B.              */
/*───────────────────────────────────────────────────────────────────────────*/

int     CrypC_LCuAdd(struct LR34_10_2001 *Context, struct LPoint *B, struct LPoint *C);
/*───────────────────────────────────────────────────────────────────────────*/
/* Вычисляет сумму двух различных точек B и C на кривой, описанной           */
/* контекстом.                                                               */
/*───────────────────────────────────────────────────────────────────────────*/
/* Помещает результат сложения в поле параметра B.                           */
/* Точки - в проективных координатах, т.е., каждая есть три вектора (X,Y,Z)  */
/* по CuNP слов.                                                             */
/*───────────────────────────────────────────────────────────────────────────*/

int     CrypC_LCuDub(struct LR34_10_2001 *Context, struct LPoint *B);
/*───────────────────────────────────────────────────────────────────────────*/
/* Вычисляет результат удвоения точки B на кривой, описанной контекстом.     */
/*───────────────────────────────────────────────────────────────────────────*/
/* Помещает результат сложения в поле параметра B.                           */
/* Точки - в проективных координатах, т.е., каждая есть три вектора (X,Y,Z)  */
/* по CuNP слов.                                                             */
/*───────────────────────────────────────────────────────────────────────────*/

int     CrypC_LAffiToProj(struct LR34_10_2001 *Context, struct LPoint *B);
/*───────────────────────────────────────────────────────────────────────────*/
/* Преобразование точки кривой в  аффинной форме в проективные координаты.   */
/*───────────────────────────────────────────────────────────────────────────*/
/* Точка B - три координаты по mod P:                                        */
/*         на входе  - (Xv,Yv,Undefined),                                    */
/*         на выходе - (Xp,Yp,Zp) = (Xv,Yv,1).                               */
/*───────────────────────────────────────────────────────────────────────────*/

int     CrypC_LProjToAffi(struct LR34_10_2001 *Context, struct LPoint *B);
/*───────────────────────────────────────────────────────────────────────────*/
/* Преобразование точки кривой в аффинную форму из проективных координат.    */
/*───────────────────────────────────────────────────────────────────────────*/
/* Точка B - три координаты по mod P:                                        */
/*         на входе  - (Xp,Yp,Zp),                                           */
/*         на выходе - (Xv,Yv,Zv=Undefined),                                 */
/*                     (Xv,Yv) = (Xp/(Zp^2),Yp/(Zp^3)),                      */
/* Поле Zv не очищаю, в нём остаётся 1/Zp.                                   */
/*───────────────────────────────────────────────────────────────────────────*/

int     CrypC_LIntToMont(struct LR34_10_2001 *Context, struct LPoint *B);
/*───────────────────────────────────────────────────────────────────────────*/
/* Отображение координат точки кривой в Montgomery Domain.                   */
/*───────────────────────────────────────────────────────────────────────────*/

int     CrypC_LMontToInt(struct LR34_10_2001 *Context, struct LPoint *B);
/*───────────────────────────────────────────────────────────────────────────*/
/* Отображение координат точки кривой из Montgomery Domain в Z.              */
/*───────────────────────────────────────────────────────────────────────────*/

void    CrypC_LCuModuloPQ(DWORD *Dividend, struct LR34_10_2001 *Context);
/*───────────────────────────────────────────────────────────────────────────*/
/* Приведение по модулю Q числа P-длины (Curve-контекст).                    */
/*───────────────────────────────────────────────────────────────────────────*/

void    CrypC_LCuModuloQQ(DWORD *Dividend, struct LR34_10_2001 *Context);
/*───────────────────────────────────────────────────────────────────────────*/
/* Приведение по модулю Q числа Q-длины (Curve-контекст).                    */
/*───────────────────────────────────────────────────────────────────────────*/

int     CrypC_Lcmp_LC(int L, DWORD *Left, DWORD *Rigt);
/*───────────────────────────────────────────────────────────────────────────*/
/*    Сравнение двух длинных беззнаковых чисел длины L 32-разрядных слов.    */
/*───────────────────────────────────────────────────────────────────────────*/
/* Возвращает <=> 0.                                                         */
/*───────────────────────────────────────────────────────────────────────────*/

int     CrypC_Lsub_LC(int L, DWORD *Left, DWORD *Rigt);
/*───────────────────────────────────────────────────────────────────────────*/
/*    Вычитание двух длинных беззнаковых чисел длины L 32-разрядных слов:    */
/*                      Left -= Rigt (mod 2**(32*L))                         */
/*───────────────────────────────────────────────────────────────────────────*/
/* Возвращает <=> 0.                                                         */
/*───────────────────────────────────────────────────────────────────────────*/

int     CrypC_Ladd_LC(int L, DWORD *Left, DWORD *Rigt);
/*───────────────────────────────────────────────────────────────────────────*/
/*     Сложение двух длинных беззнаковых чисел длины L 32-разрядных слов:    */
/*                      Left += Rigt (mod 2**(32*L))                         */
/*───────────────────────────────────────────────────────────────────────────*/
/* Возвращает перенос за пределы рабочего поля.                              */
/*───────────────────────────────────────────────────────────────────────────*/

int     CrypC__add_LbC(int L, BYTE *Left, BYTE *Rigt);
/*───────────────────────────────────────────────────────────────────────────*/
/*     Сложение двух длинных беззнаковых чисел длины L  8-разрядных слов:    */
/*                      Left += Rigt (mod 2**(8*L))                          */
/*───────────────────────────────────────────────────────────────────────────*/
/* Возвращает перенос за пределы рабочего поля.                              */
/*───────────────────────────────────────────────────────────────────────────*/

void    CrypC_Ldiv_LC (int L, DWORD *Dividend, DWORD *Divisor, DWORD *Quotient, DWORD *Rest);
/*───────────────────────────────────────────────────────────────────────────*/
/* Деление с остатком длинного беззнакового числа длины L 32-разрядных слов  */
/* на длинное беззнаковое число длины L 32-разрядных слов.                   */
/*───────────────────────────────────────────────────────────────────────────*/

void    CrypC_Ladd_PC(int L, DWORD *Left, DWORD *Rigt, DWORD *P);
/*───────────────────────────────────────────────────────────────────────────*/
/*    Сложение двух длинных беззнаковых чисел длины L 32-разрядных слов по   */
/*                      модулю P той же длины:                               */
/*                      Left += Rigt (mod P).                                */
/*───────────────────────────────────────────────────────────────────────────*/

void    CrypC_Lsub_PC(int L, DWORD *Left, DWORD *Rigt, DWORD *P);
/*───────────────────────────────────────────────────────────────────────────*/
/*   Вычитание двух длинных беззнаковых чисел длины L 32-разрядных слов по   */
/*                      модулю P той же длины:                               */
/*                      Left += Rigt (mod P).                                */
/*───────────────────────────────────────────────────────────────────────────*/

int     CrypC_Lshl_LC(int L, DWORD *F);
/*───────────────────────────────────────────────────────────────────────────*/
/* Сдвиг влево на 1 разряд длинного беззнакового числа длины L 32-разрядных  */
/*                                  слов.                                    */
/*───────────────────────────────────────────────────────────────────────────*/
/* Возвращает значение разряда, сдвинутого за пределы рабочего поля.         */
/*───────────────────────────────────────────────────────────────────────────*/

int     CrypC_Lshr_LC(int L, DWORD *F);
/*───────────────────────────────────────────────────────────────────────────*/
/* Сдвиг вправо на 1 разряд длинного беззнакового числа длины L 32-разрядных */
/*                                  слов.                                    */
/*───────────────────────────────────────────────────────────────────────────*/
/* Возвращает значение разряда, сдвинутого за пределы рабочего поля.         */
/*───────────────────────────────────────────────────────────────────────────*/

void    CrypC__GOSTE (DWORD *K, DWORD *X, DWORD *P, DWORD *C);
/*───────────────────────────────────────────────────────────────────────────*/
/* Процедура зашифрования блока данных в режиме простой замены ГОСТ 28147-89 */
/*                          на замаскированном ключе                         */
/*───────────────────────────────────────────────────────────────────────────*/
/* Входные параметры:                                                        */
/* - Указатель на буфер K модифицированных подстановок.                      */
/* - Указатель на буфер (NK*4*2 байт) ключа шифрования *X, замаскированного  */
/*   процедурой Mask_SecretKey_.                                             */
/* - Указатель на блок (8 байт) открытого текста *P.                         */
/* - Указатель на блок (8 байт) для шифрованного текста *С.                  */
/* Выход:                                                                    */
/* - Блок шифрованного текста (8 байт), размещенный в буфере *C.             */
/*───────────────────────────────────────────────────────────────────────────*/

void    CrypC__GOSTE_(DWORD *K, DWORD *X, DWORD *P, DWORD *C);
/*───────────────────────────────────────────────────────────────────────────*/
/* Процедура зашифрования блока данных в режиме простой замены ГОСТ 28147-89 */
/*                         на незамаскированном ключе                        */
/*───────────────────────────────────────────────────────────────────────────*/
/* Входные параметры:                                                        */
/* - Указатель на буфер K модифицированных подстановок.                      */
/* - Указатель на буфер (NK*4 байт) ключа шифрования *X.                     */
/* - Указатель на блок (8 байт) открытого текста *P.                         */
/* - Указатель на блок (8 байт) для шифрованного текста *С.                  */
/* Выход:                                                                    */
/* - Блок шифрованного текста (8 байт), размещенный в буфере *C.             */
/*───────────────────────────────────────────────────────────────────────────*/

void    CrypC__GOSTD (DWORD *K, DWORD *X, DWORD *P, DWORD *C);
/*───────────────────────────────────────────────────────────────────────────*/
/*       Процедура расшифрования блока данных в режиме простой замены        */
/*                ГОСТ 28147-89 на замаскированном ключе                     */
/*───────────────────────────────────────────────────────────────────────────*/
/* Входные параметры:                                                        */
/* - Указатель на буфер K модифицированных подстановок.                      */
/* - Указатель на буфер (NK*4*2 байта) ключа шифрования *X, замаскированного */
/*   процедурой Mask_SecretKey_.                                             */
/* - Указатель на блок (8 байт) шифрованного текста *P.                      */
/* - Указатель на блок (8 байт) для открытого текста *С.                     */
/* Выход:                                                                    */
/* - Блок открытого текста (8 байт), размещенный в буфере *C.                */
/*───────────────────────────────────────────────────────────────────────────*/

void    CrypC__GOSTD_(DWORD *K, DWORD *X, DWORD *P, DWORD *C);
/*───────────────────────────────────────────────────────────────────────────*/
/*       Процедура расшифрования блока данных в режиме простой замены        */
/*               ГОСТ 28147-89 на незамаскированном ключе                    */
/*───────────────────────────────────────────────────────────────────────────*/
/* Входные параметры:                                                        */
/* - Указатель на буфер K модифицированных подстановок.                      */
/* - Указатель на буфер (NK*4 байта) ключа шифрования *X.                    */
/* - Указатель на блок (8 байт) шифрованного текста *P.                      */
/* - Указатель на блок (8 байт) для открытого текста *С.                     */
/* Выход:                                                                    */
/* - Блок открытого текста (8 байт), размещенный в буфере *C.                */
/*───────────────────────────────────────────────────────────────────────────*/


void    CrypC__GOSTA (DWORD *K, DWORD *X, DWORD *I, DWORD *P);
/*───────────────────────────────────────────────────────────────────────────*/
/*            Процедура вычисления имитовектора по ГОСТ 28147-89             */
/*                         на замаскированном ключе                          */
/*───────────────────────────────────────────────────────────────────────────*/
/* Входные параметры:                                                        */
/* - Указатель на буфер K модифицированных подстановок.                      */
/* - Указатель на буфер (NK*4*2 байт) ключа шифрования *X, замаскированного  */
/*   процедурой Mask_SecretKey_.                                             */
/* - Указатель на блок (8 байт) текущего состояния имитовектора *I.          */
/* - Указатель на блок (8 байт) открытого текста *P.                         */
/* Выход:                                                                    */
/* - Новое состояние имитовектора (8 байт), размещенное в буфере *I.         */
/*───────────────────────────────────────────────────────────────────────────*/

void    CrypC__GOSTA_(DWORD *K, DWORD *X, DWORD *I, DWORD *P);
/*───────────────────────────────────────────────────────────────────────────*/
/*            Процедура вычисления имитовектора по ГОСТ 28147-89             */
/*                        на незамаскированном ключе                         */
/*───────────────────────────────────────────────────────────────────────────*/
/* Входные параметры:                                                        */
/* - Указатель на буфер K модифицированных подстановок.                      */
/* - Указатель на буфер (NK*4 байт) ключа шифрования *X.                     */
/* - Указатель на блок (8 байт) текущего состояния имитовектора *I.          */
/* - Указатель на блок (8 байт) открытого текста *P.                         */
/* Выход:                                                                    */
/* - Новое состояние имитовектора (8 байт), размещенное в буфере *I.         */
/*───────────────────────────────────────────────────────────────────────────*/

int     CrypC_Mask_SecretKey_( struct RND_State *State, void  *Sec );
/*───────────────────────────────────────────────────────────────────────────*/
/*             Формирование поля маскированного секретного ключа             */
/*───────────────────────────────────────────────────────────────────────────*/
/* Входные параметры:                                                        */
/* - Секретный ключ - первые NK*4 байт NK*4*2-байтового поля ключа *Sec.     */
/* Выход:                                                                    */
/* - Замаскированный секретный ключ замещает секретный ключ в первых NK*2    */
/*   байтах поля Sec.                                                        */
/* - Маска секретного ключа размещается в последних NK*4 байтах поля Sec.    */
/* - Секретный ключ есть результат пословного (слово длины 32 бита) сложения */
/*   по модулю 2**32 вектора замаскированного секретного ключа и вектора     */
/*   маски.                                                                  */
/*───────────────────────────────────────────────────────────────────────────*/

int     CrypC_ReMask_SecretKey_( struct RND_State *State, void  *Sec );
/*───────────────────────────────────────────────────────────────────────────*/
/*              Изменение маски маскированного секретного ключа              */
/*───────────────────────────────────────────────────────────────────────────*/
/* Входные параметры:                                                        */
/* - Маскированный секретный ключ - NK*4*2-байтовое поле ключа *Sec.         */
/* Выход:                                                                    */
/* - Замаскированный секретный ключ замещает секретный ключ в первых NK*4    */
/*   байтах поля Sec.                                                        */
/* - Маска секретного ключа размещается в последних NK*4 байтах поля Sec.    */
/* - Секретный ключ есть результат пословного (слово длины 32 бита) сложения */
/*   по модулю 2**32 вектора замаскированного секретного ключа и вектора     */
/*   маски.                                                                  */
/*───────────────────────────────────────────────────────────────────────────*/

int     CrypC_Gen_SecretKey_( struct RND_State *State, void  *Sec, int Keys );
/*───────────────────────────────────────────────────────────────────────────*/
/*       Генерация Keys псевдослучайных двоичных ключей длины NK*4 байт      */
/* Входные параметры:                                                        */
/*───────────────────────────────────────────────────────────────────────────*/
/* - Поле ключа *Sec (Keys*NK*4 байта).                                      */
/* Выход:                                                                    */
/* - Keys псевдослучайных двоичных ключей в поле *Sec.                       */
/*───────────────────────────────────────────────────────────────────────────*/

/*ПРОТОТИПы*ФУНКЦИЙ*НИЗКОГО*УРОВНЯ****************************************END*/
