#include <stdio.h>
#include "CrC_User.h"

struct DWORD_S
           {
#if BYTE_ORDER == LITTLE_ENDIAN
           BYTE b3,b2,b1,b0;
#else
           BYTE b0,b1,b2,b3;
#endif
           };
/*▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄DEFINES*/
/*▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀_INITGOST */
void CrypC__InitGost( BYTE *Perms, DWORD *K_ )
/* Процедура формирования  модифицированного массива подстановок             */
/* для криптосхемы ГОСТ 28147-89.                                            */
/* Входные параметры:                                                        */
/* - Указатель на буфер Perms (8*16 байт) 8 подстановок на V16               */
/* - Указатель на буфер K_ (4*256 дв. слов) сдвинутых образов при действии   */
/*   попарно перемноженных подстановок на соотв-щие сдвинутые байты из       */
/*   входного дв. слова.                                                     */
/* Выход:                                                                    */
/* - Заполненный буфер K_.                                                   */
{
WORD    i;
BYTE    K0_[4*256];

for (i=0;i<256;i++)
  {
   K0_[i    ] = (Perms[  0+(i>>4)]<<4)^(Perms[ 16+(i&15)]);
   K0_[i+256] = (Perms[ 32+(i>>4)]<<4)^(Perms[ 48+(i&15)]);
   K0_[i+512] = (Perms[ 64+(i>>4)]<<4)^(Perms[ 80+(i&15)]);
   K0_[i+768] = (Perms[ 96+(i>>4)]<<4)^(Perms[112+(i&15)]);
   K_ [i    ] = (DWORD)K0_[i    ] << 24;
   K_ [i+256] = (DWORD)K0_[i+256] << 16;
   K_ [i+512] = (DWORD)K0_[i+512] <<  8;
   K_ [i+768] = (DWORD)K0_[i+768]      ;
  }
}
/*▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄_INITGOST */
/*▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀_CLEARGOST */
void CrypC__ClearGost( struct COM_State *Comm )
/* Процедура очищения  модифицированного массива подстановок                 */
/* для криптосхемы ГОСТ 28147-89.                                            */
/* Входные параметры:                                                        */
/* - Указатель на буфер контекста подстановок Comm.                          */
/* Выход:                                                                    */
/* - Очищен буфер K_ контекста Comm.                                         */
{
memset(Comm->K_,0,16*256);
}
/*▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄_CLEARGOST */
/*▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀GOSTE */
void CrypC__GOSTE( DWORD *K,
                   DWORD *X,
                   DWORD *P,
                   DWORD *C)
/* Процедура зашифрования блока данных в режиме простой замены ГОСТ 28147-89 */
/*                          на замаскированном ключе                         */
/* Входные параметры:                                                        */
/* - Указатель на буфер K модифицированных подстановок.                      */
/* - Указатель на буфер (NK*4*2 байта) ключа шифрования *X, замаскированного */
/*   процедурой Mask_SecretKey_.                                             */
/* - Указатель на блок (8 байт) открытого текста *P.                         */
/* - Указатель на блок (8 байт) для шифрованного текста *С.                  */
/* Выход:                                                                    */
/* - Блок шифрованного текста (8 байт), размещенный в буфере *C.             */
{
DWORD a, b, c, d;
struct DWORD_S *A;
DWORD *K0, *K1, *K2, *K3;

//									fprintf(stderr,"K=%08lX\n",(DWORD)K);
//									fprintf(stderr,"X=%08lX\n",(DWORD)X);
//									fprintf(stderr,"P=%08lX\n",(DWORD)P);
//									fprintf(stderr,"C=%08lX\n",(DWORD)C);
//									fprintf(stderr,"E=%08lX\n",(DWORD)E);


K0 = K      ;
K1 = K + 256;
K2 = K + 512;
K3 = K + 768;

A  = (struct DWORD_S *)&a;

a = P[0];
b = P[1];
/*▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄*/
/*▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀*/
d  = a;
a +=     X[0] + X[ 8]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[1] + X[ 9]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; d ^= (c << 11) ^ (c >> 21);
a  = d + X[2] + X[10]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[3] + X[11]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; d ^= (c << 11) ^ (c >> 21);
a  = d + X[4] + X[12]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[5] + X[13]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; d ^= (c << 11) ^ (c >> 21);
a  = d + X[6] + X[14]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[7] + X[15]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; d ^= (c << 11) ^ (c >> 21);
/*▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄*/
/*▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀*/
a  = d + X[0] + X[ 8]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[1] + X[ 9]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; d ^= (c << 11) ^ (c >> 21);
a  = d + X[2] + X[10]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[3] + X[11]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; d ^= (c << 11) ^ (c >> 21);
a  = d + X[4] + X[12]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[5] + X[13]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; d ^= (c << 11) ^ (c >> 21);
a  = d + X[6] + X[14]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[7] + X[15]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; d ^= (c << 11) ^ (c >> 21);
/*▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄*/
/*▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀*/
a  = d + X[0] + X[ 8]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[1] + X[ 9]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; d ^= (c << 11) ^ (c >> 21);
a  = d + X[2] + X[10]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[3] + X[11]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; d ^= (c << 11) ^ (c >> 21);
a  = d + X[4] + X[12]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[5] + X[13]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; d ^= (c << 11) ^ (c >> 21);
a  = d + X[6] + X[14]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[7] + X[15]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; d ^= (c << 11) ^ (c >> 21);
/*▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄*/
/*▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀*/
a  = d + X[7] + X[15]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[6] + X[14]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; d ^= (c << 11) ^ (c >> 21);
a  = d + X[5] + X[13]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[4] + X[12]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; d ^= (c << 11) ^ (c >> 21);
a  = d + X[3] + X[11]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[2] + X[10]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; d ^= (c << 11) ^ (c >> 21);
a  = d + X[1] + X[ 9]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[0] + X[ 8]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; a  = (c << 11) ^ (c >> 21);
a ^= d;
/*▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄*/
/*▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀*/
C[1] = a;
C[0] = b;
}
/*▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄GOSTE */
/*▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀GOSTE_*/
void CrypC__GOSTE_( DWORD *K,
                    DWORD *X,
                    DWORD *P,
                    DWORD *C)
/* Процедура зашифрования блока данных в режиме простой замены ГОСТ 28147-89 */
/*                         на незамаскированном ключе                        */
/* Входные параметры:                                                        */
/* - Указатель на буфер K модифицированных подстановок.                      */
/* - Указатель на буфер (NK*4 байта) ключа шифрования *X.                    */
/* - Указатель на блок (8 байт) открытого текста *P.                         */
/* - Указатель на блок (8 байт) для шифрованного текста *С.                  */
/* Выход:                                                                    */
/* - Блок шифрованного текста (8 байт), размещенный в буфере *C.             */
{
DWORD a, b, c, d;
struct DWORD_S *A;
DWORD *K0, *K1, *K2, *K3;

//									printf("P=%08lX%08lX\n",P[0],P[1]);

K0 = K      ;
K1 = K + 256;
K2 = K + 512;
K3 = K + 768;

A  = (struct DWORD_S *)&a;

a = P[0];
b = P[1];
/*▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄*/
/*▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀*/
d  = a;
a +=     X[0]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[1]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; d ^= (c << 11) ^ (c >> 21);
a  = d + X[2]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[3]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; d ^= (c << 11) ^ (c >> 21);
a  = d + X[4]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[5]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; d ^= (c << 11) ^ (c >> 21);
a  = d + X[6]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[7]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; d ^= (c << 11) ^ (c >> 21);
/*▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄*/
/*▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀*/
a  = d + X[0]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[1]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; d ^= (c << 11) ^ (c >> 21);
a  = d + X[2]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[3]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; d ^= (c << 11) ^ (c >> 21);
a  = d + X[4]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[5]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; d ^= (c << 11) ^ (c >> 21);
a  = d + X[6]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[7]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; d ^= (c << 11) ^ (c >> 21);
/*▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄*/
/*▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀*/
a  = d + X[0]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[1]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; d ^= (c << 11) ^ (c >> 21);
a  = d + X[2]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[3]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; d ^= (c << 11) ^ (c >> 21);
a  = d + X[4]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[5]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; d ^= (c << 11) ^ (c >> 21);
a  = d + X[6]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[7]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; d ^= (c << 11) ^ (c >> 21);
/*▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄*/
/*▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀*/
a  = d + X[7]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[6]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; d ^= (c << 11) ^ (c >> 21);
a  = d + X[5]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[4]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; d ^= (c << 11) ^ (c >> 21);
a  = d + X[3]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[2]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; d ^= (c << 11) ^ (c >> 21);
a  = d + X[1]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[0]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; a  = (c << 11) ^ (c >> 21);
a ^= d;
/*▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄*/
/*▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀*/
C[1] = a;
C[0] = b;
//									printf("C=%08lX%08lX\n",C[0],C[1]);
}
/*▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄GOSTE_*/
/*▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀GOSTD */
void CrypC__GOSTD( DWORD *K,
                   DWORD *X,
                   DWORD *P,
                   DWORD *C)
/* Процедура расшифрования блока данных в режиме простой замены ГОСТ 28147-89 */
/*                          на замаскированном ключе                          */
/* Входные параметры:                                                         */
/* - Указатель на буфер K модифицированных подстановок.                       */
/* - Указатель на буфер (NK*4*2 байта) ключа шифрования *X, замаскированного  */
/*   процедурой Mask_SecretKey_.                                              */
/* - Указатель на блок (8 байт) шифрованного текста *P.                       */
/* - Указатель на блок (8 байт) для открытого текста *С.                      */
/* Выход:                                                                     */
/* - Блок открытого текста (8 байт), размещенный в буфере *C.                 */
{
DWORD a, b, c, d;
struct DWORD_S *A;
DWORD *K0, *K1, *K2, *K3;

//									fprintf(stderr,"K=%08lX\n",(DWORD)K);
//									fprintf(stderr,"X=%08lX\n",(DWORD)X);
//									fprintf(stderr,"P=%08lX\n",(DWORD)P);
//									fprintf(stderr,"C=%08lX\n",(DWORD)C);
//									fprintf(stderr,"E=%08lX\n",(DWORD)E);


K0 = K      ;
K1 = K + 256;
K2 = K + 512;
K3 = K + 768;

A  = (struct DWORD_S *)&a;

a = P[0];
b = P[1];
/*▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄*/
/*▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀*/
d  = a;
a +=     X[0] + X[ 8]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[1] + X[ 9]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; d ^= (c << 11) ^ (c >> 21);
a  = d + X[2] + X[10]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[3] + X[11]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; d ^= (c << 11) ^ (c >> 21);
a  = d + X[4] + X[12]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[5] + X[13]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; d ^= (c << 11) ^ (c >> 21);
a  = d + X[6] + X[14]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[7] + X[15]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; d ^= (c << 11) ^ (c >> 21);
/*▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄*/
/*▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀*/
a  = d + X[7] + X[15]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[6] + X[14]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; d ^= (c << 11) ^ (c >> 21);
a  = d + X[5] + X[13]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[4] + X[12]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; d ^= (c << 11) ^ (c >> 21);
a  = d + X[3] + X[11]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[2] + X[10]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; d ^= (c << 11) ^ (c >> 21);
a  = d + X[1] + X[ 9]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[0] + X[ 8]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; d ^= (c << 11) ^ (c >> 21);
/*▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄*/
/*▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀*/
a  = d + X[7] + X[15]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[6] + X[14]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; d ^= (c << 11) ^ (c >> 21);
a  = d + X[5] + X[13]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[4] + X[12]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; d ^= (c << 11) ^ (c >> 21);
a  = d + X[3] + X[11]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[2] + X[10]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; d ^= (c << 11) ^ (c >> 21);
a  = d + X[1] + X[ 9]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[0] + X[ 8]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; d ^= (c << 11) ^ (c >> 21);
/*▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄*/
/*▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀*/
a  = d + X[7] + X[15]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[6] + X[14]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; d ^= (c << 11) ^ (c >> 21);
a  = d + X[5] + X[13]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[4] + X[12]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; d ^= (c << 11) ^ (c >> 21);
a  = d + X[3] + X[11]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[2] + X[10]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; d ^= (c << 11) ^ (c >> 21);
a  = d + X[1] + X[ 9]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[0] + X[ 8]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; a  = (c << 11) ^ (c >> 21);
a ^= d;
/*▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄*/
/*▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀*/
C[1] = a;
C[0] = b;
}
/*▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄GOSTD */
/*▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀GOSTD_*/
void CrypC__GOSTD_( DWORD *K,
                    DWORD *X,
                    DWORD *P,
                    DWORD *C)
/* Процедура расшифрования блока данных в режиме простой замены ГОСТ 28147-89 */
/*                         на незамаскированном ключе                         */
/* Входные параметры:                                                         */
/* - Указатель на буфер K модифицированных подстановок.                       */
/* - Указатель на буфер (NK*4 байта) ключа шифрования *X.                     */
/* - Указатель на блок (8 байт) шифрованного текста *P.                       */
/* - Указатель на блок (8 байт) для открытого текста *С.                      */
/* Выход:                                                                     */
/* - Блок открытого текста (8 байт), размещенный в буфере *C.                 */
{
DWORD a, b, c, d;
struct DWORD_S *A;
DWORD *K0, *K1, *K2, *K3;

//									printf("P=%08lX%08lX\n",P[0],P[1]);

K0 = K      ;
K1 = K + 256;
K2 = K + 512;
K3 = K + 768;

A  = (struct DWORD_S *)&a;

a = P[0];
b = P[1];
/*▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄*/
/*▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀*/
d  = a;
a +=     X[0]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[1]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; d ^= (c << 11) ^ (c >> 21);
a  = d + X[2]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[3]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; d ^= (c << 11) ^ (c >> 21);
a  = d + X[4]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[5]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; d ^= (c << 11) ^ (c >> 21);
a  = d + X[6]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[7]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; d ^= (c << 11) ^ (c >> 21);
/*▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄*/
/*▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀*/
a  = d + X[7]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[6]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; d ^= (c << 11) ^ (c >> 21);
a  = d + X[5]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[4]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; d ^= (c << 11) ^ (c >> 21);
a  = d + X[3]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[2]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; d ^= (c << 11) ^ (c >> 21);
a  = d + X[1]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[0]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; d ^= (c << 11) ^ (c >> 21);
/*▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄*/
/*▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀*/
a  = d + X[7]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[6]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; d ^= (c << 11) ^ (c >> 21);
a  = d + X[5]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[4]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; d ^= (c << 11) ^ (c >> 21);
a  = d + X[3]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[2]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; d ^= (c << 11) ^ (c >> 21);
a  = d + X[1]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[0]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; d ^= (c << 11) ^ (c >> 21);
/*▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄*/
/*▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀*/
a  = d + X[7]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[6]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; d ^= (c << 11) ^ (c >> 21);
a  = d + X[5]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[4]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; d ^= (c << 11) ^ (c >> 21);
a  = d + X[3]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[2]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; d ^= (c << 11) ^ (c >> 21);
a  = d + X[1]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; b ^= (c << 11) ^ (c >> 21);
a  = b + X[0]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; a  = (c << 11) ^ (c >> 21);
a ^= d;
/*▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄*/
/*▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀*/
C[1] = a;
C[0] = b;
//									printf("C=%08lX%08lX\n",C[0],C[1]);
}
/*▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄GOSTВ_*/
/*▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀GOSTA */
void CrypC__GOSTA( DWORD *K,
                   DWORD *X,
                   DWORD *I,
                   DWORD *P)
/*            Процедура вычисления имитовектора по ГОСТ 28147-89             */
/*                         на замаскированном ключе                          */
/* Входные параметры:                                                        */
/* - Указатель на буфер K модифицированных подстановок.                      */
/* - Указатель на буфер (NK*4*2 байта) ключа шифрования *X, замаскированного */
/*   процедурой Mask_SecretKey_.                                             */
/* - Указатель на блок (8 байт) текущего состояния имитовектора *I.          */
/* - Указатель на блок (8 байт) открытого текста *P.                         */
/* Выход:                                                                    */
/* - Новое состояние имитовектора (8 байт), размещенное в буфере *I.         */
{
DWORD a, b, c, d;
struct DWORD_S *A;
DWORD *K0, *K1, *K2, *K3;

K0 = K      ;
K1 = K + 256;
K2 = K + 512;
K3 = K + 768;

A  = (struct DWORD_S *)&a;

a = I[0] ^ P[0];
b = I[1] ^ P[1];
/*▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄*/
/*▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀*/
d  = a;
a +=     X[0] + X[ 8]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; a  = (c << 11) ^ (c >> 21); b ^= a;
a  = b + X[1] + X[ 9]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; a  = (c << 11) ^ (c >> 21); d ^= a;
a  = d + X[2] + X[10]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; a  = (c << 11) ^ (c >> 21); b ^= a;
a  = b + X[3] + X[11]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; a  = (c << 11) ^ (c >> 21); d ^= a;
a  = d + X[4] + X[12]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; a  = (c << 11) ^ (c >> 21); b ^= a;
a  = b + X[5] + X[13]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; a  = (c << 11) ^ (c >> 21); d ^= a;
a  = d + X[6] + X[14]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; a  = (c << 11) ^ (c >> 21); b ^= a;
a  = b + X[7] + X[15]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; a  = (c << 11) ^ (c >> 21);
/*▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄*/
/*▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀*/
d ^= a;
a  = d + X[0] + X[ 8]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; a  = (c << 11) ^ (c >> 21); b ^= a;
a  = b + X[1] + X[ 9]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; a  = (c << 11) ^ (c >> 21); d ^= a;
a  = d + X[2] + X[10]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; a  = (c << 11) ^ (c >> 21); b ^= a;
a  = b + X[3] + X[11]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; a  = (c << 11) ^ (c >> 21); d ^= a;
a  = d + X[4] + X[12]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; a  = (c << 11) ^ (c >> 21); b ^= a;
a  = b + X[5] + X[13]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; a  = (c << 11) ^ (c >> 21); d ^= a;
a  = d + X[6] + X[14]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; a  = (c << 11) ^ (c >> 21); b ^= a;
a  = b + X[7] + X[15]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; a  = (c << 11) ^ (c >> 21); a ^= d;
/*▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄*/
/*▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀*/
I[0] = a;
I[1] = b;
}
/*▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄GOSTA */
/*▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀GOSTA_*/
void CrypC__GOSTA_( DWORD *K,
                    DWORD *X,
                    DWORD *I,
                    DWORD *P)
/*            Процедура вычисления имитовектора по ГОСТ 28147-89             */
/*                        на незамаскированном ключе                         */
/* Входные параметры:                                                        */
/* - Указатель на буфер K модифицированных подстановок.                      */
/* - Указатель на буфер (NK*4 байта) ключа шифрования *X.                    */
/* - Указатель на блок (8 байт) текущего состояния имитовектора *I.          */
/* - Указатель на блок (8 байт) открытого текста *P.                         */
/* Выход:                                                                    */
/* - Новое состояние имитовектора (8 байт), размещенное в буфере *I.         */
{
DWORD a, b, c, d;
struct DWORD_S *A;
DWORD *K0, *K1, *K2, *K3;

K0 = K      ;
K1 = K + 256;
K2 = K + 512;
K3 = K + 768;

A  = (struct DWORD_S *)&a;

a = I[0] ^ P[0];
b = I[1] ^ P[1];
/*▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄*/
/*▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀*/
d  = a;
a +=     X[0]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; a  = (c << 11) ^ (c >> 21); b ^= a;
a  = b + X[1]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; a  = (c << 11) ^ (c >> 21); d ^= a;
a  = d + X[2]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; a  = (c << 11) ^ (c >> 21); b ^= a;
a  = b + X[3]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; a  = (c << 11) ^ (c >> 21); d ^= a;
a  = d + X[4]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; a  = (c << 11) ^ (c >> 21); b ^= a;
a  = b + X[5]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; a  = (c << 11) ^ (c >> 21); d ^= a;
a  = d + X[6]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; a  = (c << 11) ^ (c >> 21); b ^= a;
a  = b + X[7]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; a  = (c << 11) ^ (c >> 21);
/*▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄*/
/*▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀*/
d ^= a;
a  = d + X[0]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; a  = (c << 11) ^ (c >> 21); b ^= a;
a  = b + X[1]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; a  = (c << 11) ^ (c >> 21); d ^= a;
a  = d + X[2]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; a  = (c << 11) ^ (c >> 21); b ^= a;
a  = b + X[3]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; a  = (c << 11) ^ (c >> 21); d ^= a;
a  = d + X[4]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; a  = (c << 11) ^ (c >> 21); b ^= a;
a  = b + X[5]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; a  = (c << 11) ^ (c >> 21); d ^= a;
a  = d + X[6]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; a  = (c << 11) ^ (c >> 21); b ^= a;
a  = b + X[7]; c  = K0[A->b0] ^ K1[A->b1] ^ K2[A->b2] ^ K3[A->b3] ; a  = (c << 11) ^ (c >> 21); a ^= d;
/*▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄*/
/*▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀*/
I[0] = a;
I[1] = b;
}
/*▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄GOSTA_*/
/*▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀EOF*/
