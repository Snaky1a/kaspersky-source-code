#ifndef _KLPRTSDEFS_H_
#define _KLPRTSDEFS_H_
/*KLCSAK_PUBLIC_HEADER*/

namespace KLPRTS
{
/*KLCSAK_BEGIN_PRIVATE*/
typedef std::vector< std::wstring > TASK_PARAMS_NAMES;
/*KLCSAK_END_PRIVATE*/
//////////////////////////////////////////////////////////////////////////
// Value names to store task list in Settings Storage
const wchar_t SS_PRODUCT_NAME[] = L"PRTS";
const wchar_t SS_VERSION[] = L"1.0";
const wchar_t SS_SECTION_NAME[] = L"TASKS";
const wchar_t SS_TASK_STORAGE_SETTINGS_VALUE_NAME[] = L"TASKS_SETTINGS";

// Task params
const wchar_t SS_VALUE_NAME_TASK_CLASS_ID[] = L"TASK_CLASS_ID";
const wchar_t SS_VALUE_NAME_TASK_PRIORITY[] = L"TASK_PRIORITY";
const wchar_t SS_VALUE_NAME_TASK_MAX_EXEC_TIME[] = L"TASK_MAX_EXEC_TIME";
const wchar_t SS_VALUE_NAME_TASK_DEL_AFTER_RUN_FLAG[] = L"TASK_DEL_AFTER_RUN_FLAG";
const wchar_t SS_VALUE_NAME_TASK_LAST_EXEC_TIME[] = L"TASK_LAST_EXEC_TIME";
const wchar_t SS_VALUE_NAME_TASK_LAST_EXEC_TIME_SEC[] = L"TASK_LAST_EXEC_TIME_SEC";
const wchar_t SS_VALUE_NAME_TASK_START_DELTA[] = L"TASK_START_DELTA";
const wchar_t SS_VALUE_NAME_TASK_PREPARATIVE_START[] = L"TASK_PREP_START";

// External task params
const wchar_t SS_VALUE_NAME_TASK_NAME[] = L"TASK_NAME";
const wchar_t SS_VALUE_NAME_TASKID_PRODUCT_NAME[] = L"TASKID_PRODUCT_NAME";
const wchar_t SS_VALUE_NAME_TASKID_VERSION[] = L"TASKID_VERSION";
const wchar_t SS_VALUE_NAME_TASKID_COMPONENT_NAME[] = L"TASKID_COMPONENT_NAME";
const wchar_t SS_VALUE_NAME_TASKID_INSTANCE_ID[] = L"TASKID_INSTANCE_ID";
const wchar_t SS_VALUE_NAME_TASK_UNIQUE_ID[] = L"TASK_UNIQUE_ID";
const wchar_t SS_VALUE_NAME_TASK_ADDITIONAL_PARAMS[] = L"TASK_ADDITIONAL_PARAMS";
const wchar_t SS_VALUE_NAME_TASK_INFO_PARAMS[] = L"TASK_INFO_PARAMS";

const wchar_t SS_VALUE_NAME_FILTER_EVENTS_PRODUCT_NAME[] = L"FILTER_EVENTS_PRODUCT_NAME";
const wchar_t SS_VALUE_NAME_FILTER_EVENTS_VERSION[] = L"FILTER_EVENTS_VERSION";
const wchar_t SS_VALUE_NAME_FILTER_EVENTS_COMPONENT_NAME[] = L"FILTER_EVENTS_COMPONENT_NAME";
const wchar_t SS_VALUE_NAME_FILTER_EVENTS_INSTANCE_ID[] = L"FILTER_EVENTS_INSTANCE_ID";

const wchar_t SS_VALUE_NAME_EVENT_TYPE[] = L"EVENT_TYPE";
const wchar_t SS_VALUE_NAME_EVENT_BODY_FILTER[] = L"EVENT_BODY_FILTER";

// Task schedule
const wchar_t SS_VALUE_NAME_TASKSCH_RUN_MISSED_FLAG[] = L"TASKSCH_RUN_MISSED_FLAG";
const wchar_t SS_VALUE_NAME_TASKSCH_LIFETIME[] = L"TASKSCH_LIFETIME";
const wchar_t SS_VALUE_NAME_TASKSCH_FIRST_EXECUTION_TIME[] = L"TASKSCH_FIRST_EXECUTION_TIME";
const wchar_t SS_VALUE_NAME_TASKSCH_FIRST_EXECUTION_TIME_SEC[] = L"TASKSCH_FIRST_EXECUTION_TIME_SEC";

// Schedule type specific settings

const wchar_t SS_VALUE_NAME_TASKSCH_TYPE[] = L"TASKSCH_TYPE";

// SecondsSchedule
const wchar_t SS_VALUE_NAME_TASKSCH_SSECONDS_PERIOD[] = L"TASKSCH_SECONDS_PERIOD";

// MillisecondsSchedule
const wchar_t SS_VALUE_NAME_TASKSCH_MS_PERIOD[] = L"TASKSCH_MS_PERIOD";
// EverydaySchedule
const wchar_t SS_VALUE_NAME_TASKSCH_ED_HOURS[] = L"TASKSCH_ED_HOURS";
const wchar_t SS_VALUE_NAME_TASKSCH_ED_MINS[] = L"TASKSCH_ED_MINS";
const wchar_t SS_VALUE_NAME_TASKSCH_ED_SECS[] = L"TASKSCH_ED_SECS";

// EveryWeekSchedule
const wchar_t SS_VALUE_NAME_TASKSCH_EW_DAY[] = L"TASKSCH_EW_DAY";
const wchar_t SS_VALUE_NAME_TASKSCH_EW_HOURS[] = L"TASKSCH_EW_HOURS";
const wchar_t SS_VALUE_NAME_TASKSCH_EW_MINS[] = L"TASKSCH_EW_MINS";
const wchar_t SS_VALUE_NAME_TASKSCH_EW_SECS[] = L"TASKSCH_EW_SECS";

// EveryMonthSchedule
const wchar_t SS_VALUE_NAME_TASKSCH_EM_DAY[] = L"TASKSCH_EM_DAY";
const wchar_t SS_VALUE_NAME_TASKSCH_EM_HOURS[] = L"TASKSCH_EM_HOURS";
const wchar_t SS_VALUE_NAME_TASKSCH_EM_MINS[] = L"TASKSCH_EM_MINS";
const wchar_t SS_VALUE_NAME_TASKSCH_EM_SECS[] = L"TASKSCH_EM_SECS";

// WeeksDaysSchedule
const wchar_t SS_VALUE_NAME_TASKSCH_WEEKDDAYS[] = L"TASKSCH_WEEKSDAYS";
const wchar_t SS_VALUE_NAME_TASKSCH_WD_DAYS[] = L"TASKSCH_WD_DAYS";
const wchar_t SS_VALUE_NAME_TASKSCH_WD_HOURS[] = L"TASKSCH_WD_HOURS";
const wchar_t SS_VALUE_NAME_TASKSCH_WD_MINS[] = L"TASKSCH_WD_MINS";
const wchar_t SS_VALUE_NAME_TASKSCH_WD_SECS[] = L"TASKSCH_WD_SECS";

/*KLCSAK_BEGIN_PRIVATE*/
//////////////////////////////////////////////////////////////////////////
// Проверка кода возврата для методов класса Task
#define CHECK_RESULT(func) \
{ \
	Errors rcl = func; \
	if (rcl != KLSCH::ERR_NONE) KLERR_THROW0(KLCS_MODULENAME, rcl); \
}
/*KLCSAK_END_PRIVATE*/
};

#endif

