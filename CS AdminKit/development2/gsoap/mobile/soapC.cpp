/* soapC.cpp
   Generated by gSOAP 2.7.0d from soapheader.h
   Copyright (C) 2001-2004 Genivia, Inc. All Rights Reserved.
   This software is released under one of the following three licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
   See README.txt for further details.
*/
#include "soapH.h"

SOAP_BEGIN_NAMESPACE(soap)

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.7.0d 2007-04-10 12:48:28 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL);
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = (struct SOAP_ENV__Fault*)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault));
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version != 1 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	for (;;)
		if (!soap_getelement(soap, &t))
			if (soap->error || soap_ignore_element(soap))
				break;
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}

SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_xsd__byte:
		return soap_in_xsd__byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_xsd__short:
		return soap_in_xsd__short(soap, NULL, NULL, "xsd:short");
	case SOAP_TYPE_short:
		return soap_in_short(soap, NULL, NULL, "xsd:short");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_xsd__int:
		return soap_in_xsd__int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_long:
		return soap_in_long(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_xsd__long:
		return soap_in_xsd__long(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_LONG64:
		return soap_in_LONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_xsd__float:
		return soap_in_xsd__float(soap, NULL, NULL, "xsd:float");
	case SOAP_TYPE_float:
		return soap_in_float(soap, NULL, NULL, "xsd:float");
	case SOAP_TYPE_xsd__double:
		return soap_in_xsd__double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_double:
		return soap_in_double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_xsd__unsignedByte:
		return soap_in_xsd__unsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedByte:
		return soap_in_unsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_xsd__unsignedShort:
		return soap_in_xsd__unsignedShort(soap, NULL, NULL, "xsd:unsignedShort");
	case SOAP_TYPE_unsignedShort:
		return soap_in_unsignedShort(soap, NULL, NULL, "xsd:unsignedShort");
	case SOAP_TYPE_unsignedInt:
		return soap_in_unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_xsd__unsignedInt:
		return soap_in_xsd__unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_unsignedLong:
		return soap_in_unsignedLong(soap, NULL, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_xsd__unsignedLong:
		return soap_in_xsd__unsignedLong(soap, NULL, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_unsignedLONG64:
		return soap_in_unsignedLONG64(soap, NULL, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_param__null:
		return soap_in_param__null(soap, NULL, NULL, "param:null");
	case SOAP_TYPE_xsd__boolean:
		return soap_in_xsd__boolean(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_aklwngt__CmdAppState:
		return soap_in_aklwngt__CmdAppState(soap, NULL, NULL, "aklwngt:CmdAppState");
	case SOAP_TYPE_aklwngt__CmdAppInfo:
		return soap_in_aklwngt__CmdAppInfo(soap, NULL, NULL, "aklwngt:CmdAppInfo");
	case SOAP_TYPE_aklwngt__CmdSubscriptions:
		return soap_in_aklwngt__CmdSubscriptions(soap, NULL, NULL, "aklwngt:CmdSubscriptions");
	case SOAP_TYPE_aklwngt__CmdParAndHash:
		return soap_in_aklwngt__CmdParAndHash(soap, NULL, NULL, "aklwngt:CmdParAndHash");
	case SOAP_TYPE_aklwngt__CmdPar:
		return soap_in_aklwngt__CmdPar(soap, NULL, NULL, "aklwngt:CmdPar");
	case SOAP_TYPE_aklwngt__CmdHash:
		return soap_in_aklwngt__CmdHash(soap, NULL, NULL, "aklwngt:CmdHash");
	case SOAP_TYPE_aklwngt__CmdError:
		return soap_in_aklwngt__CmdError(soap, NULL, NULL, "aklwngt:CmdError");
	case SOAP_TYPE_aklwngt__anyCmd:
		return soap_in_aklwngt__anyCmd(soap, NULL, NULL, "aklwngt:anyCmd");
	case SOAP_TYPE_param__arrayvalue:
		return soap_in_param__arrayvalue(soap, NULL, NULL, "param:arrayvalue");
	case SOAP_TYPE_param__params:
		return soap_in_param__params(soap, NULL, NULL, "param:params");
	case SOAP_TYPE_param__node:
		return soap_in_param__node(soap, NULL, NULL, "param:node");
	case SOAP_TYPE_param__entry:
		return soap_in_param__entry(soap, NULL, NULL, "param:entry");
	case SOAP_TYPE_param__value:
		return soap_in_param__value(soap, NULL, NULL, "param:value");
	case SOAP_TYPE_param_error_loc:
		return soap_in_param_error_loc(soap, NULL, NULL, "param-error-loc");
	case SOAP_TYPE_param_error_loc_args:
		return soap_in_param_error_loc_args(soap, NULL, NULL, "xsd:wstring");
	case SOAP_TYPE_xsd__hexBinary:
		return soap_in_xsd__hexBinary(soap, NULL, NULL, "xsd:hexBinary");
	case SOAP_TYPE_xsd__base64Binary:
		return soap_in_xsd__base64Binary(soap, NULL, NULL, "xsd:base64Binary");
	case SOAP_TYPE_xsd__token_:
		return soap_in_xsd__token_(soap, NULL, NULL, "xsd:token");
	case SOAP_TYPE_xsd__normalizedString_:
		return soap_in_xsd__normalizedString_(soap, NULL, NULL, "xsd:normalizedString");
	case SOAP_TYPE_xsd__string_:
		return soap_in_xsd__string_(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_xsd__wstring_:
		return soap_in_xsd__wstring_(soap, NULL, NULL, "xsd:wstring");
	case SOAP_TYPE_xsd__unsignedByte_:
		return soap_in_xsd__unsignedByte_(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_xsd__unsignedShort_:
		return soap_in_xsd__unsignedShort_(soap, NULL, NULL, "xsd:unsignedShort");
	case SOAP_TYPE_xsd__unsignedInt_:
		return soap_in_xsd__unsignedInt_(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_xsd__unsignedLong_:
		return soap_in_xsd__unsignedLong_(soap, NULL, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_xsd__positiveInteger_:
		return soap_in_xsd__positiveInteger_(soap, NULL, NULL, "xsd:positiveInteger");
	case SOAP_TYPE_xsd__nonNegativeInteger_:
		return soap_in_xsd__nonNegativeInteger_(soap, NULL, NULL, "xsd:nonNegativeInteger");
	case SOAP_TYPE_xsd__negativeInteger_:
		return soap_in_xsd__negativeInteger_(soap, NULL, NULL, "xsd:negativeInteger");
	case SOAP_TYPE_xsd__nonPositiveInteger_:
		return soap_in_xsd__nonPositiveInteger_(soap, NULL, NULL, "xsd:nonPositiveInteger");
	case SOAP_TYPE_xsd__byte_:
		return soap_in_xsd__byte_(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_xsd__short_:
		return soap_in_xsd__short_(soap, NULL, NULL, "xsd:short");
	case SOAP_TYPE_xsd__int_:
		return soap_in_xsd__int_(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_xsd__long_:
		return soap_in_xsd__long_(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_xsd__integer_:
		return soap_in_xsd__integer_(soap, NULL, NULL, "xsd:integer");
	case SOAP_TYPE_xsd__decimal_:
		return soap_in_xsd__decimal_(soap, NULL, NULL, "xsd:decimal");
	case SOAP_TYPE_xsd__time_:
		return soap_in_xsd__time_(soap, NULL, NULL, "xsd:time");
	case SOAP_TYPE_xsd__float_:
		return soap_in_xsd__float_(soap, NULL, NULL, "xsd:float");
	case SOAP_TYPE_xsd__duration_:
		return soap_in_xsd__duration_(soap, NULL, NULL, "xsd:duration");
	case SOAP_TYPE_xsd__double_:
		return soap_in_xsd__double_(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_xsd__dateTime_:
		return soap_in_xsd__dateTime_(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_xsd__date_:
		return soap_in_xsd__date_(soap, NULL, NULL, "xsd:date");
	case SOAP_TYPE_xsd__boolean_:
		return soap_in_xsd__boolean_(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_xsd__anyURI_:
		return soap_in_xsd__anyURI_(soap, NULL, NULL, "xsd:anyURI");
	case SOAP_TYPE_xsd__anySimpleType:
		return soap_in_xsd__anySimpleType(soap, NULL, NULL, "xsd:anySimpleType");
	case SOAP_TYPE_xsd__anyType:
		return soap_in_xsd__anyType(soap, NULL, NULL, "xsd:anyType");
	case SOAP_TYPE_aklwngt__klft_GetNextFileChunk:
		return soap_in_aklwngt__klft_GetNextFileChunk(soap, NULL, NULL, "aklwngt:klft-GetNextFileChunk");
	case SOAP_TYPE_aklwngt__klft_GetNextFileChunkResponse:
		return soap_in_aklwngt__klft_GetNextFileChunkResponse(soap, NULL, NULL, "aklwngt:klft-GetNextFileChunkResponse");
	case SOAP_TYPE_aklwngt__klft_GetFileInfo:
		return soap_in_aklwngt__klft_GetFileInfo(soap, NULL, NULL, "aklwngt:klft-GetFileInfo");
	case SOAP_TYPE_aklwngt__klft_GetFileInfoResponse:
		return soap_in_aklwngt__klft_GetFileInfoResponse(soap, NULL, NULL, "aklwngt:klft-GetFileInfoResponse");
	case SOAP_TYPE_aklwngt__PutEvents:
		return soap_in_aklwngt__PutEvents(soap, NULL, NULL, "aklwngt:PutEvents");
	case SOAP_TYPE_aklwngt__PutEventsResponse:
		return soap_in_aklwngt__PutEventsResponse(soap, NULL, NULL, "aklwngt:PutEventsResponse");
	case SOAP_TYPE_aklwngt__PutResult:
		return soap_in_aklwngt__PutResult(soap, NULL, NULL, "aklwngt:PutResult");
	case SOAP_TYPE_aklwngt__PutResultResponse:
		return soap_in_aklwngt__PutResultResponse(soap, NULL, NULL, "aklwngt:PutResultResponse");
	case SOAP_TYPE_aklwngt__Heartbeat:
		return soap_in_aklwngt__Heartbeat(soap, NULL, NULL, "aklwngt:Heartbeat");
	case SOAP_TYPE_aklwngt__HeartbeatResponse:
		return soap_in_aklwngt__HeartbeatResponse(soap, NULL, NULL, "aklwngt:HeartbeatResponse");
	case SOAP_TYPE_aklwngt__SessionEnd:
		return soap_in_aklwngt__SessionEnd(soap, NULL, NULL, "aklwngt:SessionEnd");
	case SOAP_TYPE_aklwngt__SessionEndResponse:
		return soap_in_aklwngt__SessionEndResponse(soap, NULL, NULL, "aklwngt:SessionEndResponse");
	case SOAP_TYPE_aklwngt__SessionBegin:
		return soap_in_aklwngt__SessionBegin(soap, NULL, NULL, "aklwngt:SessionBegin");
	case SOAP_TYPE_aklwngt__SessionBeginResponse:
		return soap_in_aklwngt__SessionBeginResponse(soap, NULL, NULL, "aklwngt:SessionBeginResponse");
	case SOAP_TYPE_aklwngt__klft_file_info_t:
		return soap_in_aklwngt__klft_file_info_t(soap, NULL, NULL, "aklwngt:klft-file-info-t");
	case SOAP_TYPE_aklwngt__klft_file_chunk_t:
		return soap_in_aklwngt__klft_file_chunk_t(soap, NULL, NULL, "aklwngt:klft-file-chunk-t");
	case SOAP_TYPE_aklwngt__klft_file_chunk_buff:
		return soap_in_aklwngt__klft_file_chunk_buff(soap, NULL, NULL, "aklwngt:klft-file-chunk-buff");
	case SOAP_TYPE_aklwngt__event_info_array:
		return soap_in_aklwngt__event_info_array(soap, NULL, NULL, "aklwngt:event-info-array");
	case SOAP_TYPE_aklwngt__event_info:
		return soap_in_aklwngt__event_info(soap, NULL, NULL, "aklwngt:event-info");
	case SOAP_TYPE_aklwngt__event_body:
		return soap_in_aklwngt__event_body(soap, NULL, NULL, "aklwngt:event-body");
	case SOAP_TYPE_aklwngt__sync_info:
		return soap_in_aklwngt__sync_info(soap, NULL, NULL, "aklwngt:sync-info");
	case SOAP_TYPE_aklwngt__command:
		return soap_in_aklwngt__command(soap, NULL, NULL, "aklwngt:command");
	case SOAP_TYPE_aklwngt__LicenseInfo:
		return soap_in_aklwngt__LicenseInfo(soap, NULL, NULL, "aklwngt:LicenseInfo");
	case SOAP_TYPE_aklwngt__LicKeyInfo:
		return soap_in_aklwngt__LicKeyInfo(soap, NULL, NULL, "aklwngt:LicKeyInfo");
	case SOAP_TYPE_aklwngt__ProdInfo:
		return soap_in_aklwngt__ProdInfo(soap, NULL, NULL, "aklwngt:ProdInfo");
	case SOAP_TYPE_aklwngt__DevInfo:
		return soap_in_aklwngt__DevInfo(soap, NULL, NULL, "aklwngt:DevInfo");
	case SOAP_TYPE_aklwngt__string_array:
		return soap_in_aklwngt__string_array(soap, NULL, NULL, "aklwngt:string-array");
	case SOAP_TYPE_param_error:
		return soap_in_param_error(soap, NULL, NULL, "param-error");
	case SOAP_TYPE_PointerToaklwngt__event_info_array:
		return soap_in_PointerToaklwngt__event_info_array(soap, NULL, NULL, "aklwngt:event-info-array");
	case SOAP_TYPE_PointerToaklwngt__command:
		return soap_in_PointerToaklwngt__command(soap, NULL, NULL, "aklwngt:command");
	case SOAP_TYPE_PointerToaklwngt__sync_info:
		return soap_in_PointerToaklwngt__sync_info(soap, NULL, NULL, "aklwngt:sync-info");
	case SOAP_TYPE_PointerToparam_error:
		return soap_in_PointerToparam_error(soap, NULL, NULL, "param-error");
	case SOAP_TYPE_PointerToxsd__unsignedByte:
		return soap_in_PointerToxsd__unsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_PointerToaklwngt__event_info:
		return soap_in_PointerToaklwngt__event_info(soap, NULL, NULL, "aklwngt:event-info");
	case SOAP_TYPE_PointerToaklwngt__anyCmd:
		return soap_in_PointerToaklwngt__anyCmd(soap, NULL, NULL, "aklwngt:anyCmd");
	case SOAP_TYPE_PointerToaklwngt__LicKeyInfo:
		return soap_in_PointerToaklwngt__LicKeyInfo(soap, NULL, NULL, "aklwngt:LicKeyInfo");
	case SOAP_TYPE_PointerToxsd__string:
		return soap_in_PointerToxsd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerToparam__value:
		return soap_in_PointerToparam__value(soap, NULL, NULL, "param:value");
	case SOAP_TYPE_PointerToparam__node:
		return soap_in_PointerToparam__node(soap, NULL, NULL, "param:node");
	case SOAP_TYPE_PointerToparam__entry:
		return soap_in_PointerToparam__entry(soap, NULL, NULL, "param:entry");
	case SOAP_TYPE_PointerToxsd__anyType:
		return soap_in_PointerToxsd__anyType(soap, NULL, NULL, "xsd:anyType");
	case SOAP_TYPE_PointerToparam_error_loc:
		return soap_in_PointerToparam_error_loc(soap, NULL, NULL, "param-error-loc");
	case SOAP_TYPE_PointerToxsd__wstring:
		return soap_in_PointerToxsd__wstring(soap, NULL, NULL, "xsd:wstring");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_in_PointerTounsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_xsd__token:
	{	char **s;
		s = soap_in_xsd__token(soap, NULL, NULL, "xsd:token");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__normalizedString:
	{	char **s;
		s = soap_in_xsd__normalizedString(soap, NULL, NULL, "xsd:normalizedString");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__string:
	{	char **s;
		s = soap_in_xsd__string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__wstring:
	{	wchar_t **s;
		s = soap_in_xsd__wstring(soap, NULL, NULL, "xsd:wstring");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wstring:
	{	wchar_t **s;
		s = soap_in_wstring(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__positiveInteger:
	{	char **s;
		s = soap_in_xsd__positiveInteger(soap, NULL, NULL, "xsd:positiveInteger");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__nonNegativeInteger:
	{	char **s;
		s = soap_in_xsd__nonNegativeInteger(soap, NULL, NULL, "xsd:nonNegativeInteger");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__negativeInteger:
	{	char **s;
		s = soap_in_xsd__negativeInteger(soap, NULL, NULL, "xsd:negativeInteger");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__nonPositiveInteger:
	{	char **s;
		s = soap_in_xsd__nonPositiveInteger(soap, NULL, NULL, "xsd:nonPositiveInteger");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__integer:
	{	char **s;
		s = soap_in_xsd__integer(soap, NULL, NULL, "xsd:integer");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__decimal:
	{	char **s;
		s = soap_in_xsd__decimal(soap, NULL, NULL, "xsd:decimal");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__time:
	{	char **s;
		s = soap_in_xsd__time(soap, NULL, NULL, "xsd:time");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__duration:
	{	char **s;
		s = soap_in_xsd__duration(soap, NULL, NULL, "xsd:duration");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__dateTime:
	{	char **s;
		s = soap_in_xsd__dateTime(soap, NULL, NULL, "xsd:dateTime");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__date:
	{	char **s;
		s = soap_in_xsd__date(soap, NULL, NULL, "xsd:date");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__anyURI:
	{	char **s;
		s = soap_in_xsd__anyURI(soap, NULL, NULL, "xsd:anyURI");
		return s ? *s : NULL;
	}
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_xsd__byte;
			return soap_in_xsd__byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:short"))
		{	*type = SOAP_TYPE_xsd__short;
			return soap_in_xsd__short(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:short"))
		{	*type = SOAP_TYPE_short;
			return soap_in_short(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_xsd__int;
			return soap_in_xsd__int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_long;
			return soap_in_long(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_xsd__long;
			return soap_in_xsd__long(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_LONG64;
			return soap_in_LONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:float"))
		{	*type = SOAP_TYPE_xsd__float;
			return soap_in_xsd__float(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:float"))
		{	*type = SOAP_TYPE_float;
			return soap_in_float(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_xsd__double;
			return soap_in_xsd__double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_double;
			return soap_in_double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_xsd__unsignedByte;
			return soap_in_xsd__unsignedByte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_unsignedByte;
			return soap_in_unsignedByte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedShort"))
		{	*type = SOAP_TYPE_xsd__unsignedShort;
			return soap_in_xsd__unsignedShort(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedShort"))
		{	*type = SOAP_TYPE_unsignedShort;
			return soap_in_unsignedShort(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_xsd__unsignedInt;
			return soap_in_xsd__unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedLong"))
		{	*type = SOAP_TYPE_unsignedLong;
			return soap_in_unsignedLong(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedLong"))
		{	*type = SOAP_TYPE_xsd__unsignedLong;
			return soap_in_xsd__unsignedLong(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedLong"))
		{	*type = SOAP_TYPE_unsignedLONG64;
			return soap_in_unsignedLONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "param:null"))
		{	*type = SOAP_TYPE_param__null;
			return soap_in_param__null(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_xsd__boolean;
			return soap_in_xsd__boolean(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "aklwngt:CmdAppState"))
		{	*type = SOAP_TYPE_aklwngt__CmdAppState;
			return soap_in_aklwngt__CmdAppState(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "aklwngt:CmdAppInfo"))
		{	*type = SOAP_TYPE_aklwngt__CmdAppInfo;
			return soap_in_aklwngt__CmdAppInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "aklwngt:CmdSubscriptions"))
		{	*type = SOAP_TYPE_aklwngt__CmdSubscriptions;
			return soap_in_aklwngt__CmdSubscriptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "aklwngt:CmdParAndHash"))
		{	*type = SOAP_TYPE_aklwngt__CmdParAndHash;
			return soap_in_aklwngt__CmdParAndHash(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "aklwngt:CmdPar"))
		{	*type = SOAP_TYPE_aklwngt__CmdPar;
			return soap_in_aklwngt__CmdPar(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "aklwngt:CmdHash"))
		{	*type = SOAP_TYPE_aklwngt__CmdHash;
			return soap_in_aklwngt__CmdHash(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "aklwngt:CmdError"))
		{	*type = SOAP_TYPE_aklwngt__CmdError;
			return soap_in_aklwngt__CmdError(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "aklwngt:anyCmd"))
		{	*type = SOAP_TYPE_aklwngt__anyCmd;
			return soap_in_aklwngt__anyCmd(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "param:arrayvalue"))
		{	*type = SOAP_TYPE_param__arrayvalue;
			return soap_in_param__arrayvalue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "param:params"))
		{	*type = SOAP_TYPE_param__params;
			return soap_in_param__params(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "param:node"))
		{	*type = SOAP_TYPE_param__node;
			return soap_in_param__node(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "param:entry"))
		{	*type = SOAP_TYPE_param__entry;
			return soap_in_param__entry(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "param:value"))
		{	*type = SOAP_TYPE_param__value;
			return soap_in_param__value(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "param-error-loc"))
		{	*type = SOAP_TYPE_param_error_loc;
			return soap_in_param_error_loc(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "xsd:wstring"))
		{	*type = SOAP_TYPE_param_error_loc_args;
			return soap_in_param_error_loc_args(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:hexBinary"))
		{	*type = SOAP_TYPE_xsd__hexBinary;
			return soap_in_xsd__hexBinary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:base64Binary"))
		{	*type = SOAP_TYPE_xsd__base64Binary;
			return soap_in_xsd__base64Binary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:token"))
		{	*type = SOAP_TYPE_xsd__token_;
			return soap_in_xsd__token_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:normalizedString"))
		{	*type = SOAP_TYPE_xsd__normalizedString_;
			return soap_in_xsd__normalizedString_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_xsd__string_;
			return soap_in_xsd__string_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:wstring"))
		{	*type = SOAP_TYPE_xsd__wstring_;
			return soap_in_xsd__wstring_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_xsd__unsignedByte_;
			return soap_in_xsd__unsignedByte_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedShort"))
		{	*type = SOAP_TYPE_xsd__unsignedShort_;
			return soap_in_xsd__unsignedShort_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_xsd__unsignedInt_;
			return soap_in_xsd__unsignedInt_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedLong"))
		{	*type = SOAP_TYPE_xsd__unsignedLong_;
			return soap_in_xsd__unsignedLong_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:positiveInteger"))
		{	*type = SOAP_TYPE_xsd__positiveInteger_;
			return soap_in_xsd__positiveInteger_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:nonNegativeInteger"))
		{	*type = SOAP_TYPE_xsd__nonNegativeInteger_;
			return soap_in_xsd__nonNegativeInteger_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:negativeInteger"))
		{	*type = SOAP_TYPE_xsd__negativeInteger_;
			return soap_in_xsd__negativeInteger_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:nonPositiveInteger"))
		{	*type = SOAP_TYPE_xsd__nonPositiveInteger_;
			return soap_in_xsd__nonPositiveInteger_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_xsd__byte_;
			return soap_in_xsd__byte_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:short"))
		{	*type = SOAP_TYPE_xsd__short_;
			return soap_in_xsd__short_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_xsd__int_;
			return soap_in_xsd__int_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_xsd__long_;
			return soap_in_xsd__long_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:integer"))
		{	*type = SOAP_TYPE_xsd__integer_;
			return soap_in_xsd__integer_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:decimal"))
		{	*type = SOAP_TYPE_xsd__decimal_;
			return soap_in_xsd__decimal_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:time"))
		{	*type = SOAP_TYPE_xsd__time_;
			return soap_in_xsd__time_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:float"))
		{	*type = SOAP_TYPE_xsd__float_;
			return soap_in_xsd__float_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:duration"))
		{	*type = SOAP_TYPE_xsd__duration_;
			return soap_in_xsd__duration_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_xsd__double_;
			return soap_in_xsd__double_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_xsd__dateTime_;
			return soap_in_xsd__dateTime_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:date"))
		{	*type = SOAP_TYPE_xsd__date_;
			return soap_in_xsd__date_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_xsd__boolean_;
			return soap_in_xsd__boolean_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyURI"))
		{	*type = SOAP_TYPE_xsd__anyURI_;
			return soap_in_xsd__anyURI_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anySimpleType"))
		{	*type = SOAP_TYPE_xsd__anySimpleType;
			return soap_in_xsd__anySimpleType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyType"))
		{	*type = SOAP_TYPE_xsd__anyType;
			return soap_in_xsd__anyType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "aklwngt:klft-GetNextFileChunk"))
		{	*type = SOAP_TYPE_aklwngt__klft_GetNextFileChunk;
			return soap_in_aklwngt__klft_GetNextFileChunk(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "aklwngt:klft-GetNextFileChunkResponse"))
		{	*type = SOAP_TYPE_aklwngt__klft_GetNextFileChunkResponse;
			return soap_in_aklwngt__klft_GetNextFileChunkResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "aklwngt:klft-GetFileInfo"))
		{	*type = SOAP_TYPE_aklwngt__klft_GetFileInfo;
			return soap_in_aklwngt__klft_GetFileInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "aklwngt:klft-GetFileInfoResponse"))
		{	*type = SOAP_TYPE_aklwngt__klft_GetFileInfoResponse;
			return soap_in_aklwngt__klft_GetFileInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "aklwngt:PutEvents"))
		{	*type = SOAP_TYPE_aklwngt__PutEvents;
			return soap_in_aklwngt__PutEvents(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "aklwngt:PutEventsResponse"))
		{	*type = SOAP_TYPE_aklwngt__PutEventsResponse;
			return soap_in_aklwngt__PutEventsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "aklwngt:PutResult"))
		{	*type = SOAP_TYPE_aklwngt__PutResult;
			return soap_in_aklwngt__PutResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "aklwngt:PutResultResponse"))
		{	*type = SOAP_TYPE_aklwngt__PutResultResponse;
			return soap_in_aklwngt__PutResultResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "aklwngt:Heartbeat"))
		{	*type = SOAP_TYPE_aklwngt__Heartbeat;
			return soap_in_aklwngt__Heartbeat(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "aklwngt:HeartbeatResponse"))
		{	*type = SOAP_TYPE_aklwngt__HeartbeatResponse;
			return soap_in_aklwngt__HeartbeatResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "aklwngt:SessionEnd"))
		{	*type = SOAP_TYPE_aklwngt__SessionEnd;
			return soap_in_aklwngt__SessionEnd(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "aklwngt:SessionEndResponse"))
		{	*type = SOAP_TYPE_aklwngt__SessionEndResponse;
			return soap_in_aklwngt__SessionEndResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "aklwngt:SessionBegin"))
		{	*type = SOAP_TYPE_aklwngt__SessionBegin;
			return soap_in_aklwngt__SessionBegin(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "aklwngt:SessionBeginResponse"))
		{	*type = SOAP_TYPE_aklwngt__SessionBeginResponse;
			return soap_in_aklwngt__SessionBeginResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "aklwngt:klft-file-info-t"))
		{	*type = SOAP_TYPE_aklwngt__klft_file_info_t;
			return soap_in_aklwngt__klft_file_info_t(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "aklwngt:klft-file-chunk-t"))
		{	*type = SOAP_TYPE_aklwngt__klft_file_chunk_t;
			return soap_in_aklwngt__klft_file_chunk_t(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "aklwngt:klft-file-chunk-buff"))
		{	*type = SOAP_TYPE_aklwngt__klft_file_chunk_buff;
			return soap_in_aklwngt__klft_file_chunk_buff(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "aklwngt:event-info-array"))
		{	*type = SOAP_TYPE_aklwngt__event_info_array;
			return soap_in_aklwngt__event_info_array(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "aklwngt:event-info"))
		{	*type = SOAP_TYPE_aklwngt__event_info;
			return soap_in_aklwngt__event_info(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "aklwngt:event-body"))
		{	*type = SOAP_TYPE_aklwngt__event_body;
			return soap_in_aklwngt__event_body(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "aklwngt:sync-info"))
		{	*type = SOAP_TYPE_aklwngt__sync_info;
			return soap_in_aklwngt__sync_info(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "aklwngt:command"))
		{	*type = SOAP_TYPE_aklwngt__command;
			return soap_in_aklwngt__command(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "aklwngt:LicenseInfo"))
		{	*type = SOAP_TYPE_aklwngt__LicenseInfo;
			return soap_in_aklwngt__LicenseInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "aklwngt:LicKeyInfo"))
		{	*type = SOAP_TYPE_aklwngt__LicKeyInfo;
			return soap_in_aklwngt__LicKeyInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "aklwngt:ProdInfo"))
		{	*type = SOAP_TYPE_aklwngt__ProdInfo;
			return soap_in_aklwngt__ProdInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "aklwngt:DevInfo"))
		{	*type = SOAP_TYPE_aklwngt__DevInfo;
			return soap_in_aklwngt__DevInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "aklwngt:string-array"))
		{	*type = SOAP_TYPE_aklwngt__string_array;
			return soap_in_aklwngt__string_array(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "param-error"))
		{	*type = SOAP_TYPE_param_error;
			return soap_in_param_error(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:token"))
		{	char **s;
			*type = SOAP_TYPE_xsd__token;
			s = soap_in_xsd__token(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:normalizedString"))
		{	char **s;
			*type = SOAP_TYPE_xsd__normalizedString;
			s = soap_in_xsd__normalizedString(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_xsd__string;
			s = soap_in_xsd__string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:positiveInteger"))
		{	char **s;
			*type = SOAP_TYPE_xsd__positiveInteger;
			s = soap_in_xsd__positiveInteger(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:nonNegativeInteger"))
		{	char **s;
			*type = SOAP_TYPE_xsd__nonNegativeInteger;
			s = soap_in_xsd__nonNegativeInteger(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:negativeInteger"))
		{	char **s;
			*type = SOAP_TYPE_xsd__negativeInteger;
			s = soap_in_xsd__negativeInteger(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:nonPositiveInteger"))
		{	char **s;
			*type = SOAP_TYPE_xsd__nonPositiveInteger;
			s = soap_in_xsd__nonPositiveInteger(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:integer"))
		{	char **s;
			*type = SOAP_TYPE_xsd__integer;
			s = soap_in_xsd__integer(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:decimal"))
		{	char **s;
			*type = SOAP_TYPE_xsd__decimal;
			s = soap_in_xsd__decimal(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:time"))
		{	char **s;
			*type = SOAP_TYPE_xsd__time;
			s = soap_in_xsd__time(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:duration"))
		{	char **s;
			*type = SOAP_TYPE_xsd__duration;
			s = soap_in_xsd__duration(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	char **s;
			*type = SOAP_TYPE_xsd__dateTime;
			s = soap_in_xsd__dateTime(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:date"))
		{	char **s;
			*type = SOAP_TYPE_xsd__date;
			s = soap_in_xsd__date(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:anyURI"))
		{	char **s;
			*type = SOAP_TYPE_xsd__anyURI;
			s = soap_in_xsd__anyURI(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{	if (!soap_peek_element(soap))
	{	int t;
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
			return soap->error = SOAP_TAG_MISMATCH;
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unknown element '%s' (level=%u, %d)\n", soap->tag, soap->level, soap->body));
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_xsd__byte:
		return soap_out_xsd__byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_xsd__short:
		return soap_out_xsd__short(soap, tag, id, (const short *)ptr, "xsd:short");
	case SOAP_TYPE_short:
		return soap_out_short(soap, tag, id, (const short *)ptr, "xsd:short");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_xsd__int:
		return soap_out_xsd__int(soap, tag, id, (const long *)ptr, "xsd:int");
	case SOAP_TYPE_long:
		return soap_out_long(soap, tag, id, (const long *)ptr, "xsd:long");
	case SOAP_TYPE_xsd__long:
		return soap_out_xsd__long(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_LONG64:
		return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_xsd__float:
		return soap_out_xsd__float(soap, tag, id, (const float *)ptr, "xsd:float");
	case SOAP_TYPE_float:
		return soap_out_float(soap, tag, id, (const float *)ptr, "xsd:float");
	case SOAP_TYPE_xsd__double:
		return soap_out_xsd__double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_xsd__unsignedByte:
		return soap_out_xsd__unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedByte:
		return soap_out_unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_xsd__unsignedShort:
		return soap_out_xsd__unsignedShort(soap, tag, id, (const unsigned short *)ptr, "xsd:unsignedShort");
	case SOAP_TYPE_unsignedShort:
		return soap_out_unsignedShort(soap, tag, id, (const unsigned short *)ptr, "xsd:unsignedShort");
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_xsd__unsignedInt:
		return soap_out_xsd__unsignedInt(soap, tag, id, (const unsigned long *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_unsignedLong:
		return soap_out_unsignedLong(soap, tag, id, (const unsigned long *)ptr, "xsd:unsignedLong");
	case SOAP_TYPE_xsd__unsignedLong:
		return soap_out_xsd__unsignedLong(soap, tag, id, (const ULONG64 *)ptr, "xsd:unsignedLong");
	case SOAP_TYPE_unsignedLONG64:
		return soap_out_unsignedLONG64(soap, tag, id, (const ULONG64 *)ptr, "xsd:unsignedLong");
	case SOAP_TYPE_param__null:
		return soap_out_param__null(soap, tag, id, (const bool *)ptr, "param:null");
	case SOAP_TYPE_xsd__boolean:
		return soap_out_xsd__boolean(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_aklwngt__CmdAppState:
		return ((aklwngt__CmdAppState *)ptr)->soap_out(soap, tag, id, "aklwngt:CmdAppState");
	case SOAP_TYPE_aklwngt__CmdAppInfo:
		return ((aklwngt__CmdAppInfo *)ptr)->soap_out(soap, tag, id, "aklwngt:CmdAppInfo");
	case SOAP_TYPE_aklwngt__CmdSubscriptions:
		return ((aklwngt__CmdSubscriptions *)ptr)->soap_out(soap, tag, id, "aklwngt:CmdSubscriptions");
	case SOAP_TYPE_aklwngt__CmdParAndHash:
		return ((aklwngt__CmdParAndHash *)ptr)->soap_out(soap, tag, id, "aklwngt:CmdParAndHash");
	case SOAP_TYPE_aklwngt__CmdPar:
		return ((aklwngt__CmdPar *)ptr)->soap_out(soap, tag, id, "aklwngt:CmdPar");
	case SOAP_TYPE_aklwngt__CmdHash:
		return ((aklwngt__CmdHash *)ptr)->soap_out(soap, tag, id, "aklwngt:CmdHash");
	case SOAP_TYPE_aklwngt__CmdError:
		return ((aklwngt__CmdError *)ptr)->soap_out(soap, tag, id, "aklwngt:CmdError");
	case SOAP_TYPE_aklwngt__anyCmd:
		return ((aklwngt__anyCmd *)ptr)->soap_out(soap, tag, id, "aklwngt:anyCmd");
	case SOAP_TYPE_param__arrayvalue:
		return ((param__arrayvalue *)ptr)->soap_out(soap, tag, id, "param:arrayvalue");
	case SOAP_TYPE_param__params:
		return ((param__params *)ptr)->soap_out(soap, tag, id, "param:params");
	case SOAP_TYPE_param__node:
		return ((param__node *)ptr)->soap_out(soap, tag, id, "param:node");
	case SOAP_TYPE_param__entry:
		return ((param__entry *)ptr)->soap_out(soap, tag, id, "param:entry");
	case SOAP_TYPE_param__value:
		return ((param__value *)ptr)->soap_out(soap, tag, id, "param:value");
	case SOAP_TYPE_param_error_loc:
		return ((param_error_loc *)ptr)->soap_out(soap, tag, id, "param-error-loc");
	case SOAP_TYPE_param_error_loc_args:
		return ((param_error_loc_args *)ptr)->soap_out(soap, tag, id, "xsd:wstring");
	case SOAP_TYPE_xsd__hexBinary:
		return ((xsd__hexBinary *)ptr)->soap_out(soap, tag, id, "xsd:hexBinary");
	case SOAP_TYPE_xsd__base64Binary:
		return ((xsd__base64Binary *)ptr)->soap_out(soap, tag, id, "xsd:base64Binary");
	case SOAP_TYPE_xsd__token_:
		return ((xsd__token_ *)ptr)->soap_out(soap, tag, id, "xsd:token");
	case SOAP_TYPE_xsd__normalizedString_:
		return ((xsd__normalizedString_ *)ptr)->soap_out(soap, tag, id, "xsd:normalizedString");
	case SOAP_TYPE_xsd__string_:
		return ((xsd__string_ *)ptr)->soap_out(soap, tag, id, "xsd:string");
	case SOAP_TYPE_xsd__wstring_:
		return ((xsd__wstring_ *)ptr)->soap_out(soap, tag, id, "xsd:wstring");
	case SOAP_TYPE_xsd__unsignedByte_:
		return ((xsd__unsignedByte_ *)ptr)->soap_out(soap, tag, id, "xsd:unsignedByte");
	case SOAP_TYPE_xsd__unsignedShort_:
		return ((xsd__unsignedShort_ *)ptr)->soap_out(soap, tag, id, "xsd:unsignedShort");
	case SOAP_TYPE_xsd__unsignedInt_:
		return ((xsd__unsignedInt_ *)ptr)->soap_out(soap, tag, id, "xsd:unsignedInt");
	case SOAP_TYPE_xsd__unsignedLong_:
		return ((xsd__unsignedLong_ *)ptr)->soap_out(soap, tag, id, "xsd:unsignedLong");
	case SOAP_TYPE_xsd__positiveInteger_:
		return ((xsd__positiveInteger_ *)ptr)->soap_out(soap, tag, id, "xsd:positiveInteger");
	case SOAP_TYPE_xsd__nonNegativeInteger_:
		return ((xsd__nonNegativeInteger_ *)ptr)->soap_out(soap, tag, id, "xsd:nonNegativeInteger");
	case SOAP_TYPE_xsd__negativeInteger_:
		return ((xsd__negativeInteger_ *)ptr)->soap_out(soap, tag, id, "xsd:negativeInteger");
	case SOAP_TYPE_xsd__nonPositiveInteger_:
		return ((xsd__nonPositiveInteger_ *)ptr)->soap_out(soap, tag, id, "xsd:nonPositiveInteger");
	case SOAP_TYPE_xsd__byte_:
		return ((xsd__byte_ *)ptr)->soap_out(soap, tag, id, "xsd:byte");
	case SOAP_TYPE_xsd__short_:
		return ((xsd__short_ *)ptr)->soap_out(soap, tag, id, "xsd:short");
	case SOAP_TYPE_xsd__int_:
		return ((xsd__int_ *)ptr)->soap_out(soap, tag, id, "xsd:int");
	case SOAP_TYPE_xsd__long_:
		return ((xsd__long_ *)ptr)->soap_out(soap, tag, id, "xsd:long");
	case SOAP_TYPE_xsd__integer_:
		return ((xsd__integer_ *)ptr)->soap_out(soap, tag, id, "xsd:integer");
	case SOAP_TYPE_xsd__decimal_:
		return ((xsd__decimal_ *)ptr)->soap_out(soap, tag, id, "xsd:decimal");
	case SOAP_TYPE_xsd__time_:
		return ((xsd__time_ *)ptr)->soap_out(soap, tag, id, "xsd:time");
	case SOAP_TYPE_xsd__float_:
		return ((xsd__float_ *)ptr)->soap_out(soap, tag, id, "xsd:float");
	case SOAP_TYPE_xsd__duration_:
		return ((xsd__duration_ *)ptr)->soap_out(soap, tag, id, "xsd:duration");
	case SOAP_TYPE_xsd__double_:
		return ((xsd__double_ *)ptr)->soap_out(soap, tag, id, "xsd:double");
	case SOAP_TYPE_xsd__dateTime_:
		return ((xsd__dateTime_ *)ptr)->soap_out(soap, tag, id, "xsd:dateTime");
	case SOAP_TYPE_xsd__date_:
		return ((xsd__date_ *)ptr)->soap_out(soap, tag, id, "xsd:date");
	case SOAP_TYPE_xsd__boolean_:
		return ((xsd__boolean_ *)ptr)->soap_out(soap, tag, id, "xsd:boolean");
	case SOAP_TYPE_xsd__anyURI_:
		return ((xsd__anyURI_ *)ptr)->soap_out(soap, tag, id, "xsd:anyURI");
	case SOAP_TYPE_xsd__anySimpleType:
		return ((xsd__anySimpleType *)ptr)->soap_out(soap, tag, id, "xsd:anySimpleType");
	case SOAP_TYPE_xsd__anyType:
		return ((xsd__anyType *)ptr)->soap_out(soap, tag, id, "xsd:anyType");
	case SOAP_TYPE_aklwngt__klft_GetNextFileChunk:
		return soap_out_aklwngt__klft_GetNextFileChunk(soap, tag, id, (const struct aklwngt__klft_GetNextFileChunk *)ptr, "aklwngt:klft-GetNextFileChunk");
	case SOAP_TYPE_aklwngt__klft_GetNextFileChunkResponse:
		return soap_out_aklwngt__klft_GetNextFileChunkResponse(soap, tag, id, (const struct aklwngt__klft_GetNextFileChunkResponse *)ptr, "aklwngt:klft-GetNextFileChunkResponse");
	case SOAP_TYPE_aklwngt__klft_GetFileInfo:
		return soap_out_aklwngt__klft_GetFileInfo(soap, tag, id, (const struct aklwngt__klft_GetFileInfo *)ptr, "aklwngt:klft-GetFileInfo");
	case SOAP_TYPE_aklwngt__klft_GetFileInfoResponse:
		return soap_out_aklwngt__klft_GetFileInfoResponse(soap, tag, id, (const struct aklwngt__klft_GetFileInfoResponse *)ptr, "aklwngt:klft-GetFileInfoResponse");
	case SOAP_TYPE_aklwngt__PutEvents:
		return soap_out_aklwngt__PutEvents(soap, tag, id, (const struct aklwngt__PutEvents *)ptr, "aklwngt:PutEvents");
	case SOAP_TYPE_aklwngt__PutEventsResponse:
		return soap_out_aklwngt__PutEventsResponse(soap, tag, id, (const struct aklwngt__PutEventsResponse *)ptr, "aklwngt:PutEventsResponse");
	case SOAP_TYPE_aklwngt__PutResult:
		return soap_out_aklwngt__PutResult(soap, tag, id, (const struct aklwngt__PutResult *)ptr, "aklwngt:PutResult");
	case SOAP_TYPE_aklwngt__PutResultResponse:
		return soap_out_aklwngt__PutResultResponse(soap, tag, id, (const struct aklwngt__PutResultResponse *)ptr, "aklwngt:PutResultResponse");
	case SOAP_TYPE_aklwngt__Heartbeat:
		return soap_out_aklwngt__Heartbeat(soap, tag, id, (const struct aklwngt__Heartbeat *)ptr, "aklwngt:Heartbeat");
	case SOAP_TYPE_aklwngt__HeartbeatResponse:
		return soap_out_aklwngt__HeartbeatResponse(soap, tag, id, (const struct aklwngt__HeartbeatResponse *)ptr, "aklwngt:HeartbeatResponse");
	case SOAP_TYPE_aklwngt__SessionEnd:
		return soap_out_aklwngt__SessionEnd(soap, tag, id, (const struct aklwngt__SessionEnd *)ptr, "aklwngt:SessionEnd");
	case SOAP_TYPE_aklwngt__SessionEndResponse:
		return soap_out_aklwngt__SessionEndResponse(soap, tag, id, (const struct aklwngt__SessionEndResponse *)ptr, "aklwngt:SessionEndResponse");
	case SOAP_TYPE_aklwngt__SessionBegin:
		return soap_out_aklwngt__SessionBegin(soap, tag, id, (const struct aklwngt__SessionBegin *)ptr, "aklwngt:SessionBegin");
	case SOAP_TYPE_aklwngt__SessionBeginResponse:
		return soap_out_aklwngt__SessionBeginResponse(soap, tag, id, (const struct aklwngt__SessionBeginResponse *)ptr, "aklwngt:SessionBeginResponse");
	case SOAP_TYPE_aklwngt__klft_file_info_t:
		return soap_out_aklwngt__klft_file_info_t(soap, tag, id, (const struct aklwngt__klft_file_info_t *)ptr, "aklwngt:klft-file-info-t");
	case SOAP_TYPE_aklwngt__klft_file_chunk_t:
		return soap_out_aklwngt__klft_file_chunk_t(soap, tag, id, (const struct aklwngt__klft_file_chunk_t *)ptr, "aklwngt:klft-file-chunk-t");
	case SOAP_TYPE_aklwngt__klft_file_chunk_buff:
		return soap_out_aklwngt__klft_file_chunk_buff(soap, tag, id, (const struct aklwngt__klft_file_chunk_buff *)ptr, "aklwngt:klft-file-chunk-buff");
	case SOAP_TYPE_aklwngt__event_info_array:
		return soap_out_aklwngt__event_info_array(soap, tag, id, (const struct aklwngt__event_info_array *)ptr, "aklwngt:event-info-array");
	case SOAP_TYPE_aklwngt__event_info:
		return soap_out_aklwngt__event_info(soap, tag, id, (const struct aklwngt__event_info *)ptr, "aklwngt:event-info");
	case SOAP_TYPE_aklwngt__event_body:
		return soap_out_aklwngt__event_body(soap, tag, id, (const struct aklwngt__event_body *)ptr, "aklwngt:event-body");
	case SOAP_TYPE_aklwngt__sync_info:
		return soap_out_aklwngt__sync_info(soap, tag, id, (const struct aklwngt__sync_info *)ptr, "aklwngt:sync-info");
	case SOAP_TYPE_aklwngt__command:
		return soap_out_aklwngt__command(soap, tag, id, (const struct aklwngt__command *)ptr, "aklwngt:command");
	case SOAP_TYPE_aklwngt__LicenseInfo:
		return soap_out_aklwngt__LicenseInfo(soap, tag, id, (const struct aklwngt__LicenseInfo *)ptr, "aklwngt:LicenseInfo");
	case SOAP_TYPE_aklwngt__LicKeyInfo:
		return soap_out_aklwngt__LicKeyInfo(soap, tag, id, (const struct aklwngt__LicKeyInfo *)ptr, "aklwngt:LicKeyInfo");
	case SOAP_TYPE_aklwngt__ProdInfo:
		return soap_out_aklwngt__ProdInfo(soap, tag, id, (const struct aklwngt__ProdInfo *)ptr, "aklwngt:ProdInfo");
	case SOAP_TYPE_aklwngt__DevInfo:
		return soap_out_aklwngt__DevInfo(soap, tag, id, (const struct aklwngt__DevInfo *)ptr, "aklwngt:DevInfo");
	case SOAP_TYPE_aklwngt__string_array:
		return soap_out_aklwngt__string_array(soap, tag, id, (const struct aklwngt__string_array *)ptr, "aklwngt:string-array");
	case SOAP_TYPE_param_error:
		return soap_out_param_error(soap, tag, id, (const struct param_error *)ptr, "param-error");
	case SOAP_TYPE_PointerToaklwngt__event_info_array:
		return soap_out_PointerToaklwngt__event_info_array(soap, tag, id, (struct aklwngt__event_info_array *const*)ptr, "aklwngt:event-info-array");
	case SOAP_TYPE_PointerToaklwngt__command:
		return soap_out_PointerToaklwngt__command(soap, tag, id, (struct aklwngt__command *const*)ptr, "aklwngt:command");
	case SOAP_TYPE_PointerToaklwngt__sync_info:
		return soap_out_PointerToaklwngt__sync_info(soap, tag, id, (struct aklwngt__sync_info *const*)ptr, "aklwngt:sync-info");
	case SOAP_TYPE_PointerToparam_error:
		return soap_out_PointerToparam_error(soap, tag, id, (struct param_error *const*)ptr, "param-error");
	case SOAP_TYPE_PointerToxsd__unsignedByte:
		return soap_out_PointerToxsd__unsignedByte(soap, tag, id, (unsigned char *const*)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_PointerToaklwngt__event_info:
		return soap_out_PointerToaklwngt__event_info(soap, tag, id, (struct aklwngt__event_info *const*)ptr, "aklwngt:event-info");
	case SOAP_TYPE_PointerToaklwngt__anyCmd:
		return soap_out_PointerToaklwngt__anyCmd(soap, tag, id, (aklwngt__anyCmd *const*)ptr, "aklwngt:anyCmd");
	case SOAP_TYPE_PointerToaklwngt__LicKeyInfo:
		return soap_out_PointerToaklwngt__LicKeyInfo(soap, tag, id, (struct aklwngt__LicKeyInfo *const*)ptr, "aklwngt:LicKeyInfo");
	case SOAP_TYPE_PointerToxsd__string:
		return soap_out_PointerToxsd__string(soap, tag, id, (char **const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerToparam__value:
		return soap_out_PointerToparam__value(soap, tag, id, (param__value *const*)ptr, "param:value");
	case SOAP_TYPE_PointerToparam__node:
		return soap_out_PointerToparam__node(soap, tag, id, (param__node *const*)ptr, "param:node");
	case SOAP_TYPE_PointerToparam__entry:
		return soap_out_PointerToparam__entry(soap, tag, id, (param__entry *const*)ptr, "param:entry");
	case SOAP_TYPE_PointerToxsd__anyType:
		return soap_out_PointerToxsd__anyType(soap, tag, id, (xsd__anyType *const*)ptr, "xsd:anyType");
	case SOAP_TYPE_PointerToparam_error_loc:
		return soap_out_PointerToparam_error_loc(soap, tag, id, (param_error_loc *const*)ptr, "param-error-loc");
	case SOAP_TYPE_PointerToxsd__wstring:
		return soap_out_PointerToxsd__wstring(soap, tag, id, (wchar_t **const*)ptr, "xsd:wstring");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_out_PointerTounsignedByte(soap, tag, id, (unsigned char *const*)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_xsd__token:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:token");
	case SOAP_TYPE_xsd__normalizedString:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:normalizedString");
	case SOAP_TYPE_xsd__string:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:string");
	case SOAP_TYPE_xsd__wstring:
		return soap_out_wstring(soap, tag, id, (wchar_t**)&ptr, "xsd:wstring");
	case SOAP_TYPE_wstring:
		return soap_out_wstring(soap, tag, id, (wchar_t**)&ptr, "xsd:string");
	case SOAP_TYPE_xsd__positiveInteger:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:positiveInteger");
	case SOAP_TYPE_xsd__nonNegativeInteger:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:nonNegativeInteger");
	case SOAP_TYPE_xsd__negativeInteger:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:negativeInteger");
	case SOAP_TYPE_xsd__nonPositiveInteger:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:nonPositiveInteger");
	case SOAP_TYPE_xsd__integer:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:integer");
	case SOAP_TYPE_xsd__decimal:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:decimal");
	case SOAP_TYPE_xsd__time:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:time");
	case SOAP_TYPE_xsd__duration:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:duration");
	case SOAP_TYPE_xsd__dateTime:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:dateTime");
	case SOAP_TYPE_xsd__date:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:date");
	case SOAP_TYPE_xsd__anyURI:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:anyURI");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, "QName", id, (char**)&ptr, NULL);
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	switch (type)
	{
	case SOAP_TYPE_aklwngt__CmdAppState:
		((aklwngt__CmdAppState *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_aklwngt__CmdAppInfo:
		((aklwngt__CmdAppInfo *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_aklwngt__CmdSubscriptions:
		((aklwngt__CmdSubscriptions *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_aklwngt__CmdParAndHash:
		((aklwngt__CmdParAndHash *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_aklwngt__CmdPar:
		((aklwngt__CmdPar *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_aklwngt__CmdHash:
		((aklwngt__CmdHash *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_aklwngt__CmdError:
		((aklwngt__CmdError *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_aklwngt__anyCmd:
		((aklwngt__anyCmd *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_param__arrayvalue:
		((param__arrayvalue *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_param__params:
		((param__params *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_param__node:
		((param__node *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_param__entry:
		((param__entry *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_param__value:
		((param__value *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_param_error_loc:
		((param_error_loc *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_param_error_loc_args:
		((param_error_loc_args *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__hexBinary:
		((xsd__hexBinary *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__base64Binary:
		((xsd__base64Binary *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__token_:
		((xsd__token_ *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__normalizedString_:
		((xsd__normalizedString_ *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__string_:
		((xsd__string_ *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__wstring_:
		((xsd__wstring_ *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__unsignedByte_:
		((xsd__unsignedByte_ *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__unsignedShort_:
		((xsd__unsignedShort_ *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__unsignedInt_:
		((xsd__unsignedInt_ *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__unsignedLong_:
		((xsd__unsignedLong_ *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__positiveInteger_:
		((xsd__positiveInteger_ *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__nonNegativeInteger_:
		((xsd__nonNegativeInteger_ *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__negativeInteger_:
		((xsd__negativeInteger_ *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__nonPositiveInteger_:
		((xsd__nonPositiveInteger_ *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__byte_:
		((xsd__byte_ *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__short_:
		((xsd__short_ *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__int_:
		((xsd__int_ *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__long_:
		((xsd__long_ *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__integer_:
		((xsd__integer_ *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__decimal_:
		((xsd__decimal_ *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__time_:
		((xsd__time_ *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__float_:
		((xsd__float_ *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__duration_:
		((xsd__duration_ *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__double_:
		((xsd__double_ *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__dateTime_:
		((xsd__dateTime_ *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__date_:
		((xsd__date_ *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__boolean_:
		((xsd__boolean_ *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__anyURI_:
		((xsd__anyURI_ *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__anySimpleType:
		((xsd__anySimpleType *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__anyType:
		((xsd__anyType *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_aklwngt__klft_GetNextFileChunk:
		soap_mark_aklwngt__klft_GetNextFileChunk(soap, (const struct aklwngt__klft_GetNextFileChunk *)ptr);
		break;
	case SOAP_TYPE_aklwngt__klft_GetNextFileChunkResponse:
		soap_mark_aklwngt__klft_GetNextFileChunkResponse(soap, (const struct aklwngt__klft_GetNextFileChunkResponse *)ptr);
		break;
	case SOAP_TYPE_aklwngt__klft_GetFileInfo:
		soap_mark_aklwngt__klft_GetFileInfo(soap, (const struct aklwngt__klft_GetFileInfo *)ptr);
		break;
	case SOAP_TYPE_aklwngt__klft_GetFileInfoResponse:
		soap_mark_aklwngt__klft_GetFileInfoResponse(soap, (const struct aklwngt__klft_GetFileInfoResponse *)ptr);
		break;
	case SOAP_TYPE_aklwngt__PutEvents:
		soap_mark_aklwngt__PutEvents(soap, (const struct aklwngt__PutEvents *)ptr);
		break;
	case SOAP_TYPE_aklwngt__PutEventsResponse:
		soap_mark_aklwngt__PutEventsResponse(soap, (const struct aklwngt__PutEventsResponse *)ptr);
		break;
	case SOAP_TYPE_aklwngt__PutResult:
		soap_mark_aklwngt__PutResult(soap, (const struct aklwngt__PutResult *)ptr);
		break;
	case SOAP_TYPE_aklwngt__PutResultResponse:
		soap_mark_aklwngt__PutResultResponse(soap, (const struct aklwngt__PutResultResponse *)ptr);
		break;
	case SOAP_TYPE_aklwngt__Heartbeat:
		soap_mark_aklwngt__Heartbeat(soap, (const struct aklwngt__Heartbeat *)ptr);
		break;
	case SOAP_TYPE_aklwngt__HeartbeatResponse:
		soap_mark_aklwngt__HeartbeatResponse(soap, (const struct aklwngt__HeartbeatResponse *)ptr);
		break;
	case SOAP_TYPE_aklwngt__SessionEnd:
		soap_mark_aklwngt__SessionEnd(soap, (const struct aklwngt__SessionEnd *)ptr);
		break;
	case SOAP_TYPE_aklwngt__SessionEndResponse:
		soap_mark_aklwngt__SessionEndResponse(soap, (const struct aklwngt__SessionEndResponse *)ptr);
		break;
	case SOAP_TYPE_aklwngt__SessionBegin:
		soap_mark_aklwngt__SessionBegin(soap, (const struct aklwngt__SessionBegin *)ptr);
		break;
	case SOAP_TYPE_aklwngt__SessionBeginResponse:
		soap_mark_aklwngt__SessionBeginResponse(soap, (const struct aklwngt__SessionBeginResponse *)ptr);
		break;
	case SOAP_TYPE_aklwngt__klft_file_info_t:
		soap_mark_aklwngt__klft_file_info_t(soap, (const struct aklwngt__klft_file_info_t *)ptr);
		break;
	case SOAP_TYPE_aklwngt__klft_file_chunk_t:
		soap_mark_aklwngt__klft_file_chunk_t(soap, (const struct aklwngt__klft_file_chunk_t *)ptr);
		break;
	case SOAP_TYPE_aklwngt__klft_file_chunk_buff:
		soap_mark_aklwngt__klft_file_chunk_buff(soap, (const struct aklwngt__klft_file_chunk_buff *)ptr);
		break;
	case SOAP_TYPE_aklwngt__event_info_array:
		soap_mark_aklwngt__event_info_array(soap, (const struct aklwngt__event_info_array *)ptr);
		break;
	case SOAP_TYPE_aklwngt__event_info:
		soap_mark_aklwngt__event_info(soap, (const struct aklwngt__event_info *)ptr);
		break;
	case SOAP_TYPE_aklwngt__event_body:
		soap_mark_aklwngt__event_body(soap, (const struct aklwngt__event_body *)ptr);
		break;
	case SOAP_TYPE_aklwngt__sync_info:
		soap_mark_aklwngt__sync_info(soap, (const struct aklwngt__sync_info *)ptr);
		break;
	case SOAP_TYPE_aklwngt__command:
		soap_mark_aklwngt__command(soap, (const struct aklwngt__command *)ptr);
		break;
	case SOAP_TYPE_aklwngt__LicenseInfo:
		soap_mark_aklwngt__LicenseInfo(soap, (const struct aklwngt__LicenseInfo *)ptr);
		break;
	case SOAP_TYPE_aklwngt__LicKeyInfo:
		soap_mark_aklwngt__LicKeyInfo(soap, (const struct aklwngt__LicKeyInfo *)ptr);
		break;
	case SOAP_TYPE_aklwngt__ProdInfo:
		soap_mark_aklwngt__ProdInfo(soap, (const struct aklwngt__ProdInfo *)ptr);
		break;
	case SOAP_TYPE_aklwngt__DevInfo:
		soap_mark_aklwngt__DevInfo(soap, (const struct aklwngt__DevInfo *)ptr);
		break;
	case SOAP_TYPE_aklwngt__string_array:
		soap_mark_aklwngt__string_array(soap, (const struct aklwngt__string_array *)ptr);
		break;
	case SOAP_TYPE_param_error:
		soap_mark_param_error(soap, (const struct param_error *)ptr);
		break;
	case SOAP_TYPE_PointerToaklwngt__event_info_array:
		soap_mark_PointerToaklwngt__event_info_array(soap, (struct aklwngt__event_info_array *const*)ptr);
		break;
	case SOAP_TYPE_PointerToaklwngt__command:
		soap_mark_PointerToaklwngt__command(soap, (struct aklwngt__command *const*)ptr);
		break;
	case SOAP_TYPE_PointerToaklwngt__sync_info:
		soap_mark_PointerToaklwngt__sync_info(soap, (struct aklwngt__sync_info *const*)ptr);
		break;
	case SOAP_TYPE_PointerToparam_error:
		soap_mark_PointerToparam_error(soap, (struct param_error *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__unsignedByte:
		soap_mark_PointerToxsd__unsignedByte(soap, (unsigned char *const*)ptr);
		break;
	case SOAP_TYPE_PointerToaklwngt__event_info:
		soap_mark_PointerToaklwngt__event_info(soap, (struct aklwngt__event_info *const*)ptr);
		break;
	case SOAP_TYPE_PointerToaklwngt__anyCmd:
		soap_mark_PointerToaklwngt__anyCmd(soap, (aklwngt__anyCmd *const*)ptr);
		break;
	case SOAP_TYPE_PointerToaklwngt__LicKeyInfo:
		soap_mark_PointerToaklwngt__LicKeyInfo(soap, (struct aklwngt__LicKeyInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__string:
		soap_mark_PointerToxsd__string(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE_PointerToparam__value:
		soap_mark_PointerToparam__value(soap, (param__value *const*)ptr);
		break;
	case SOAP_TYPE_PointerToparam__node:
		soap_mark_PointerToparam__node(soap, (param__node *const*)ptr);
		break;
	case SOAP_TYPE_PointerToparam__entry:
		soap_mark_PointerToparam__entry(soap, (param__entry *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__anyType:
		soap_mark_PointerToxsd__anyType(soap, (xsd__anyType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToparam_error_loc:
		soap_mark_PointerToparam_error_loc(soap, (param_error_loc *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__wstring:
		soap_mark_PointerToxsd__wstring(soap, (wchar_t **const*)ptr);
		break;
	case SOAP_TYPE_PointerTounsignedByte:
		soap_mark_PointerTounsignedByte(soap, (unsigned char *const*)ptr);
		break;
	case SOAP_TYPE_xsd__token:
		soap_mark_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_xsd__normalizedString:
		soap_mark_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_xsd__string:
		soap_mark_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_xsd__wstring:
		soap_mark_wstring(soap, (wchar_t**)&ptr);
		break;
	case SOAP_TYPE_wstring:
		soap_mark_wstring(soap, (wchar_t**)&ptr);
		break;
	case SOAP_TYPE_xsd__positiveInteger:
		soap_mark_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_xsd__nonNegativeInteger:
		soap_mark_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_xsd__negativeInteger:
		soap_mark_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_xsd__nonPositiveInteger:
		soap_mark_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_xsd__integer:
		soap_mark_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_xsd__decimal:
		soap_mark_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_xsd__time:
		soap_mark_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_xsd__duration:
		soap_mark_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_xsd__dateTime:
		soap_mark_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_xsd__date:
		soap_mark_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_xsd__anyURI:
		soap_mark_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE__QName:
		soap_mark_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_mark_string(soap, (char**)&ptr);
		break;
	}
}

#ifndef WITH_LEANER
SOAP_FMAC3 int SOAP_FMAC4 soap_resolve_attachments(struct soap *soap)
{
	if (!(soap->mode & SOAP_ENC_DIME))
		return SOAP_OK;
	while (soap->dime.flags & SOAP_DIME_CF)
	{	if (soap_getdimehdr(soap))
			return soap->error;
		if (soap_move(soap, soap->dime.size))
			return soap->error = SOAP_EOF;
	}
	if (soap_move(soap, ((soap->dime.size+3)&(~3))-soap_tell(soap)))
		return soap->error = SOAP_EOF;
	for (;;)
	{	if (soap_getdime(soap))
			break;
		switch (soap_lookup_type(soap, soap->dime.id))
		{
		case SOAP_TYPE_xsd__hexBinary:
		{	xsd__hexBinary * a;
			a = (xsd__hexBinary *)soap_class_id_enter(soap, soap->dime.id, NULL, SOAP_TYPE_xsd__hexBinary, sizeof(xsd__hexBinary), NULL, NULL);
			if (!a)
				return soap->error;
			a->__ptr = (unsigned char*)soap->dime.ptr;
			a->__size = soap->dime.size;
			break;
		}
		case SOAP_TYPE_xsd__base64Binary:
		{	xsd__base64Binary * a;
			a = (xsd__base64Binary *)soap_class_id_enter(soap, soap->dime.id, NULL, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), NULL, NULL);
			if (!a)
				return soap->error;
			a->__ptr = (unsigned char*)soap->dime.ptr;
			a->__size = soap->dime.size;
			break;
		}
		case SOAP_TYPE_aklwngt__klft_file_chunk_buff:
		{	struct aklwngt__klft_file_chunk_buff * a;
			a = (struct aklwngt__klft_file_chunk_buff *)soap_id_enter(soap, soap->dime.id, NULL, SOAP_TYPE_aklwngt__klft_file_chunk_buff, sizeof(struct aklwngt__klft_file_chunk_buff), 0, NULL, NULL, NULL);
			if (!a)
				return soap->error;
			a->__ptr = (unsigned char*)soap->dime.ptr;
			a->__size = soap->dime.size;
			break;
		}
		}
	}
	if (soap->error == SOAP_DIME_END)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_xsd__anyType:
		return (void*)soap_instantiate_xsd__anyType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__anySimpleType:
		return (void*)soap_instantiate_xsd__anySimpleType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__anyURI_:
		return (void*)soap_instantiate_xsd__anyURI_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__boolean_:
		return (void*)soap_instantiate_xsd__boolean_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__date_:
		return (void*)soap_instantiate_xsd__date_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__dateTime_:
		return (void*)soap_instantiate_xsd__dateTime_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__double_:
		return (void*)soap_instantiate_xsd__double_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__duration_:
		return (void*)soap_instantiate_xsd__duration_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__float_:
		return (void*)soap_instantiate_xsd__float_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__time_:
		return (void*)soap_instantiate_xsd__time_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__decimal_:
		return (void*)soap_instantiate_xsd__decimal_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__integer_:
		return (void*)soap_instantiate_xsd__integer_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__long_:
		return (void*)soap_instantiate_xsd__long_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__int_:
		return (void*)soap_instantiate_xsd__int_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__short_:
		return (void*)soap_instantiate_xsd__short_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__byte_:
		return (void*)soap_instantiate_xsd__byte_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__nonPositiveInteger_:
		return (void*)soap_instantiate_xsd__nonPositiveInteger_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__negativeInteger_:
		return (void*)soap_instantiate_xsd__negativeInteger_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__nonNegativeInteger_:
		return (void*)soap_instantiate_xsd__nonNegativeInteger_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__positiveInteger_:
		return (void*)soap_instantiate_xsd__positiveInteger_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__unsignedLong_:
		return (void*)soap_instantiate_xsd__unsignedLong_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__unsignedInt_:
		return (void*)soap_instantiate_xsd__unsignedInt_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__unsignedShort_:
		return (void*)soap_instantiate_xsd__unsignedShort_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__unsignedByte_:
		return (void*)soap_instantiate_xsd__unsignedByte_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__wstring_:
		return (void*)soap_instantiate_xsd__wstring_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__string_:
		return (void*)soap_instantiate_xsd__string_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__normalizedString_:
		return (void*)soap_instantiate_xsd__normalizedString_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__token_:
		return (void*)soap_instantiate_xsd__token_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__base64Binary:
		return (void*)soap_instantiate_xsd__base64Binary(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__hexBinary:
		return (void*)soap_instantiate_xsd__hexBinary(soap, -1, type, arrayType, n);
	case SOAP_TYPE_param_error_loc_args:
		return (void*)soap_instantiate_param_error_loc_args(soap, -1, type, arrayType, n);
	case SOAP_TYPE_param_error_loc:
		return (void*)soap_instantiate_param_error_loc(soap, -1, type, arrayType, n);
	case SOAP_TYPE_param__value:
		return (void*)soap_instantiate_param__value(soap, -1, type, arrayType, n);
	case SOAP_TYPE_param__entry:
		return (void*)soap_instantiate_param__entry(soap, -1, type, arrayType, n);
	case SOAP_TYPE_param__node:
		return (void*)soap_instantiate_param__node(soap, -1, type, arrayType, n);
	case SOAP_TYPE_param__params:
		return (void*)soap_instantiate_param__params(soap, -1, type, arrayType, n);
	case SOAP_TYPE_param__arrayvalue:
		return (void*)soap_instantiate_param__arrayvalue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_aklwngt__anyCmd:
		return (void*)soap_instantiate_aklwngt__anyCmd(soap, -1, type, arrayType, n);
	case SOAP_TYPE_aklwngt__CmdError:
		return (void*)soap_instantiate_aklwngt__CmdError(soap, -1, type, arrayType, n);
	case SOAP_TYPE_aklwngt__CmdHash:
		return (void*)soap_instantiate_aklwngt__CmdHash(soap, -1, type, arrayType, n);
	case SOAP_TYPE_aklwngt__CmdPar:
		return (void*)soap_instantiate_aklwngt__CmdPar(soap, -1, type, arrayType, n);
	case SOAP_TYPE_aklwngt__CmdParAndHash:
		return (void*)soap_instantiate_aklwngt__CmdParAndHash(soap, -1, type, arrayType, n);
	case SOAP_TYPE_aklwngt__CmdSubscriptions:
		return (void*)soap_instantiate_aklwngt__CmdSubscriptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_aklwngt__CmdAppInfo:
		return (void*)soap_instantiate_aklwngt__CmdAppInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_aklwngt__CmdAppState:
		return (void*)soap_instantiate_aklwngt__CmdAppState(soap, -1, type, arrayType, n);
	case SOAP_TYPE_aklwngt__sync_info:
		return (void*)soap_instantiate_aklwngt__sync_info(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_xsd__anyType:
		if (p->size < 0)
			delete (xsd__anyType*)p->ptr;
		else
			delete[] (xsd__anyType*)p->ptr;
		break;
	case SOAP_TYPE_xsd__anySimpleType:
		if (p->size < 0)
			delete (xsd__anySimpleType*)p->ptr;
		else
			delete[] (xsd__anySimpleType*)p->ptr;
		break;
	case SOAP_TYPE_xsd__anyURI_:
		if (p->size < 0)
			delete (xsd__anyURI_*)p->ptr;
		else
			delete[] (xsd__anyURI_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__boolean_:
		if (p->size < 0)
			delete (xsd__boolean_*)p->ptr;
		else
			delete[] (xsd__boolean_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__date_:
		if (p->size < 0)
			delete (xsd__date_*)p->ptr;
		else
			delete[] (xsd__date_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__dateTime_:
		if (p->size < 0)
			delete (xsd__dateTime_*)p->ptr;
		else
			delete[] (xsd__dateTime_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__double_:
		if (p->size < 0)
			delete (xsd__double_*)p->ptr;
		else
			delete[] (xsd__double_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__duration_:
		if (p->size < 0)
			delete (xsd__duration_*)p->ptr;
		else
			delete[] (xsd__duration_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__float_:
		if (p->size < 0)
			delete (xsd__float_*)p->ptr;
		else
			delete[] (xsd__float_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__time_:
		if (p->size < 0)
			delete (xsd__time_*)p->ptr;
		else
			delete[] (xsd__time_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__decimal_:
		if (p->size < 0)
			delete (xsd__decimal_*)p->ptr;
		else
			delete[] (xsd__decimal_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__integer_:
		if (p->size < 0)
			delete (xsd__integer_*)p->ptr;
		else
			delete[] (xsd__integer_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__long_:
		if (p->size < 0)
			delete (xsd__long_*)p->ptr;
		else
			delete[] (xsd__long_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__int_:
		if (p->size < 0)
			delete (xsd__int_*)p->ptr;
		else
			delete[] (xsd__int_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__short_:
		if (p->size < 0)
			delete (xsd__short_*)p->ptr;
		else
			delete[] (xsd__short_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__byte_:
		if (p->size < 0)
			delete (xsd__byte_*)p->ptr;
		else
			delete[] (xsd__byte_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__nonPositiveInteger_:
		if (p->size < 0)
			delete (xsd__nonPositiveInteger_*)p->ptr;
		else
			delete[] (xsd__nonPositiveInteger_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__negativeInteger_:
		if (p->size < 0)
			delete (xsd__negativeInteger_*)p->ptr;
		else
			delete[] (xsd__negativeInteger_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__nonNegativeInteger_:
		if (p->size < 0)
			delete (xsd__nonNegativeInteger_*)p->ptr;
		else
			delete[] (xsd__nonNegativeInteger_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__positiveInteger_:
		if (p->size < 0)
			delete (xsd__positiveInteger_*)p->ptr;
		else
			delete[] (xsd__positiveInteger_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__unsignedLong_:
		if (p->size < 0)
			delete (xsd__unsignedLong_*)p->ptr;
		else
			delete[] (xsd__unsignedLong_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__unsignedInt_:
		if (p->size < 0)
			delete (xsd__unsignedInt_*)p->ptr;
		else
			delete[] (xsd__unsignedInt_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__unsignedShort_:
		if (p->size < 0)
			delete (xsd__unsignedShort_*)p->ptr;
		else
			delete[] (xsd__unsignedShort_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__unsignedByte_:
		if (p->size < 0)
			delete (xsd__unsignedByte_*)p->ptr;
		else
			delete[] (xsd__unsignedByte_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__wstring_:
		if (p->size < 0)
			delete (xsd__wstring_*)p->ptr;
		else
			delete[] (xsd__wstring_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__string_:
		if (p->size < 0)
			delete (xsd__string_*)p->ptr;
		else
			delete[] (xsd__string_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__normalizedString_:
		if (p->size < 0)
			delete (xsd__normalizedString_*)p->ptr;
		else
			delete[] (xsd__normalizedString_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__token_:
		if (p->size < 0)
			delete (xsd__token_*)p->ptr;
		else
			delete[] (xsd__token_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__base64Binary:
		if (p->size < 0)
			delete (xsd__base64Binary*)p->ptr;
		else
			delete[] (xsd__base64Binary*)p->ptr;
		break;
	case SOAP_TYPE_xsd__hexBinary:
		if (p->size < 0)
			delete (xsd__hexBinary*)p->ptr;
		else
			delete[] (xsd__hexBinary*)p->ptr;
		break;
	case SOAP_TYPE_param_error_loc_args:
		if (p->size < 0)
			delete (param_error_loc_args*)p->ptr;
		else
			delete[] (param_error_loc_args*)p->ptr;
		break;
	case SOAP_TYPE_param_error_loc:
		if (p->size < 0)
			delete (param_error_loc*)p->ptr;
		else
			delete[] (param_error_loc*)p->ptr;
		break;
	case SOAP_TYPE_param__value:
		if (p->size < 0)
			delete (param__value*)p->ptr;
		else
			delete[] (param__value*)p->ptr;
		break;
	case SOAP_TYPE_param__entry:
		if (p->size < 0)
			delete (param__entry*)p->ptr;
		else
			delete[] (param__entry*)p->ptr;
		break;
	case SOAP_TYPE_param__node:
		if (p->size < 0)
			delete (param__node*)p->ptr;
		else
			delete[] (param__node*)p->ptr;
		break;
	case SOAP_TYPE_param__params:
		if (p->size < 0)
			delete (param__params*)p->ptr;
		else
			delete[] (param__params*)p->ptr;
		break;
	case SOAP_TYPE_param__arrayvalue:
		if (p->size < 0)
			delete (param__arrayvalue*)p->ptr;
		else
			delete[] (param__arrayvalue*)p->ptr;
		break;
	case SOAP_TYPE_aklwngt__anyCmd:
		if (p->size < 0)
			delete (aklwngt__anyCmd*)p->ptr;
		else
			delete[] (aklwngt__anyCmd*)p->ptr;
		break;
	case SOAP_TYPE_aklwngt__CmdError:
		if (p->size < 0)
			delete (aklwngt__CmdError*)p->ptr;
		else
			delete[] (aklwngt__CmdError*)p->ptr;
		break;
	case SOAP_TYPE_aklwngt__CmdHash:
		if (p->size < 0)
			delete (aklwngt__CmdHash*)p->ptr;
		else
			delete[] (aklwngt__CmdHash*)p->ptr;
		break;
	case SOAP_TYPE_aklwngt__CmdPar:
		if (p->size < 0)
			delete (aklwngt__CmdPar*)p->ptr;
		else
			delete[] (aklwngt__CmdPar*)p->ptr;
		break;
	case SOAP_TYPE_aklwngt__CmdParAndHash:
		if (p->size < 0)
			delete (aklwngt__CmdParAndHash*)p->ptr;
		else
			delete[] (aklwngt__CmdParAndHash*)p->ptr;
		break;
	case SOAP_TYPE_aklwngt__CmdSubscriptions:
		if (p->size < 0)
			delete (aklwngt__CmdSubscriptions*)p->ptr;
		else
			delete[] (aklwngt__CmdSubscriptions*)p->ptr;
		break;
	case SOAP_TYPE_aklwngt__CmdAppInfo:
		if (p->size < 0)
			delete (aklwngt__CmdAppInfo*)p->ptr;
		else
			delete[] (aklwngt__CmdAppInfo*)p->ptr;
		break;
	case SOAP_TYPE_aklwngt__CmdAppState:
		if (p->size < 0)
			delete (aklwngt__CmdAppState*)p->ptr;
		else
			delete[] (aklwngt__CmdAppState*)p->ptr;
		break;
	case SOAP_TYPE_aklwngt__sync_info:
		if (p->size < 0)
			delete (struct aklwngt__sync_info*)p->ptr;
		else
			delete[] (struct aklwngt__sync_info*)p->ptr;
		break;
	}
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__byte(struct soap *soap, char *a)
{
#ifdef SOAP_DEFAULT_xsd__byte
	*a = SOAP_DEFAULT_xsd__byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__byte(struct soap *soap, char const*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__byte);
	if (soap_out_xsd__byte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_xsd__byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_xsd__byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__byte(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_xsd__byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	return soap_inbyte(soap, tag, a, type, SOAP_TYPE_xsd__byte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_byte(struct soap *soap, char const*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	return soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__short(struct soap *soap, short *a)
{
#ifdef SOAP_DEFAULT_xsd__short
	*a = SOAP_DEFAULT_xsd__short;
#else
	*a = (short)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__short(struct soap *soap, short const*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__short(struct soap *soap, const short *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__short);
	if (soap_out_xsd__short(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__short(struct soap *soap, const char *tag, int id, const short *a, const char *type)
{
	return soap_outshort(soap, tag, id, a, type, SOAP_TYPE_xsd__short);
}

SOAP_FMAC3 short * SOAP_FMAC4 soap_get_xsd__short(struct soap *soap, short *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__short(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 short * SOAP_FMAC4 soap_in_xsd__short(struct soap *soap, const char *tag, short *a, const char *type)
{
	return soap_inshort(soap, tag, a, type, SOAP_TYPE_xsd__short);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_short(struct soap *soap, short *a)
{
#ifdef SOAP_DEFAULT_short
	*a = SOAP_DEFAULT_short;
#else
	*a = (short)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_short(struct soap *soap, short const*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_short(struct soap *soap, const short *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_short);
	if (soap_out_short(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_short(struct soap *soap, const char *tag, int id, const short *a, const char *type)
{
	return soap_outshort(soap, tag, id, a, type, SOAP_TYPE_short);
}

SOAP_FMAC3 short * SOAP_FMAC4 soap_get_short(struct soap *soap, short *p, const char *tag, const char *type)
{
	if ((p = soap_in_short(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 short * SOAP_FMAC4 soap_in_short(struct soap *soap, const char *tag, short *a, const char *type)
{
	return soap_inshort(soap, tag, a, type, SOAP_TYPE_short);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_int(struct soap *soap, int const*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__int(struct soap *soap, long *a)
{
#ifdef SOAP_DEFAULT_xsd__int
	*a = SOAP_DEFAULT_xsd__int;
#else
	*a = (long)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__int(struct soap *soap, long const*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__int(struct soap *soap, const long *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__int);
	if (soap_out_xsd__int(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__int(struct soap *soap, const char *tag, int id, const long *a, const char *type)
{
	return soap_outlong(soap, tag, id, a, type, SOAP_TYPE_xsd__int);
}

SOAP_FMAC3 long * SOAP_FMAC4 soap_get_xsd__int(struct soap *soap, long *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__int(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 long * SOAP_FMAC4 soap_in_xsd__int(struct soap *soap, const char *tag, long *a, const char *type)
{
	return soap_inlong(soap, tag, a, type, SOAP_TYPE_xsd__int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_long(struct soap *soap, long *a)
{
#ifdef SOAP_DEFAULT_long
	*a = SOAP_DEFAULT_long;
#else
	*a = (long)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_long(struct soap *soap, long const*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_long(struct soap *soap, const long *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_long);
	if (soap_out_long(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_long(struct soap *soap, const char *tag, int id, const long *a, const char *type)
{
	return soap_outlong(soap, tag, id, a, type, SOAP_TYPE_long);
}

SOAP_FMAC3 long * SOAP_FMAC4 soap_get_long(struct soap *soap, long *p, const char *tag, const char *type)
{
	if ((p = soap_in_long(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 long * SOAP_FMAC4 soap_in_long(struct soap *soap, const char *tag, long *a, const char *type)
{
	return soap_inlong(soap, tag, a, type, SOAP_TYPE_long);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__long(struct soap *soap, LONG64 *a)
{
#ifdef SOAP_DEFAULT_xsd__long
	*a = SOAP_DEFAULT_xsd__long;
#else
	*a = (LONG64)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__long(struct soap *soap, LONG64 const*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__long(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__long);
	if (soap_out_xsd__long(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__long(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_xsd__long);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_xsd__long(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__long(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_xsd__long(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{
	return soap_inLONG64(soap, tag, a, type, SOAP_TYPE_xsd__long);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_LONG64(struct soap *soap, LONG64 *a)
{
#ifdef SOAP_DEFAULT_LONG64
	*a = SOAP_DEFAULT_LONG64;
#else
	*a = (LONG64)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_LONG64(struct soap *soap, LONG64 const*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_LONG64);
	if (soap_out_LONG64(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{
	return soap_inLONG64(soap, tag, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__float(struct soap *soap, float *a)
{
#ifdef SOAP_DEFAULT_xsd__float
	*a = SOAP_DEFAULT_xsd__float;
#else
	*a = (float)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__float(struct soap *soap, float const*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__float(struct soap *soap, const float *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__float);
	if (soap_out_xsd__float(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__float(struct soap *soap, const char *tag, int id, const float *a, const char *type)
{
	return soap_outfloat(soap, tag, id, a, type, SOAP_TYPE_xsd__float);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_get_xsd__float(struct soap *soap, float *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__float(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_in_xsd__float(struct soap *soap, const char *tag, float *a, const char *type)
{
	return soap_infloat(soap, tag, a, type, SOAP_TYPE_xsd__float);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_float(struct soap *soap, float *a)
{
#ifdef SOAP_DEFAULT_float
	*a = SOAP_DEFAULT_float;
#else
	*a = (float)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_float(struct soap *soap, float const*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_float(struct soap *soap, const float *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_float);
	if (soap_out_float(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_float(struct soap *soap, const char *tag, int id, const float *a, const char *type)
{
	return soap_outfloat(soap, tag, id, a, type, SOAP_TYPE_float);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_get_float(struct soap *soap, float *p, const char *tag, const char *type)
{
	if ((p = soap_in_float(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_in_float(struct soap *soap, const char *tag, float *a, const char *type)
{
	return soap_infloat(soap, tag, a, type, SOAP_TYPE_float);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__double(struct soap *soap, double *a)
{
#ifdef SOAP_DEFAULT_xsd__double
	*a = SOAP_DEFAULT_xsd__double;
#else
	*a = (double)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__double(struct soap *soap, double const*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__double);
	if (soap_out_xsd__double(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_xsd__double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_xsd__double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__double(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_xsd__double(struct soap *soap, const char *tag, double *a, const char *type)
{
	return soap_indouble(soap, tag, a, type, SOAP_TYPE_xsd__double);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_double(struct soap *soap, double *a)
{
#ifdef SOAP_DEFAULT_double
	*a = SOAP_DEFAULT_double;
#else
	*a = (double)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_double(struct soap *soap, double const*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_double);
	if (soap_out_double(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{
	return soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__unsignedByte(struct soap *soap, unsigned char *a)
{
#ifdef SOAP_DEFAULT_xsd__unsignedByte
	*a = SOAP_DEFAULT_xsd__unsignedByte;
#else
	*a = (unsigned char)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__unsignedByte(struct soap *soap, unsigned char const*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__unsignedByte);
	if (soap_out_xsd__unsignedByte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_xsd__unsignedByte);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_xsd__unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__unsignedByte(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_xsd__unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{
	return soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_xsd__unsignedByte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedByte(struct soap *soap, unsigned char *a)
{
#ifdef SOAP_DEFAULT_unsignedByte
	*a = SOAP_DEFAULT_unsignedByte;
#else
	*a = (unsigned char)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_unsignedByte(struct soap *soap, unsigned char const*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedByte);
	if (soap_out_unsignedByte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedByte(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{
	return soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__unsignedShort(struct soap *soap, unsigned short *a)
{
#ifdef SOAP_DEFAULT_xsd__unsignedShort
	*a = SOAP_DEFAULT_xsd__unsignedShort;
#else
	*a = (unsigned short)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__unsignedShort(struct soap *soap, unsigned short const*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__unsignedShort(struct soap *soap, const unsigned short *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__unsignedShort);
	if (soap_out_xsd__unsignedShort(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__unsignedShort(struct soap *soap, const char *tag, int id, const unsigned short *a, const char *type)
{
	return soap_outunsignedShort(soap, tag, id, a, type, SOAP_TYPE_xsd__unsignedShort);
}

SOAP_FMAC3 unsigned short * SOAP_FMAC4 soap_get_xsd__unsignedShort(struct soap *soap, unsigned short *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__unsignedShort(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned short * SOAP_FMAC4 soap_in_xsd__unsignedShort(struct soap *soap, const char *tag, unsigned short *a, const char *type)
{
	return soap_inunsignedShort(soap, tag, a, type, SOAP_TYPE_xsd__unsignedShort);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedShort(struct soap *soap, unsigned short *a)
{
#ifdef SOAP_DEFAULT_unsignedShort
	*a = SOAP_DEFAULT_unsignedShort;
#else
	*a = (unsigned short)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_unsignedShort(struct soap *soap, unsigned short const*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedShort(struct soap *soap, const unsigned short *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedShort);
	if (soap_out_unsignedShort(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedShort(struct soap *soap, const char *tag, int id, const unsigned short *a, const char *type)
{
	return soap_outunsignedShort(soap, tag, id, a, type, SOAP_TYPE_unsignedShort);
}

SOAP_FMAC3 unsigned short * SOAP_FMAC4 soap_get_unsignedShort(struct soap *soap, unsigned short *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedShort(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned short * SOAP_FMAC4 soap_in_unsignedShort(struct soap *soap, const char *tag, unsigned short *a, const char *type)
{
	return soap_inunsignedShort(soap, tag, a, type, SOAP_TYPE_unsignedShort);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedInt(struct soap *soap, unsigned int *a)
{
#ifdef SOAP_DEFAULT_unsignedInt
	*a = SOAP_DEFAULT_unsignedInt;
#else
	*a = (unsigned int)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_unsignedInt(struct soap *soap, unsigned int const*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedInt);
	if (soap_out_unsignedInt(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{
	return soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__unsignedInt(struct soap *soap, unsigned long *a)
{
#ifdef SOAP_DEFAULT_xsd__unsignedInt
	*a = SOAP_DEFAULT_xsd__unsignedInt;
#else
	*a = (unsigned long)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__unsignedInt(struct soap *soap, unsigned long const*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__unsignedInt(struct soap *soap, const unsigned long *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__unsignedInt);
	if (soap_out_xsd__unsignedInt(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__unsignedInt(struct soap *soap, const char *tag, int id, const unsigned long *a, const char *type)
{
	return soap_outunsignedLong(soap, tag, id, a, type, SOAP_TYPE_xsd__unsignedInt);
}

SOAP_FMAC3 unsigned long * SOAP_FMAC4 soap_get_xsd__unsignedInt(struct soap *soap, unsigned long *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__unsignedInt(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned long * SOAP_FMAC4 soap_in_xsd__unsignedInt(struct soap *soap, const char *tag, unsigned long *a, const char *type)
{
	return soap_inunsignedLong(soap, tag, a, type, SOAP_TYPE_xsd__unsignedInt);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedLong(struct soap *soap, unsigned long *a)
{
#ifdef SOAP_DEFAULT_unsignedLong
	*a = SOAP_DEFAULT_unsignedLong;
#else
	*a = (unsigned long)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_unsignedLong(struct soap *soap, unsigned long const*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedLong(struct soap *soap, const unsigned long *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedLong);
	if (soap_out_unsignedLong(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedLong(struct soap *soap, const char *tag, int id, const unsigned long *a, const char *type)
{
	return soap_outunsignedLong(soap, tag, id, a, type, SOAP_TYPE_unsignedLong);
}

SOAP_FMAC3 unsigned long * SOAP_FMAC4 soap_get_unsignedLong(struct soap *soap, unsigned long *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedLong(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned long * SOAP_FMAC4 soap_in_unsignedLong(struct soap *soap, const char *tag, unsigned long *a, const char *type)
{
	return soap_inunsignedLong(soap, tag, a, type, SOAP_TYPE_unsignedLong);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__unsignedLong(struct soap *soap, ULONG64 *a)
{
#ifdef SOAP_DEFAULT_xsd__unsignedLong
	*a = SOAP_DEFAULT_xsd__unsignedLong;
#else
	*a = (ULONG64)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__unsignedLong(struct soap *soap, ULONG64 const*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__unsignedLong(struct soap *soap, const ULONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__unsignedLong);
	if (soap_out_xsd__unsignedLong(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__unsignedLong(struct soap *soap, const char *tag, int id, const ULONG64 *a, const char *type)
{
	return soap_outULONG64(soap, tag, id, a, type, SOAP_TYPE_xsd__unsignedLong);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_get_xsd__unsignedLong(struct soap *soap, ULONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__unsignedLong(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_in_xsd__unsignedLong(struct soap *soap, const char *tag, ULONG64 *a, const char *type)
{
	return soap_inULONG64(soap, tag, a, type, SOAP_TYPE_xsd__unsignedLong);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedLONG64(struct soap *soap, ULONG64 *a)
{
#ifdef SOAP_DEFAULT_unsignedLONG64
	*a = SOAP_DEFAULT_unsignedLONG64;
#else
	*a = (ULONG64)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_unsignedLONG64(struct soap *soap, ULONG64 const*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedLONG64(struct soap *soap, const ULONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedLONG64);
	if (soap_out_unsignedLONG64(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedLONG64(struct soap *soap, const char *tag, int id, const ULONG64 *a, const char *type)
{
	return soap_outULONG64(soap, tag, id, a, type, SOAP_TYPE_unsignedLONG64);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_get_unsignedLONG64(struct soap *soap, ULONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedLONG64(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_in_unsignedLONG64(struct soap *soap, const char *tag, ULONG64 *a, const char *type)
{
	return soap_inULONG64(soap, tag, a, type, SOAP_TYPE_unsignedLONG64);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_param__null(struct soap *soap, bool *a)
{
#ifdef SOAP_DEFAULT_param__null
	*a = SOAP_DEFAULT_param__null;
#else
	*a = (bool)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_param__null(struct soap *soap, bool const*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_param__null(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_param__null);
	if (soap_out_param__null(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_param__null[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3 const char* SOAP_FMAC4 soap_param__null2s(struct soap *soap, bool n)
{	const char *s = soap_str_code(soap_codes_param__null, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_param__null(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_param__null), type);
	soap_send(soap, soap_param__null2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_param__null(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_param__null(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_s2param__null(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_param__null, s);
	if (map)
		*a = (bool)map->code;
	else if (soap->mode & SOAP_XML_STRICT)
		return soap->error = SOAP_TYPE;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
			return soap->error;
		*a = (bool)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_param__null(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, "xsd:boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_param__null, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2param__null(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_param__null, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__boolean(struct soap *soap, bool *a)
{
#ifdef SOAP_DEFAULT_xsd__boolean
	*a = SOAP_DEFAULT_xsd__boolean;
#else
	*a = (bool)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__boolean(struct soap *soap, bool const*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__boolean(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__boolean);
	if (soap_out_xsd__boolean(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_xsd__boolean[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3 const char* SOAP_FMAC4 soap_xsd__boolean2s(struct soap *soap, bool n)
{	const char *s = soap_str_code(soap_codes_xsd__boolean, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__boolean(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xsd__boolean), type);
	soap_send(soap, soap_xsd__boolean2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_xsd__boolean(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__boolean(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_s2xsd__boolean(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_xsd__boolean, s);
	if (map)
		*a = (bool)map->code;
	else if (soap->mode & SOAP_XML_STRICT)
		return soap->error = SOAP_TYPE;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
			return soap->error;
		*a = (bool)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_xsd__boolean(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, "xsd:boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__boolean, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2xsd__boolean(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_xsd__boolean, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bool(struct soap *soap, bool const*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3 const char* SOAP_FMAC4 soap_bool2s(struct soap *soap, bool n)
{	const char *s = soap_str_code(soap_codes_bool, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type);
	soap_send(soap, soap_bool2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)map->code;
	else if (soap->mode & SOAP_XML_STRICT)
		return soap->error = SOAP_TYPE;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
			return soap->error;
		*a = (bool)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

void aklwngt__CmdAppState::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void aklwngt__CmdAppState::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((aklwngt__CmdAppState*)this)->hash, SOAP_TYPE_xsd__base64Binary);
	((aklwngt__CmdAppState*)this)->hash.soap_mark(soap);
	soap_embedded(soap, &((aklwngt__CmdAppState*)this)->stateApp, SOAP_TYPE_xsd__int);
	soap_embedded(soap, &((aklwngt__CmdAppState*)this)->stateRTP, SOAP_TYPE_xsd__int);
	soap_embedded(soap, &((aklwngt__CmdAppState*)this)->lastFullScan, SOAP_TYPE_xsd__dateTime);
	soap_mark_xsd__dateTime(soap, &((aklwngt__CmdAppState*)this)->lastFullScan);
	soap_embedded(soap, &((aklwngt__CmdAppState*)this)->lastUpdateTime, SOAP_TYPE_xsd__dateTime);
	soap_mark_xsd__dateTime(soap, &((aklwngt__CmdAppState*)this)->lastUpdateTime);
	soap_embedded(soap, &((aklwngt__CmdAppState*)this)->basesDate, SOAP_TYPE_xsd__dateTime);
	soap_mark_xsd__dateTime(soap, &((aklwngt__CmdAppState*)this)->basesDate);
	soap_embedded(soap, &((aklwngt__CmdAppState*)this)->basesInstallDate, SOAP_TYPE_xsd__dateTime);
	soap_mark_xsd__dateTime(soap, &((aklwngt__CmdAppState*)this)->basesInstallDate);
	soap_embedded(soap, &((aklwngt__CmdAppState*)this)->basesRecords, SOAP_TYPE_xsd__int);
}

void aklwngt__CmdAppState::soap_default(struct soap *soap)
{
	((aklwngt__CmdAppState*)this)->hash.xsd__base64Binary::soap_default(soap);
	soap_default_xsd__int(soap, &((aklwngt__CmdAppState*)this)->stateApp);
	soap_default_xsd__int(soap, &((aklwngt__CmdAppState*)this)->stateRTP);
	((aklwngt__CmdAppState*)this)->lastFullScan = NULL;
	((aklwngt__CmdAppState*)this)->lastUpdateTime = NULL;
	((aklwngt__CmdAppState*)this)->basesDate = NULL;
	((aklwngt__CmdAppState*)this)->basesInstallDate = NULL;
	soap_default_xsd__int(soap, &((aklwngt__CmdAppState*)this)->basesRecords);
}

int aklwngt__CmdAppState::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_aklwngt__CmdAppState);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int aklwngt__CmdAppState::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_aklwngt__CmdAppState(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_aklwngt__CmdAppState(struct soap *soap, const char *tag, int id, const aklwngt__CmdAppState *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_aklwngt__CmdAppState), "aklwngt:CmdAppState");
	(((aklwngt__CmdAppState*)a)->hash).soap_out(soap, "hash", -1, "");
	soap_out_xsd__int(soap, "stateApp", -1, &(((aklwngt__CmdAppState*)a)->stateApp), "");
	soap_out_xsd__int(soap, "stateRTP", -1, &(((aklwngt__CmdAppState*)a)->stateRTP), "");
	soap_out_xsd__dateTime(soap, "lastFullScan", -1, &(((aklwngt__CmdAppState*)a)->lastFullScan), "");
	soap_out_xsd__dateTime(soap, "lastUpdateTime", -1, &(((aklwngt__CmdAppState*)a)->lastUpdateTime), "");
	soap_out_xsd__dateTime(soap, "basesDate", -1, &(((aklwngt__CmdAppState*)a)->basesDate), "");
	soap_out_xsd__dateTime(soap, "basesInstallDate", -1, &(((aklwngt__CmdAppState*)a)->basesInstallDate), "");
	soap_out_xsd__int(soap, "basesRecords", -1, &(((aklwngt__CmdAppState*)a)->basesRecords), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *aklwngt__CmdAppState::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_aklwngt__CmdAppState(soap, this, tag, type);
}

SOAP_FMAC3 aklwngt__CmdAppState * SOAP_FMAC4 soap_get_aklwngt__CmdAppState(struct soap *soap, aklwngt__CmdAppState *p, const char *tag, const char *type)
{
	if ((p = soap_in_aklwngt__CmdAppState(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *aklwngt__CmdAppState::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_aklwngt__CmdAppState(soap, tag, this, type);
}

SOAP_FMAC3 aklwngt__CmdAppState * SOAP_FMAC4 soap_in_aklwngt__CmdAppState(struct soap *soap, const char *tag, aklwngt__CmdAppState *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (aklwngt__CmdAppState *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_aklwngt__CmdAppState, sizeof(aklwngt__CmdAppState), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_aklwngt__CmdAppState)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (aklwngt__CmdAppState *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_hash1 = 1, soap_flag_stateApp1 = 1, soap_flag_stateRTP1 = 1, soap_flag_lastFullScan1 = 1, soap_flag_lastUpdateTime1 = 1, soap_flag_basesDate1 = 1, soap_flag_basesInstallDate1 = 1, soap_flag_basesRecords1 = 1;
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_hash1 && soap->error == SOAP_TAG_MISMATCH)
				if ((((aklwngt__CmdAppState*)a)->hash).soap_in(soap, "hash", "xsd:base64Binary"))
				{	soap_flag_hash1 = 0;
					continue;
				}
			if (soap_flag_stateApp1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "stateApp", &(((aklwngt__CmdAppState*)a)->stateApp), "xsd:int"))
				{	soap_flag_stateApp1 = 0;
					continue;
				}
			if (soap_flag_stateRTP1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "stateRTP", &(((aklwngt__CmdAppState*)a)->stateRTP), "xsd:int"))
				{	soap_flag_stateRTP1 = 0;
					continue;
				}
			if (soap_flag_lastFullScan1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__dateTime(soap, "lastFullScan", &(((aklwngt__CmdAppState*)a)->lastFullScan), "xsd:dateTime"))
				{	soap_flag_lastFullScan1 = 0;
					continue;
				}
			if (soap_flag_lastUpdateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__dateTime(soap, "lastUpdateTime", &(((aklwngt__CmdAppState*)a)->lastUpdateTime), "xsd:dateTime"))
				{	soap_flag_lastUpdateTime1 = 0;
					continue;
				}
			if (soap_flag_basesDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__dateTime(soap, "basesDate", &(((aklwngt__CmdAppState*)a)->basesDate), "xsd:dateTime"))
				{	soap_flag_basesDate1 = 0;
					continue;
				}
			if (soap_flag_basesInstallDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__dateTime(soap, "basesInstallDate", &(((aklwngt__CmdAppState*)a)->basesInstallDate), "xsd:dateTime"))
				{	soap_flag_basesInstallDate1 = 0;
					continue;
				}
			if (soap_flag_basesRecords1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "basesRecords", &(((aklwngt__CmdAppState*)a)->basesRecords), "xsd:int"))
				{	soap_flag_basesRecords1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_hash1 || soap_flag_stateApp1 || soap_flag_stateRTP1 || soap_flag_basesRecords1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (aklwngt__CmdAppState *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_aklwngt__CmdAppState, 0, sizeof(aklwngt__CmdAppState), 0, soap_copy_aklwngt__CmdAppState);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 aklwngt__CmdAppState * SOAP_FMAC6 soap_new_aklwngt__CmdAppState(struct soap *soap, int n)
{	return soap_instantiate_aklwngt__CmdAppState(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_aklwngt__CmdAppState(struct soap *soap, aklwngt__CmdAppState *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 aklwngt__CmdAppState * SOAP_FMAC6 soap_instantiate_aklwngt__CmdAppState(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_aklwngt__CmdAppState(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_aklwngt__CmdAppState, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new aklwngt__CmdAppState;
		if (size)
			*size = sizeof(aklwngt__CmdAppState);
	}
	else
	{	cp->ptr = (void*)new aklwngt__CmdAppState[n];
		if (size)
			*size = n * sizeof(aklwngt__CmdAppState);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (aklwngt__CmdAppState*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_aklwngt__CmdAppState(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying aklwngt__CmdAppState %p -> %p\n", q, p));
	*(aklwngt__CmdAppState*)p = *(aklwngt__CmdAppState*)q;
}

void aklwngt__CmdAppInfo::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void aklwngt__CmdAppInfo::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((aklwngt__CmdAppInfo*)this)->hash, SOAP_TYPE_xsd__base64Binary);
	((aklwngt__CmdAppInfo*)this)->hash.soap_mark(soap);
	soap_embedded(soap, &((aklwngt__CmdAppInfo*)this)->prodInfo, SOAP_TYPE_aklwngt__ProdInfo);
	soap_mark_aklwngt__ProdInfo(soap, &((aklwngt__CmdAppInfo*)this)->prodInfo);
	soap_embedded(soap, &((aklwngt__CmdAppInfo*)this)->licenseInfo, SOAP_TYPE_aklwngt__LicenseInfo);
	soap_mark_aklwngt__LicenseInfo(soap, &((aklwngt__CmdAppInfo*)this)->licenseInfo);
	soap_embedded(soap, &((aklwngt__CmdAppInfo*)this)->devInfo, SOAP_TYPE_aklwngt__DevInfo);
	soap_mark_aklwngt__DevInfo(soap, &((aklwngt__CmdAppInfo*)this)->devInfo);
}

void aklwngt__CmdAppInfo::soap_default(struct soap *soap)
{
	((aklwngt__CmdAppInfo*)this)->hash.xsd__base64Binary::soap_default(soap);
	soap_default_aklwngt__ProdInfo(soap, &((aklwngt__CmdAppInfo*)this)->prodInfo);
	soap_default_aklwngt__LicenseInfo(soap, &((aklwngt__CmdAppInfo*)this)->licenseInfo);
	soap_default_aklwngt__DevInfo(soap, &((aklwngt__CmdAppInfo*)this)->devInfo);
}

int aklwngt__CmdAppInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_aklwngt__CmdAppInfo);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int aklwngt__CmdAppInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_aklwngt__CmdAppInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_aklwngt__CmdAppInfo(struct soap *soap, const char *tag, int id, const aklwngt__CmdAppInfo *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_aklwngt__CmdAppInfo), "aklwngt:CmdAppInfo");
	(((aklwngt__CmdAppInfo*)a)->hash).soap_out(soap, "hash", -1, "");
	soap_out_aklwngt__ProdInfo(soap, "prodInfo", -1, &(((aklwngt__CmdAppInfo*)a)->prodInfo), "");
	soap_out_aklwngt__LicenseInfo(soap, "licenseInfo", -1, &(((aklwngt__CmdAppInfo*)a)->licenseInfo), "");
	soap_out_aklwngt__DevInfo(soap, "devInfo", -1, &(((aklwngt__CmdAppInfo*)a)->devInfo), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *aklwngt__CmdAppInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_aklwngt__CmdAppInfo(soap, this, tag, type);
}

SOAP_FMAC3 aklwngt__CmdAppInfo * SOAP_FMAC4 soap_get_aklwngt__CmdAppInfo(struct soap *soap, aklwngt__CmdAppInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_aklwngt__CmdAppInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *aklwngt__CmdAppInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_aklwngt__CmdAppInfo(soap, tag, this, type);
}

SOAP_FMAC3 aklwngt__CmdAppInfo * SOAP_FMAC4 soap_in_aklwngt__CmdAppInfo(struct soap *soap, const char *tag, aklwngt__CmdAppInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (aklwngt__CmdAppInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_aklwngt__CmdAppInfo, sizeof(aklwngt__CmdAppInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_aklwngt__CmdAppInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (aklwngt__CmdAppInfo *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_hash1 = 1, soap_flag_prodInfo1 = 1, soap_flag_licenseInfo1 = 1, soap_flag_devInfo1 = 1;
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_hash1 && soap->error == SOAP_TAG_MISMATCH)
				if ((((aklwngt__CmdAppInfo*)a)->hash).soap_in(soap, "hash", "xsd:base64Binary"))
				{	soap_flag_hash1 = 0;
					continue;
				}
			if (soap_flag_prodInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_aklwngt__ProdInfo(soap, "prodInfo", &(((aklwngt__CmdAppInfo*)a)->prodInfo), "aklwngt:ProdInfo"))
				{	soap_flag_prodInfo1 = 0;
					continue;
				}
			if (soap_flag_licenseInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_aklwngt__LicenseInfo(soap, "licenseInfo", &(((aklwngt__CmdAppInfo*)a)->licenseInfo), "aklwngt:LicenseInfo"))
				{	soap_flag_licenseInfo1 = 0;
					continue;
				}
			if (soap_flag_devInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_aklwngt__DevInfo(soap, "devInfo", &(((aklwngt__CmdAppInfo*)a)->devInfo), "aklwngt:DevInfo"))
				{	soap_flag_devInfo1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_hash1 || soap_flag_prodInfo1 || soap_flag_licenseInfo1 || soap_flag_devInfo1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (aklwngt__CmdAppInfo *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_aklwngt__CmdAppInfo, 0, sizeof(aklwngt__CmdAppInfo), 0, soap_copy_aklwngt__CmdAppInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 aklwngt__CmdAppInfo * SOAP_FMAC6 soap_new_aklwngt__CmdAppInfo(struct soap *soap, int n)
{	return soap_instantiate_aklwngt__CmdAppInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_aklwngt__CmdAppInfo(struct soap *soap, aklwngt__CmdAppInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 aklwngt__CmdAppInfo * SOAP_FMAC6 soap_instantiate_aklwngt__CmdAppInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_aklwngt__CmdAppInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_aklwngt__CmdAppInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new aklwngt__CmdAppInfo;
		if (size)
			*size = sizeof(aklwngt__CmdAppInfo);
	}
	else
	{	cp->ptr = (void*)new aklwngt__CmdAppInfo[n];
		if (size)
			*size = n * sizeof(aklwngt__CmdAppInfo);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (aklwngt__CmdAppInfo*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_aklwngt__CmdAppInfo(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying aklwngt__CmdAppInfo %p -> %p\n", q, p));
	*(aklwngt__CmdAppInfo*)p = *(aklwngt__CmdAppInfo*)q;
}

void aklwngt__CmdSubscriptions::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void aklwngt__CmdSubscriptions::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((aklwngt__CmdSubscriptions*)this)->typesInfo, SOAP_TYPE_aklwngt__string_array);
	soap_mark_aklwngt__string_array(soap, &((aklwngt__CmdSubscriptions*)this)->typesInfo);
	soap_embedded(soap, &((aklwngt__CmdSubscriptions*)this)->typesWarning, SOAP_TYPE_aklwngt__string_array);
	soap_mark_aklwngt__string_array(soap, &((aklwngt__CmdSubscriptions*)this)->typesWarning);
	soap_embedded(soap, &((aklwngt__CmdSubscriptions*)this)->typesError, SOAP_TYPE_aklwngt__string_array);
	soap_mark_aklwngt__string_array(soap, &((aklwngt__CmdSubscriptions*)this)->typesError);
	soap_embedded(soap, &((aklwngt__CmdSubscriptions*)this)->typesCritical, SOAP_TYPE_aklwngt__string_array);
	soap_mark_aklwngt__string_array(soap, &((aklwngt__CmdSubscriptions*)this)->typesCritical);
}

void aklwngt__CmdSubscriptions::soap_default(struct soap *soap)
{
	soap_default_aklwngt__string_array(soap, &((aklwngt__CmdSubscriptions*)this)->typesInfo);
	soap_default_aklwngt__string_array(soap, &((aklwngt__CmdSubscriptions*)this)->typesWarning);
	soap_default_aklwngt__string_array(soap, &((aklwngt__CmdSubscriptions*)this)->typesError);
	soap_default_aklwngt__string_array(soap, &((aklwngt__CmdSubscriptions*)this)->typesCritical);
}

int aklwngt__CmdSubscriptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_aklwngt__CmdSubscriptions);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int aklwngt__CmdSubscriptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_aklwngt__CmdSubscriptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_aklwngt__CmdSubscriptions(struct soap *soap, const char *tag, int id, const aklwngt__CmdSubscriptions *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_aklwngt__CmdSubscriptions), "aklwngt:CmdSubscriptions");
	soap_out_aklwngt__string_array(soap, "typesInfo", -1, &(((aklwngt__CmdSubscriptions*)a)->typesInfo), "");
	soap_out_aklwngt__string_array(soap, "typesWarning", -1, &(((aklwngt__CmdSubscriptions*)a)->typesWarning), "");
	soap_out_aklwngt__string_array(soap, "typesError", -1, &(((aklwngt__CmdSubscriptions*)a)->typesError), "");
	soap_out_aklwngt__string_array(soap, "typesCritical", -1, &(((aklwngt__CmdSubscriptions*)a)->typesCritical), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *aklwngt__CmdSubscriptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_aklwngt__CmdSubscriptions(soap, this, tag, type);
}

SOAP_FMAC3 aklwngt__CmdSubscriptions * SOAP_FMAC4 soap_get_aklwngt__CmdSubscriptions(struct soap *soap, aklwngt__CmdSubscriptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_aklwngt__CmdSubscriptions(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *aklwngt__CmdSubscriptions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_aklwngt__CmdSubscriptions(soap, tag, this, type);
}

SOAP_FMAC3 aklwngt__CmdSubscriptions * SOAP_FMAC4 soap_in_aklwngt__CmdSubscriptions(struct soap *soap, const char *tag, aklwngt__CmdSubscriptions *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (aklwngt__CmdSubscriptions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_aklwngt__CmdSubscriptions, sizeof(aklwngt__CmdSubscriptions), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_aklwngt__CmdSubscriptions)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (aklwngt__CmdSubscriptions *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_typesInfo1 = 1, soap_flag_typesWarning1 = 1, soap_flag_typesError1 = 1, soap_flag_typesCritical1 = 1;
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_typesInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_aklwngt__string_array(soap, "typesInfo", &(((aklwngt__CmdSubscriptions*)a)->typesInfo), "aklwngt:string-array"))
				{	soap_flag_typesInfo1 = 0;
					continue;
				}
			if (soap_flag_typesWarning1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_aklwngt__string_array(soap, "typesWarning", &(((aklwngt__CmdSubscriptions*)a)->typesWarning), "aklwngt:string-array"))
				{	soap_flag_typesWarning1 = 0;
					continue;
				}
			if (soap_flag_typesError1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_aklwngt__string_array(soap, "typesError", &(((aklwngt__CmdSubscriptions*)a)->typesError), "aklwngt:string-array"))
				{	soap_flag_typesError1 = 0;
					continue;
				}
			if (soap_flag_typesCritical1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_aklwngt__string_array(soap, "typesCritical", &(((aklwngt__CmdSubscriptions*)a)->typesCritical), "aklwngt:string-array"))
				{	soap_flag_typesCritical1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_typesInfo1 || soap_flag_typesWarning1 || soap_flag_typesError1 || soap_flag_typesCritical1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (aklwngt__CmdSubscriptions *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_aklwngt__CmdSubscriptions, 0, sizeof(aklwngt__CmdSubscriptions), 0, soap_copy_aklwngt__CmdSubscriptions);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 aklwngt__CmdSubscriptions * SOAP_FMAC6 soap_new_aklwngt__CmdSubscriptions(struct soap *soap, int n)
{	return soap_instantiate_aklwngt__CmdSubscriptions(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_aklwngt__CmdSubscriptions(struct soap *soap, aklwngt__CmdSubscriptions *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 aklwngt__CmdSubscriptions * SOAP_FMAC6 soap_instantiate_aklwngt__CmdSubscriptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_aklwngt__CmdSubscriptions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_aklwngt__CmdSubscriptions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new aklwngt__CmdSubscriptions;
		if (size)
			*size = sizeof(aklwngt__CmdSubscriptions);
	}
	else
	{	cp->ptr = (void*)new aklwngt__CmdSubscriptions[n];
		if (size)
			*size = n * sizeof(aklwngt__CmdSubscriptions);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (aklwngt__CmdSubscriptions*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_aklwngt__CmdSubscriptions(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying aklwngt__CmdSubscriptions %p -> %p\n", q, p));
	*(aklwngt__CmdSubscriptions*)p = *(aklwngt__CmdSubscriptions*)q;
}

void aklwngt__CmdParAndHash::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void aklwngt__CmdParAndHash::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((aklwngt__CmdParAndHash*)this)->hash, SOAP_TYPE_xsd__base64Binary);
	((aklwngt__CmdParAndHash*)this)->hash.soap_mark(soap);
	soap_embedded(soap, &((aklwngt__CmdParAndHash*)this)->parameters, SOAP_TYPE_param__params);
	((aklwngt__CmdParAndHash*)this)->parameters.soap_mark(soap);
}

void aklwngt__CmdParAndHash::soap_default(struct soap *soap)
{
	((aklwngt__CmdParAndHash*)this)->hash.xsd__base64Binary::soap_default(soap);
	((aklwngt__CmdParAndHash*)this)->parameters.param__params::soap_default(soap);
}

int aklwngt__CmdParAndHash::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_aklwngt__CmdParAndHash);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int aklwngt__CmdParAndHash::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_aklwngt__CmdParAndHash(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_aklwngt__CmdParAndHash(struct soap *soap, const char *tag, int id, const aklwngt__CmdParAndHash *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_aklwngt__CmdParAndHash), "aklwngt:CmdParAndHash");
	(((aklwngt__CmdParAndHash*)a)->hash).soap_out(soap, "hash", -1, "");
	(((aklwngt__CmdParAndHash*)a)->parameters).soap_out(soap, "parameters", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *aklwngt__CmdParAndHash::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_aklwngt__CmdParAndHash(soap, this, tag, type);
}

SOAP_FMAC3 aklwngt__CmdParAndHash * SOAP_FMAC4 soap_get_aklwngt__CmdParAndHash(struct soap *soap, aklwngt__CmdParAndHash *p, const char *tag, const char *type)
{
	if ((p = soap_in_aklwngt__CmdParAndHash(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *aklwngt__CmdParAndHash::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_aklwngt__CmdParAndHash(soap, tag, this, type);
}

SOAP_FMAC3 aklwngt__CmdParAndHash * SOAP_FMAC4 soap_in_aklwngt__CmdParAndHash(struct soap *soap, const char *tag, aklwngt__CmdParAndHash *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (aklwngt__CmdParAndHash *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_aklwngt__CmdParAndHash, sizeof(aklwngt__CmdParAndHash), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_aklwngt__CmdParAndHash)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (aklwngt__CmdParAndHash *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_hash1 = 1, soap_flag_parameters1 = 1;
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_hash1 && soap->error == SOAP_TAG_MISMATCH)
				if ((((aklwngt__CmdParAndHash*)a)->hash).soap_in(soap, "hash", "xsd:base64Binary"))
				{	soap_flag_hash1 = 0;
					continue;
				}
			if (soap_flag_parameters1 && soap->error == SOAP_TAG_MISMATCH)
				if ((((aklwngt__CmdParAndHash*)a)->parameters).soap_in(soap, "parameters", "param:params"))
				{	soap_flag_parameters1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_hash1 || soap_flag_parameters1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (aklwngt__CmdParAndHash *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_aklwngt__CmdParAndHash, 0, sizeof(aklwngt__CmdParAndHash), 0, soap_copy_aklwngt__CmdParAndHash);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 aklwngt__CmdParAndHash * SOAP_FMAC6 soap_new_aklwngt__CmdParAndHash(struct soap *soap, int n)
{	return soap_instantiate_aklwngt__CmdParAndHash(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_aklwngt__CmdParAndHash(struct soap *soap, aklwngt__CmdParAndHash *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 aklwngt__CmdParAndHash * SOAP_FMAC6 soap_instantiate_aklwngt__CmdParAndHash(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_aklwngt__CmdParAndHash(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_aklwngt__CmdParAndHash, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new aklwngt__CmdParAndHash;
		if (size)
			*size = sizeof(aklwngt__CmdParAndHash);
	}
	else
	{	cp->ptr = (void*)new aklwngt__CmdParAndHash[n];
		if (size)
			*size = n * sizeof(aklwngt__CmdParAndHash);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (aklwngt__CmdParAndHash*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_aklwngt__CmdParAndHash(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying aklwngt__CmdParAndHash %p -> %p\n", q, p));
	*(aklwngt__CmdParAndHash*)p = *(aklwngt__CmdParAndHash*)q;
}

void aklwngt__CmdPar::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void aklwngt__CmdPar::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((aklwngt__CmdPar*)this)->parameters, SOAP_TYPE_param__params);
	((aklwngt__CmdPar*)this)->parameters.soap_mark(soap);
}

void aklwngt__CmdPar::soap_default(struct soap *soap)
{
	((aklwngt__CmdPar*)this)->parameters.param__params::soap_default(soap);
}

int aklwngt__CmdPar::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_aklwngt__CmdPar);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int aklwngt__CmdPar::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_aklwngt__CmdPar(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_aklwngt__CmdPar(struct soap *soap, const char *tag, int id, const aklwngt__CmdPar *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_aklwngt__CmdPar), "aklwngt:CmdPar");
	(((aklwngt__CmdPar*)a)->parameters).soap_out(soap, "parameters", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *aklwngt__CmdPar::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_aklwngt__CmdPar(soap, this, tag, type);
}

SOAP_FMAC3 aklwngt__CmdPar * SOAP_FMAC4 soap_get_aklwngt__CmdPar(struct soap *soap, aklwngt__CmdPar *p, const char *tag, const char *type)
{
	if ((p = soap_in_aklwngt__CmdPar(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *aklwngt__CmdPar::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_aklwngt__CmdPar(soap, tag, this, type);
}

SOAP_FMAC3 aklwngt__CmdPar * SOAP_FMAC4 soap_in_aklwngt__CmdPar(struct soap *soap, const char *tag, aklwngt__CmdPar *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (aklwngt__CmdPar *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_aklwngt__CmdPar, sizeof(aklwngt__CmdPar), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_aklwngt__CmdPar)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (aklwngt__CmdPar *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_parameters1 = 1;
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_parameters1 && soap->error == SOAP_TAG_MISMATCH)
				if ((((aklwngt__CmdPar*)a)->parameters).soap_in(soap, "parameters", "param:params"))
				{	soap_flag_parameters1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_parameters1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (aklwngt__CmdPar *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_aklwngt__CmdPar, 0, sizeof(aklwngt__CmdPar), 0, soap_copy_aklwngt__CmdPar);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 aklwngt__CmdPar * SOAP_FMAC6 soap_new_aklwngt__CmdPar(struct soap *soap, int n)
{	return soap_instantiate_aklwngt__CmdPar(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_aklwngt__CmdPar(struct soap *soap, aklwngt__CmdPar *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 aklwngt__CmdPar * SOAP_FMAC6 soap_instantiate_aklwngt__CmdPar(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_aklwngt__CmdPar(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_aklwngt__CmdPar, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new aklwngt__CmdPar;
		if (size)
			*size = sizeof(aklwngt__CmdPar);
	}
	else
	{	cp->ptr = (void*)new aklwngt__CmdPar[n];
		if (size)
			*size = n * sizeof(aklwngt__CmdPar);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (aklwngt__CmdPar*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_aklwngt__CmdPar(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying aklwngt__CmdPar %p -> %p\n", q, p));
	*(aklwngt__CmdPar*)p = *(aklwngt__CmdPar*)q;
}

void aklwngt__CmdHash::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void aklwngt__CmdHash::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((aklwngt__CmdHash*)this)->hash, SOAP_TYPE_xsd__base64Binary);
	((aklwngt__CmdHash*)this)->hash.soap_mark(soap);
}

void aklwngt__CmdHash::soap_default(struct soap *soap)
{
	((aklwngt__CmdHash*)this)->hash.xsd__base64Binary::soap_default(soap);
}

int aklwngt__CmdHash::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_aklwngt__CmdHash);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int aklwngt__CmdHash::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_aklwngt__CmdHash(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_aklwngt__CmdHash(struct soap *soap, const char *tag, int id, const aklwngt__CmdHash *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_aklwngt__CmdHash), "aklwngt:CmdHash");
	(((aklwngt__CmdHash*)a)->hash).soap_out(soap, "hash", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *aklwngt__CmdHash::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_aklwngt__CmdHash(soap, this, tag, type);
}

SOAP_FMAC3 aklwngt__CmdHash * SOAP_FMAC4 soap_get_aklwngt__CmdHash(struct soap *soap, aklwngt__CmdHash *p, const char *tag, const char *type)
{
	if ((p = soap_in_aklwngt__CmdHash(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *aklwngt__CmdHash::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_aklwngt__CmdHash(soap, tag, this, type);
}

SOAP_FMAC3 aklwngt__CmdHash * SOAP_FMAC4 soap_in_aklwngt__CmdHash(struct soap *soap, const char *tag, aklwngt__CmdHash *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (aklwngt__CmdHash *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_aklwngt__CmdHash, sizeof(aklwngt__CmdHash), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_aklwngt__CmdHash)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (aklwngt__CmdHash *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_hash1 = 1;
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_hash1 && soap->error == SOAP_TAG_MISMATCH)
				if ((((aklwngt__CmdHash*)a)->hash).soap_in(soap, "hash", "xsd:base64Binary"))
				{	soap_flag_hash1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_hash1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (aklwngt__CmdHash *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_aklwngt__CmdHash, 0, sizeof(aklwngt__CmdHash), 0, soap_copy_aklwngt__CmdHash);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 aklwngt__CmdHash * SOAP_FMAC6 soap_new_aklwngt__CmdHash(struct soap *soap, int n)
{	return soap_instantiate_aklwngt__CmdHash(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_aklwngt__CmdHash(struct soap *soap, aklwngt__CmdHash *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 aklwngt__CmdHash * SOAP_FMAC6 soap_instantiate_aklwngt__CmdHash(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_aklwngt__CmdHash(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_aklwngt__CmdHash, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new aklwngt__CmdHash;
		if (size)
			*size = sizeof(aklwngt__CmdHash);
	}
	else
	{	cp->ptr = (void*)new aklwngt__CmdHash[n];
		if (size)
			*size = n * sizeof(aklwngt__CmdHash);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (aklwngt__CmdHash*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_aklwngt__CmdHash(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying aklwngt__CmdHash %p -> %p\n", q, p));
	*(aklwngt__CmdHash*)p = *(aklwngt__CmdHash*)q;
}

void aklwngt__CmdError::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void aklwngt__CmdError::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((aklwngt__CmdError*)this)->oError, SOAP_TYPE_param_error);
	soap_mark_param_error(soap, &((aklwngt__CmdError*)this)->oError);
}

void aklwngt__CmdError::soap_default(struct soap *soap)
{
	soap_default_param_error(soap, &((aklwngt__CmdError*)this)->oError);
}

int aklwngt__CmdError::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_aklwngt__CmdError);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int aklwngt__CmdError::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_aklwngt__CmdError(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_aklwngt__CmdError(struct soap *soap, const char *tag, int id, const aklwngt__CmdError *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_aklwngt__CmdError), "aklwngt:CmdError");
	soap_out_param_error(soap, "oError", -1, &(((aklwngt__CmdError*)a)->oError), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *aklwngt__CmdError::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_aklwngt__CmdError(soap, this, tag, type);
}

SOAP_FMAC3 aklwngt__CmdError * SOAP_FMAC4 soap_get_aklwngt__CmdError(struct soap *soap, aklwngt__CmdError *p, const char *tag, const char *type)
{
	if ((p = soap_in_aklwngt__CmdError(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *aklwngt__CmdError::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_aklwngt__CmdError(soap, tag, this, type);
}

SOAP_FMAC3 aklwngt__CmdError * SOAP_FMAC4 soap_in_aklwngt__CmdError(struct soap *soap, const char *tag, aklwngt__CmdError *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (aklwngt__CmdError *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_aklwngt__CmdError, sizeof(aklwngt__CmdError), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_aklwngt__CmdError)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (aklwngt__CmdError *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_oError1 = 1;
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_oError1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_param_error(soap, "oError", &(((aklwngt__CmdError*)a)->oError), ""))
				{	soap_flag_oError1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_oError1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (aklwngt__CmdError *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_aklwngt__CmdError, 0, sizeof(aklwngt__CmdError), 0, soap_copy_aklwngt__CmdError);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 aklwngt__CmdError * SOAP_FMAC6 soap_new_aklwngt__CmdError(struct soap *soap, int n)
{	return soap_instantiate_aklwngt__CmdError(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_aklwngt__CmdError(struct soap *soap, aklwngt__CmdError *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 aklwngt__CmdError * SOAP_FMAC6 soap_instantiate_aklwngt__CmdError(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_aklwngt__CmdError(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_aklwngt__CmdError, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new aklwngt__CmdError;
		if (size)
			*size = sizeof(aklwngt__CmdError);
	}
	else
	{	cp->ptr = (void*)new aklwngt__CmdError[n];
		if (size)
			*size = n * sizeof(aklwngt__CmdError);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (aklwngt__CmdError*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_aklwngt__CmdError(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying aklwngt__CmdError %p -> %p\n", q, p));
	*(aklwngt__CmdError*)p = *(aklwngt__CmdError*)q;
}

void aklwngt__anyCmd::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void aklwngt__anyCmd::soap_mark(struct soap *soap) const
{
}

void aklwngt__anyCmd::soap_default(struct soap *soap)
{
}

int aklwngt__anyCmd::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_aklwngt__anyCmd);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int aklwngt__anyCmd::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_aklwngt__anyCmd(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_aklwngt__anyCmd(struct soap *soap, const char *tag, int id, const aklwngt__anyCmd *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_aklwngt__anyCmd), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *aklwngt__anyCmd::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_aklwngt__anyCmd(soap, this, tag, type);
}

SOAP_FMAC3 aklwngt__anyCmd * SOAP_FMAC4 soap_get_aklwngt__anyCmd(struct soap *soap, aklwngt__anyCmd *p, const char *tag, const char *type)
{
	if ((p = soap_in_aklwngt__anyCmd(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *aklwngt__anyCmd::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_aklwngt__anyCmd(soap, tag, this, type);
}

SOAP_FMAC3 aklwngt__anyCmd * SOAP_FMAC4 soap_in_aklwngt__anyCmd(struct soap *soap, const char *tag, aklwngt__anyCmd *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (aklwngt__anyCmd *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_aklwngt__anyCmd, sizeof(aklwngt__anyCmd), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_aklwngt__anyCmd)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (aklwngt__anyCmd *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (aklwngt__anyCmd *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_aklwngt__anyCmd, 0, sizeof(aklwngt__anyCmd), 0, soap_copy_aklwngt__anyCmd);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 aklwngt__anyCmd * SOAP_FMAC6 soap_new_aklwngt__anyCmd(struct soap *soap, int n)
{	return soap_instantiate_aklwngt__anyCmd(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_aklwngt__anyCmd(struct soap *soap, aklwngt__anyCmd *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 aklwngt__anyCmd * SOAP_FMAC6 soap_instantiate_aklwngt__anyCmd(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_aklwngt__anyCmd(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_aklwngt__anyCmd, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "aklwngt:CmdError"))
	{	cp->type = SOAP_TYPE_aklwngt__CmdError;
		if (n < 0)
		{	cp->ptr = (void*)new aklwngt__CmdError;
			if (size)
				*size = sizeof(aklwngt__CmdError);
		}
		else
		{	cp->ptr = (void*)new aklwngt__CmdError[n];
			if (size)
				*size = n * sizeof(aklwngt__CmdError);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (aklwngt__CmdError*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "aklwngt:CmdHash"))
	{	cp->type = SOAP_TYPE_aklwngt__CmdHash;
		if (n < 0)
		{	cp->ptr = (void*)new aklwngt__CmdHash;
			if (size)
				*size = sizeof(aklwngt__CmdHash);
		}
		else
		{	cp->ptr = (void*)new aklwngt__CmdHash[n];
			if (size)
				*size = n * sizeof(aklwngt__CmdHash);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (aklwngt__CmdHash*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "aklwngt:CmdPar"))
	{	cp->type = SOAP_TYPE_aklwngt__CmdPar;
		if (n < 0)
		{	cp->ptr = (void*)new aklwngt__CmdPar;
			if (size)
				*size = sizeof(aklwngt__CmdPar);
		}
		else
		{	cp->ptr = (void*)new aklwngt__CmdPar[n];
			if (size)
				*size = n * sizeof(aklwngt__CmdPar);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (aklwngt__CmdPar*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "aklwngt:CmdParAndHash"))
	{	cp->type = SOAP_TYPE_aklwngt__CmdParAndHash;
		if (n < 0)
		{	cp->ptr = (void*)new aklwngt__CmdParAndHash;
			if (size)
				*size = sizeof(aklwngt__CmdParAndHash);
		}
		else
		{	cp->ptr = (void*)new aklwngt__CmdParAndHash[n];
			if (size)
				*size = n * sizeof(aklwngt__CmdParAndHash);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (aklwngt__CmdParAndHash*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "aklwngt:CmdSubscriptions"))
	{	cp->type = SOAP_TYPE_aklwngt__CmdSubscriptions;
		if (n < 0)
		{	cp->ptr = (void*)new aklwngt__CmdSubscriptions;
			if (size)
				*size = sizeof(aklwngt__CmdSubscriptions);
		}
		else
		{	cp->ptr = (void*)new aklwngt__CmdSubscriptions[n];
			if (size)
				*size = n * sizeof(aklwngt__CmdSubscriptions);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (aklwngt__CmdSubscriptions*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "aklwngt:CmdAppInfo"))
	{	cp->type = SOAP_TYPE_aklwngt__CmdAppInfo;
		if (n < 0)
		{	cp->ptr = (void*)new aklwngt__CmdAppInfo;
			if (size)
				*size = sizeof(aklwngt__CmdAppInfo);
		}
		else
		{	cp->ptr = (void*)new aklwngt__CmdAppInfo[n];
			if (size)
				*size = n * sizeof(aklwngt__CmdAppInfo);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (aklwngt__CmdAppInfo*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "aklwngt:CmdAppState"))
	{	cp->type = SOAP_TYPE_aklwngt__CmdAppState;
		if (n < 0)
		{	cp->ptr = (void*)new aklwngt__CmdAppState;
			if (size)
				*size = sizeof(aklwngt__CmdAppState);
		}
		else
		{	cp->ptr = (void*)new aklwngt__CmdAppState[n];
			if (size)
				*size = n * sizeof(aklwngt__CmdAppState);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (aklwngt__CmdAppState*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new aklwngt__anyCmd;
		if (size)
			*size = sizeof(aklwngt__anyCmd);
	}
	else
	{	cp->ptr = (void*)new aklwngt__anyCmd[n];
		if (size)
			*size = n * sizeof(aklwngt__anyCmd);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (aklwngt__anyCmd*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_aklwngt__anyCmd(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying aklwngt__anyCmd %p -> %p\n", q, p));
	*(aklwngt__anyCmd*)p = *(aklwngt__anyCmd*)q;
}

void param__arrayvalue::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void param__arrayvalue::soap_mark(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_param__arrayvalue))
		for (int i = 0; i < this->__size; i++)
		{	soap_embedded(soap, this->__ptr + i, SOAP_TYPE_param__value);
			this->__ptr[i].soap_mark(soap);
		}
}

void param__arrayvalue::soap_default(struct soap *soap)
{
	this->__size = 0;
	this->__ptr = NULL;
}

int param__arrayvalue::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_param__arrayvalue);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int param__arrayvalue::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_param__arrayvalue(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_param__arrayvalue(struct soap *soap, const char *tag, int id, const param__arrayvalue *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_param__arrayvalue);
	if (id < 0)
		return soap->error;
	soap_element_begin_out(soap, tag, id, "param:arrayvalue");
	for (i = 0; i < n; i++)
	{
		soap_out_param__value(soap, "item", -1, &a->__ptr[i], "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *param__arrayvalue::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_param__arrayvalue(soap, this, tag, type);
}

SOAP_FMAC3 param__arrayvalue * SOAP_FMAC4 soap_get_param__arrayvalue(struct soap *soap, param__arrayvalue *p, const char *tag, const char *type)
{
	if ((p = soap_in_param__arrayvalue(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *param__arrayvalue::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_param__arrayvalue(soap, tag, this, type);
}

SOAP_FMAC3 param__arrayvalue * SOAP_FMAC4 soap_in_param__arrayvalue(struct soap *soap, const char *tag, param__arrayvalue *a, const char *type)
{	int i, j;
	param__value *p;
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (param__arrayvalue *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_param__arrayvalue, sizeof(param__arrayvalue), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = soap_new_param__value(soap, a->__size);
			for (i = 0; i < a->__size; i++)
				(a->__ptr+i)->param__value::soap_default(soap);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_param__value(soap, NULL, a->__ptr + i, "param:value"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	param__value q;
			soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (param__value *)soap_push_block(soap, sizeof(param__value));
				if (!p)
					return NULL;
				memcpy(p, &q, sizeof(param__value));
				p->soap_default(soap);
				if (!soap_in_param__value(soap, NULL, p, "param:value"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			if (soap->blist->size)
				a->__ptr = soap_new_param__value(soap, soap->blist->size/sizeof(param__value));
			else
				a->__ptr = NULL;
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (param__arrayvalue *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_param__arrayvalue, 0, sizeof(param__arrayvalue), 0, soap_copy_param__arrayvalue);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 param__arrayvalue * SOAP_FMAC6 soap_new_param__arrayvalue(struct soap *soap, int n)
{	return soap_instantiate_param__arrayvalue(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_param__arrayvalue(struct soap *soap, param__arrayvalue *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 param__arrayvalue * SOAP_FMAC6 soap_instantiate_param__arrayvalue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_param__arrayvalue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_param__arrayvalue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new param__arrayvalue;
		if (size)
			*size = sizeof(param__arrayvalue);
	}
	else
	{	cp->ptr = (void*)new param__arrayvalue[n];
		if (size)
			*size = n * sizeof(param__arrayvalue);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (param__arrayvalue*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_param__arrayvalue(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying param__arrayvalue %p -> %p\n", q, p));
	*(param__arrayvalue*)p = *(param__arrayvalue*)q;
}

void param__params::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void param__params::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((param__params*)this)->node, SOAP_TYPE_PointerToparam__node);
	soap_mark_PointerToparam__node(soap, &((param__params*)this)->node);
	soap_embedded(soap, &((param__params*)this)->checksum, SOAP_TYPE_xsd__int);
	soap_embedded(soap, &((param__params*)this)->binfmt, SOAP_TYPE_xsd__base64Binary);
	((param__params*)this)->binfmt.soap_mark(soap);
}

void param__params::soap_default(struct soap *soap)
{
	((param__params*)this)->node = NULL;
	soap_default_xsd__int(soap, &((param__params*)this)->checksum);
	((param__params*)this)->binfmt.xsd__base64Binary::soap_default(soap);
}

int param__params::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_param__params);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int param__params::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_param__params(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_param__params(struct soap *soap, const char *tag, int id, const param__params *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_param__params), "param:params");
	soap_out_PointerToparam__node(soap, "node", -1, &(((param__params*)a)->node), "");
	soap_out_xsd__int(soap, "checksum", -1, &(((param__params*)a)->checksum), "");
	(((param__params*)a)->binfmt).soap_out(soap, "binfmt", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *param__params::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_param__params(soap, this, tag, type);
}

SOAP_FMAC3 param__params * SOAP_FMAC4 soap_get_param__params(struct soap *soap, param__params *p, const char *tag, const char *type)
{
	if ((p = soap_in_param__params(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *param__params::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_param__params(soap, tag, this, type);
}

SOAP_FMAC3 param__params * SOAP_FMAC4 soap_in_param__params(struct soap *soap, const char *tag, param__params *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (param__params *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_param__params, sizeof(param__params), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_param__params)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (param__params *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_node1 = 1, soap_flag_checksum1 = 1, soap_flag_binfmt1 = 1;
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_node1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToparam__node(soap, "node", &(((param__params*)a)->node), "param:node"))
				{	soap_flag_node1 = 0;
					continue;
				}
			if (soap_flag_checksum1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "checksum", &(((param__params*)a)->checksum), "xsd:int"))
				{	soap_flag_checksum1 = 0;
					continue;
				}
			if (soap_flag_binfmt1 && soap->error == SOAP_TAG_MISMATCH)
				if ((((param__params*)a)->binfmt).soap_in(soap, "binfmt", "xsd:base64Binary"))
				{	soap_flag_binfmt1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_checksum1 || soap_flag_binfmt1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (param__params *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_param__params, 0, sizeof(param__params), 0, soap_copy_param__params);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 param__params * SOAP_FMAC6 soap_new_param__params(struct soap *soap, int n)
{	return soap_instantiate_param__params(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_param__params(struct soap *soap, param__params *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 param__params * SOAP_FMAC6 soap_instantiate_param__params(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_param__params(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_param__params, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new param__params;
		if (size)
			*size = sizeof(param__params);
	}
	else
	{	cp->ptr = (void*)new param__params[n];
		if (size)
			*size = n * sizeof(param__params);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (param__params*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_param__params(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying param__params %p -> %p\n", q, p));
	*(param__params*)p = *(param__params*)q;
}

void param__node::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void param__node::soap_mark(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_param__node))
		for (int i = 0; i < this->__size; i++)
		{	soap_embedded(soap, this->__ptr + i, SOAP_TYPE_param__entry);
			this->__ptr[i].soap_mark(soap);
		}
}

void param__node::soap_default(struct soap *soap)
{
	this->__size = 0;
	this->__ptr = NULL;
}

int param__node::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_param__node);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int param__node::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_param__node(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_param__node(struct soap *soap, const char *tag, int id, const param__node *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_param__node);
	if (id < 0)
		return soap->error;
	soap_element_begin_out(soap, tag, id, type);
	for (i = 0; i < n; i++)
	{
		soap_out_param__entry(soap, "item", -1, &a->__ptr[i], "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *param__node::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_param__node(soap, this, tag, type);
}

SOAP_FMAC3 param__node * SOAP_FMAC4 soap_get_param__node(struct soap *soap, param__node *p, const char *tag, const char *type)
{
	if ((p = soap_in_param__node(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *param__node::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_param__node(soap, tag, this, type);
}

SOAP_FMAC3 param__node * SOAP_FMAC4 soap_in_param__node(struct soap *soap, const char *tag, param__node *a, const char *type)
{	int i, j;
	param__entry *p;
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (param__node *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_param__node, sizeof(param__node), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = soap_new_param__entry(soap, a->__size);
			for (i = 0; i < a->__size; i++)
				(a->__ptr+i)->param__entry::soap_default(soap);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_param__entry(soap, NULL, a->__ptr + i, "param:entry"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	param__entry q;
			soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (param__entry *)soap_push_block(soap, sizeof(param__entry));
				if (!p)
					return NULL;
				memcpy(p, &q, sizeof(param__entry));
				p->soap_default(soap);
				if (!soap_in_param__entry(soap, NULL, p, "param:entry"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			if (soap->blist->size)
				a->__ptr = soap_new_param__entry(soap, soap->blist->size/sizeof(param__entry));
			else
				a->__ptr = NULL;
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (param__node *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_param__node, 0, sizeof(param__node), 0, soap_copy_param__node);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 param__node * SOAP_FMAC6 soap_new_param__node(struct soap *soap, int n)
{	return soap_instantiate_param__node(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_param__node(struct soap *soap, param__node *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 param__node * SOAP_FMAC6 soap_instantiate_param__node(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_param__node(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_param__node, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new param__node;
		if (size)
			*size = sizeof(param__node);
	}
	else
	{	cp->ptr = (void*)new param__node[n];
		if (size)
			*size = n * sizeof(param__node);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (param__node*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_param__node(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying param__node %p -> %p\n", q, p));
	*(param__node*)p = *(param__node*)q;
}

void param__entry::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void param__entry::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((param__entry*)this)->name, SOAP_TYPE_xsd__wstring);
	soap_mark_xsd__wstring(soap, &((param__entry*)this)->name);
	soap_embedded(soap, &((param__entry*)this)->value, SOAP_TYPE_param__value);
	((param__entry*)this)->value.soap_mark(soap);
}

void param__entry::soap_default(struct soap *soap)
{
	((param__entry*)this)->name = NULL;
	((param__entry*)this)->value.param__value::soap_default(soap);
}

int param__entry::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_param__entry);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int param__entry::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_param__entry(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_param__entry(struct soap *soap, const char *tag, int id, const param__entry *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_param__entry), type);
	soap_out_xsd__wstring(soap, "name", -1, &(((param__entry*)a)->name), "");
	(((param__entry*)a)->value).soap_out(soap, "value", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *param__entry::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_param__entry(soap, this, tag, type);
}

SOAP_FMAC3 param__entry * SOAP_FMAC4 soap_get_param__entry(struct soap *soap, param__entry *p, const char *tag, const char *type)
{
	if ((p = soap_in_param__entry(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *param__entry::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_param__entry(soap, tag, this, type);
}

SOAP_FMAC3 param__entry * SOAP_FMAC4 soap_in_param__entry(struct soap *soap, const char *tag, param__entry *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (param__entry *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_param__entry, sizeof(param__entry), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_param__entry)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (param__entry *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_name1 = 1, soap_flag_value1 = 1;
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__wstring(soap, "name", &(((param__entry*)a)->name), "xsd:wstring"))
				{	soap_flag_name1 = 0;
					continue;
				}
			if (soap_flag_value1 && soap->error == SOAP_TAG_MISMATCH)
				if ((((param__entry*)a)->value).soap_in(soap, "value", "param:value"))
				{	soap_flag_value1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_value1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (param__entry *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_param__entry, 0, sizeof(param__entry), 0, soap_copy_param__entry);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 param__entry * SOAP_FMAC6 soap_new_param__entry(struct soap *soap, int n)
{	return soap_instantiate_param__entry(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_param__entry(struct soap *soap, param__entry *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 param__entry * SOAP_FMAC6 soap_instantiate_param__entry(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_param__entry(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_param__entry, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new param__entry;
		if (size)
			*size = sizeof(param__entry);
	}
	else
	{	cp->ptr = (void*)new param__entry[n];
		if (size)
			*size = n * sizeof(param__entry);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (param__entry*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_param__entry(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying param__entry %p -> %p\n", q, p));
	*(param__entry*)p = *(param__entry*)q;
}

void param__value::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void param__value::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((param__value*)this)->data, SOAP_TYPE_PointerToxsd__anyType);
	soap_mark_PointerToxsd__anyType(soap, &((param__value*)this)->data);
}

void param__value::soap_default(struct soap *soap)
{
	((param__value*)this)->data = NULL;
}

int param__value::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_param__value);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int param__value::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_param__value(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_param__value(struct soap *soap, const char *tag, int id, const param__value *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_param__value), type);
	soap_out_PointerToxsd__anyType(soap, "data", -1, &(((param__value*)a)->data), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *param__value::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_param__value(soap, this, tag, type);
}

SOAP_FMAC3 param__value * SOAP_FMAC4 soap_get_param__value(struct soap *soap, param__value *p, const char *tag, const char *type)
{
	if ((p = soap_in_param__value(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *param__value::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_param__value(soap, tag, this, type);
}

SOAP_FMAC3 param__value * SOAP_FMAC4 soap_in_param__value(struct soap *soap, const char *tag, param__value *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (param__value *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_param__value, sizeof(param__value), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_param__value)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (param__value *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_data1 = 1;
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_data1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "data", &(((param__value*)a)->data), "xsd:anyType"))
				{	soap_flag_data1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (param__value *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_param__value, 0, sizeof(param__value), 0, soap_copy_param__value);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 param__value * SOAP_FMAC6 soap_new_param__value(struct soap *soap, int n)
{	return soap_instantiate_param__value(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_param__value(struct soap *soap, param__value *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 param__value * SOAP_FMAC6 soap_instantiate_param__value(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_param__value(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_param__value, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new param__value;
		if (size)
			*size = sizeof(param__value);
	}
	else
	{	cp->ptr = (void*)new param__value[n];
		if (size)
			*size = n * sizeof(param__value);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (param__value*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_param__value(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying param__value %p -> %p\n", q, p));
	*(param__value*)p = *(param__value*)q;
}

void param_error_loc::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void param_error_loc::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((param_error_loc*)this)->format_id, SOAP_TYPE_xsd__int);
	soap_embedded(soap, &((param_error_loc*)this)->format, SOAP_TYPE_xsd__wstring);
	soap_mark_xsd__wstring(soap, &((param_error_loc*)this)->format);
	soap_embedded(soap, &((param_error_loc*)this)->locmodule, SOAP_TYPE_xsd__wstring);
	soap_mark_xsd__wstring(soap, &((param_error_loc*)this)->locmodule);
	soap_embedded(soap, &((param_error_loc*)this)->args, SOAP_TYPE_param_error_loc_args);
	((param_error_loc*)this)->args.soap_mark(soap);
}

void param_error_loc::soap_default(struct soap *soap)
{
	soap_default_xsd__int(soap, &((param_error_loc*)this)->format_id);
	((param_error_loc*)this)->format = NULL;
	((param_error_loc*)this)->locmodule = NULL;
	((param_error_loc*)this)->args.param_error_loc_args::soap_default(soap);
}

int param_error_loc::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_param_error_loc);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int param_error_loc::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_param_error_loc(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_param_error_loc(struct soap *soap, const char *tag, int id, const param_error_loc *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_param_error_loc), type);
	soap_out_xsd__int(soap, "format-id", -1, &(((param_error_loc*)a)->format_id), "");
	soap_out_xsd__wstring(soap, "format", -1, &(((param_error_loc*)a)->format), "");
	soap_out_xsd__wstring(soap, "locmodule", -1, &(((param_error_loc*)a)->locmodule), "");
	(((param_error_loc*)a)->args).soap_out(soap, "args", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *param_error_loc::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_param_error_loc(soap, this, tag, type);
}

SOAP_FMAC3 param_error_loc * SOAP_FMAC4 soap_get_param_error_loc(struct soap *soap, param_error_loc *p, const char *tag, const char *type)
{
	if ((p = soap_in_param_error_loc(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *param_error_loc::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_param_error_loc(soap, tag, this, type);
}

SOAP_FMAC3 param_error_loc * SOAP_FMAC4 soap_in_param_error_loc(struct soap *soap, const char *tag, param_error_loc *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (param_error_loc *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_param_error_loc, sizeof(param_error_loc), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_param_error_loc)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (param_error_loc *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_format_id1 = 1, soap_flag_format1 = 1, soap_flag_locmodule1 = 1, soap_flag_args1 = 1;
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_format_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "format-id", &(((param_error_loc*)a)->format_id), "xsd:int"))
				{	soap_flag_format_id1 = 0;
					continue;
				}
			if (soap_flag_format1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__wstring(soap, "format", &(((param_error_loc*)a)->format), "xsd:wstring"))
				{	soap_flag_format1 = 0;
					continue;
				}
			if (soap_flag_locmodule1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__wstring(soap, "locmodule", &(((param_error_loc*)a)->locmodule), "xsd:wstring"))
				{	soap_flag_locmodule1 = 0;
					continue;
				}
			if (soap_flag_args1 && soap->error == SOAP_TAG_MISMATCH)
				if ((((param_error_loc*)a)->args).soap_in(soap, "args", "xsd:wstring"))
				{	soap_flag_args1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_format_id1 || soap_flag_args1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (param_error_loc *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_param_error_loc, 0, sizeof(param_error_loc), 0, soap_copy_param_error_loc);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 param_error_loc * SOAP_FMAC6 soap_new_param_error_loc(struct soap *soap, int n)
{	return soap_instantiate_param_error_loc(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_param_error_loc(struct soap *soap, param_error_loc *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 param_error_loc * SOAP_FMAC6 soap_instantiate_param_error_loc(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_param_error_loc(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_param_error_loc, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new param_error_loc;
		if (size)
			*size = sizeof(param_error_loc);
	}
	else
	{	cp->ptr = (void*)new param_error_loc[n];
		if (size)
			*size = n * sizeof(param_error_loc);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (param_error_loc*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_param_error_loc(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying param_error_loc %p -> %p\n", q, p));
	*(param_error_loc*)p = *(param_error_loc*)q;
}

void param_error_loc_args::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void param_error_loc_args::soap_mark(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_param_error_loc_args))
		for (int i = 0; i < this->__size; i++)
		{	soap_embedded(soap, this->__ptr + i, SOAP_TYPE_xsd__wstring);
			soap_mark_xsd__wstring(soap, this->__ptr + i);
		}
}

void param_error_loc_args::soap_default(struct soap *soap)
{
	this->__size = 0;
	this->__ptr = NULL;
}

int param_error_loc_args::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_param_error_loc_args);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int param_error_loc_args::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_param_error_loc_args(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_param_error_loc_args(struct soap *soap, const char *tag, int id, const param_error_loc_args *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "xsd:wstring", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_param_error_loc_args);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_xsd__wstring(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *param_error_loc_args::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_param_error_loc_args(soap, this, tag, type);
}

SOAP_FMAC3 param_error_loc_args * SOAP_FMAC4 soap_get_param_error_loc_args(struct soap *soap, param_error_loc_args *p, const char *tag, const char *type)
{
	if ((p = soap_in_param_error_loc_args(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *param_error_loc_args::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_param_error_loc_args(soap, tag, this, type);
}

SOAP_FMAC3 param_error_loc_args * SOAP_FMAC4 soap_in_param_error_loc_args(struct soap *soap, const char *tag, param_error_loc_args *a, const char *type)
{	int i, j;
	wchar_t **p;
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (param_error_loc_args *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_param_error_loc_args, sizeof(param_error_loc_args), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (wchar_t **)soap_malloc(soap, sizeof(wchar_t *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_xsd__wstring(soap, NULL, a->__ptr + i, "xsd:wstring"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (wchar_t **)soap_push_block(soap, sizeof(wchar_t *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_xsd__wstring(soap, NULL, p, "xsd:wstring"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (wchar_t **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 0);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (param_error_loc_args *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_param_error_loc_args, 0, sizeof(param_error_loc_args), 0, soap_copy_param_error_loc_args);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 param_error_loc_args * SOAP_FMAC6 soap_new_param_error_loc_args(struct soap *soap, int n)
{	return soap_instantiate_param_error_loc_args(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_param_error_loc_args(struct soap *soap, param_error_loc_args *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 param_error_loc_args * SOAP_FMAC6 soap_instantiate_param_error_loc_args(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_param_error_loc_args(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_param_error_loc_args, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new param_error_loc_args;
		if (size)
			*size = sizeof(param_error_loc_args);
	}
	else
	{	cp->ptr = (void*)new param_error_loc_args[n];
		if (size)
			*size = n * sizeof(param_error_loc_args);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (param_error_loc_args*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_param_error_loc_args(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying param_error_loc_args %p -> %p\n", q, p));
	*(param_error_loc_args*)p = *(param_error_loc_args*)q;
}

void xsd__hexBinary::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__hexBinary::soap_mark(struct soap *soap) const
{
	if (this->__ptr)
		soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_xsd__hexBinary);
}

void xsd__hexBinary::soap_default(struct soap *soap)
{
	this->__size = 0;
	this->__ptr = NULL;
}

int xsd__hexBinary::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_xsd__hexBinary);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__hexBinary::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_xsd__hexBinary(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__hexBinary(struct soap *soap, const char *tag, int id, const xsd__hexBinary *a, const char *type)
{
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_xsd__hexBinary);
	if (id < 0)
		return soap->error;
	soap_element_begin_out(soap, tag, id, "xsd:hexBinary");
	soap_puthex(soap, a->__ptr, a->__size);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *xsd__hexBinary::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__hexBinary(soap, this, tag, type);
}

SOAP_FMAC3 xsd__hexBinary * SOAP_FMAC4 soap_get_xsd__hexBinary(struct soap *soap, xsd__hexBinary *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__hexBinary(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__hexBinary::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__hexBinary(soap, tag, this, type);
}

SOAP_FMAC3 xsd__hexBinary * SOAP_FMAC4 soap_in_xsd__hexBinary(struct soap *soap, const char *tag, xsd__hexBinary *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":hexBinary"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__hexBinary *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__hexBinary, sizeof(xsd__hexBinary), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_gethex(soap, &a->__size);
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (xsd__hexBinary *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_xsd__hexBinary, 0, sizeof(xsd__hexBinary), 0, soap_copy_xsd__hexBinary);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 xsd__hexBinary * SOAP_FMAC6 soap_new_xsd__hexBinary(struct soap *soap, int n)
{	return soap_instantiate_xsd__hexBinary(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__hexBinary(struct soap *soap, xsd__hexBinary *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__hexBinary * SOAP_FMAC6 soap_instantiate_xsd__hexBinary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__hexBinary(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__hexBinary, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__hexBinary;
		if (size)
			*size = sizeof(xsd__hexBinary);
	}
	else
	{	cp->ptr = (void*)new xsd__hexBinary[n];
		if (size)
			*size = n * sizeof(xsd__hexBinary);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__hexBinary*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__hexBinary(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__hexBinary %p -> %p\n", q, p));
	*(xsd__hexBinary*)p = *(xsd__hexBinary*)q;
}

void xsd__base64Binary::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__base64Binary::soap_mark(struct soap *soap) const
{
	if (this->__ptr)
		soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_xsd__base64Binary);
}

void xsd__base64Binary::soap_default(struct soap *soap)
{
	this->__size = 0;
	this->__ptr = NULL;
}

int xsd__base64Binary::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_xsd__base64Binary);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__base64Binary::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_xsd__base64Binary(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__base64Binary(struct soap *soap, const char *tag, int id, const xsd__base64Binary *a, const char *type)
{
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_xsd__base64Binary);
	if (id < 0)
		return soap->error;
	soap_element_begin_out(soap, tag, id, "xsd:base64Binary");
	soap_putbase64(soap, a->__ptr, a->__size);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *xsd__base64Binary::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__base64Binary(soap, this, tag, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_get_xsd__base64Binary(struct soap *soap, xsd__base64Binary *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__base64Binary(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__base64Binary::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__base64Binary(soap, tag, this, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_in_xsd__base64Binary(struct soap *soap, const char *tag, xsd__base64Binary *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__base64Binary *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (xsd__base64Binary *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_xsd__base64Binary, 0, sizeof(xsd__base64Binary), 0, soap_copy_xsd__base64Binary);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 xsd__base64Binary * SOAP_FMAC6 soap_new_xsd__base64Binary(struct soap *soap, int n)
{	return soap_instantiate_xsd__base64Binary(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__base64Binary(struct soap *soap, xsd__base64Binary *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__base64Binary * SOAP_FMAC6 soap_instantiate_xsd__base64Binary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__base64Binary(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__base64Binary, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__base64Binary;
		if (size)
			*size = sizeof(xsd__base64Binary);
	}
	else
	{	cp->ptr = (void*)new xsd__base64Binary[n];
		if (size)
			*size = n * sizeof(xsd__base64Binary);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__base64Binary*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__base64Binary(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__base64Binary %p -> %p\n", q, p));
	*(xsd__base64Binary*)p = *(xsd__base64Binary*)q;
}

void xsd__token_::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__token_::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((xsd__token_*)this)->__item, SOAP_TYPE_xsd__token);
	soap_mark_xsd__token(soap, &((xsd__token_*)this)->__item);
	soap_embedded(soap, &((xsd__normalizedString_*)this)->__item, SOAP_TYPE_xsd__normalizedString);
	soap_mark_xsd__normalizedString(soap, &((xsd__normalizedString_*)this)->__item);
	soap_embedded(soap, &((xsd__string_*)this)->__item, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &((xsd__string_*)this)->__item);
}

void xsd__token_::soap_default(struct soap *soap)
{
	((xsd__token_*)this)->__item = NULL;
	((xsd__normalizedString_*)this)->__item = NULL;
	((xsd__string_*)this)->__item = NULL;
}

int xsd__token_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__token_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__token_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__token_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__token_(struct soap *soap, const char *tag, int id, const xsd__token_ *a, const char *type)
{
	soap_out_xsd__token(soap, tag, id, &(((xsd__token_*)a)->__item), "xsd:token");
	return SOAP_OK;
}

void *xsd__token_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__token_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__token_ * SOAP_FMAC4 soap_get_xsd__token_(struct soap *soap, xsd__token_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__token_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__token_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__token_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__token_ * SOAP_FMAC4 soap_in_xsd__token_(struct soap *soap, const char *tag, xsd__token_ *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (xsd__token_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__token_, sizeof(xsd__token_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__token_)
			return (xsd__token_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__token(soap, tag, &(((xsd__token_*)a)->__item), "xsd:token"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__token_ * SOAP_FMAC6 soap_new_xsd__token_(struct soap *soap, int n)
{	return soap_instantiate_xsd__token_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__token_(struct soap *soap, xsd__token_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__token_ * SOAP_FMAC6 soap_instantiate_xsd__token_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__token_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__token_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__token_;
		if (size)
			*size = sizeof(xsd__token_);
	}
	else
	{	cp->ptr = (void*)new xsd__token_[n];
		if (size)
			*size = n * sizeof(xsd__token_);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__token_*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__token_(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__token_ %p -> %p\n", q, p));
	*(xsd__token_*)p = *(xsd__token_*)q;
}

void xsd__normalizedString_::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__normalizedString_::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((xsd__normalizedString_*)this)->__item, SOAP_TYPE_xsd__normalizedString);
	soap_mark_xsd__normalizedString(soap, &((xsd__normalizedString_*)this)->__item);
	soap_embedded(soap, &((xsd__string_*)this)->__item, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &((xsd__string_*)this)->__item);
}

void xsd__normalizedString_::soap_default(struct soap *soap)
{
	((xsd__normalizedString_*)this)->__item = NULL;
	((xsd__string_*)this)->__item = NULL;
}

int xsd__normalizedString_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__normalizedString_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__normalizedString_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__normalizedString_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__normalizedString_(struct soap *soap, const char *tag, int id, const xsd__normalizedString_ *a, const char *type)
{
	soap_out_xsd__normalizedString(soap, tag, id, &(((xsd__normalizedString_*)a)->__item), "xsd:normalizedString");
	return SOAP_OK;
}

void *xsd__normalizedString_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__normalizedString_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__normalizedString_ * SOAP_FMAC4 soap_get_xsd__normalizedString_(struct soap *soap, xsd__normalizedString_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__normalizedString_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__normalizedString_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__normalizedString_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__normalizedString_ * SOAP_FMAC4 soap_in_xsd__normalizedString_(struct soap *soap, const char *tag, xsd__normalizedString_ *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (xsd__normalizedString_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__normalizedString_, sizeof(xsd__normalizedString_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__normalizedString_)
			return (xsd__normalizedString_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__normalizedString(soap, tag, &(((xsd__normalizedString_*)a)->__item), "xsd:normalizedString"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__normalizedString_ * SOAP_FMAC6 soap_new_xsd__normalizedString_(struct soap *soap, int n)
{	return soap_instantiate_xsd__normalizedString_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__normalizedString_(struct soap *soap, xsd__normalizedString_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__normalizedString_ * SOAP_FMAC6 soap_instantiate_xsd__normalizedString_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__normalizedString_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__normalizedString_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "xsd:token"))
	{	cp->type = SOAP_TYPE_xsd__token_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__token_;
			if (size)
				*size = sizeof(xsd__token_);
		}
		else
		{	cp->ptr = (void*)new xsd__token_[n];
			if (size)
				*size = n * sizeof(xsd__token_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__token_*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new xsd__normalizedString_;
		if (size)
			*size = sizeof(xsd__normalizedString_);
	}
	else
	{	cp->ptr = (void*)new xsd__normalizedString_[n];
		if (size)
			*size = n * sizeof(xsd__normalizedString_);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__normalizedString_*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__normalizedString_(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__normalizedString_ %p -> %p\n", q, p));
	*(xsd__normalizedString_*)p = *(xsd__normalizedString_*)q;
}

void xsd__string_::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__string_::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((xsd__string_*)this)->__item, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &((xsd__string_*)this)->__item);
}

void xsd__string_::soap_default(struct soap *soap)
{
	((xsd__string_*)this)->__item = NULL;
}

int xsd__string_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__string_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__string_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__string_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__string_(struct soap *soap, const char *tag, int id, const xsd__string_ *a, const char *type)
{
	soap_out_xsd__string(soap, tag, id, &(((xsd__string_*)a)->__item), "xsd:string");
	return SOAP_OK;
}

void *xsd__string_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__string_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__string_ * SOAP_FMAC4 soap_get_xsd__string_(struct soap *soap, xsd__string_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__string_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__string_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__string_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__string_ * SOAP_FMAC4 soap_in_xsd__string_(struct soap *soap, const char *tag, xsd__string_ *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (xsd__string_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__string_, sizeof(xsd__string_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__string_)
			return (xsd__string_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__string(soap, tag, &(((xsd__string_*)a)->__item), "xsd:string"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__string_ * SOAP_FMAC6 soap_new_xsd__string_(struct soap *soap, int n)
{	return soap_instantiate_xsd__string_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__string_(struct soap *soap, xsd__string_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__string_ * SOAP_FMAC6 soap_instantiate_xsd__string_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__string_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__string_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "xsd:normalizedString"))
	{	cp->type = SOAP_TYPE_xsd__normalizedString_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__normalizedString_;
			if (size)
				*size = sizeof(xsd__normalizedString_);
		}
		else
		{	cp->ptr = (void*)new xsd__normalizedString_[n];
			if (size)
				*size = n * sizeof(xsd__normalizedString_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__normalizedString_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:token"))
	{	cp->type = SOAP_TYPE_xsd__token_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__token_;
			if (size)
				*size = sizeof(xsd__token_);
		}
		else
		{	cp->ptr = (void*)new xsd__token_[n];
			if (size)
				*size = n * sizeof(xsd__token_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__token_*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new xsd__string_;
		if (size)
			*size = sizeof(xsd__string_);
	}
	else
	{	cp->ptr = (void*)new xsd__string_[n];
		if (size)
			*size = n * sizeof(xsd__string_);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__string_*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__string_(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__string_ %p -> %p\n", q, p));
	*(xsd__string_*)p = *(xsd__string_*)q;
}

void xsd__wstring_::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__wstring_::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((xsd__wstring_*)this)->__item, SOAP_TYPE_xsd__wstring);
	soap_mark_xsd__wstring(soap, &((xsd__wstring_*)this)->__item);
}

void xsd__wstring_::soap_default(struct soap *soap)
{
	((xsd__wstring_*)this)->__item = NULL;
}

int xsd__wstring_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__wstring_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__wstring_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__wstring_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__wstring_(struct soap *soap, const char *tag, int id, const xsd__wstring_ *a, const char *type)
{
	soap_out_xsd__wstring(soap, tag, id, &(((xsd__wstring_*)a)->__item), "xsd:wstring");
	return SOAP_OK;
}

void *xsd__wstring_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__wstring_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__wstring_ * SOAP_FMAC4 soap_get_xsd__wstring_(struct soap *soap, xsd__wstring_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__wstring_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__wstring_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__wstring_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__wstring_ * SOAP_FMAC4 soap_in_xsd__wstring_(struct soap *soap, const char *tag, xsd__wstring_ *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (xsd__wstring_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__wstring_, sizeof(xsd__wstring_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__wstring_)
			return (xsd__wstring_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__wstring(soap, tag, &(((xsd__wstring_*)a)->__item), "xsd:wstring"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__wstring_ * SOAP_FMAC6 soap_new_xsd__wstring_(struct soap *soap, int n)
{	return soap_instantiate_xsd__wstring_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__wstring_(struct soap *soap, xsd__wstring_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__wstring_ * SOAP_FMAC6 soap_instantiate_xsd__wstring_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__wstring_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__wstring_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__wstring_;
		if (size)
			*size = sizeof(xsd__wstring_);
	}
	else
	{	cp->ptr = (void*)new xsd__wstring_[n];
		if (size)
			*size = n * sizeof(xsd__wstring_);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__wstring_*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__wstring_(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__wstring_ %p -> %p\n", q, p));
	*(xsd__wstring_*)p = *(xsd__wstring_*)q;
}

void xsd__unsignedByte_::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__unsignedByte_::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((xsd__unsignedByte_*)this)->__item, SOAP_TYPE_xsd__unsignedByte);
	soap_embedded(soap, &((xsd__unsignedShort_*)this)->__item, SOAP_TYPE_xsd__unsignedShort);
	soap_embedded(soap, &((xsd__unsignedInt_*)this)->__item, SOAP_TYPE_xsd__unsignedInt);
	soap_embedded(soap, &((xsd__unsignedLong_*)this)->__item, SOAP_TYPE_xsd__unsignedLong);
	soap_embedded(soap, &((xsd__nonNegativeInteger_*)this)->__item, SOAP_TYPE_xsd__nonNegativeInteger);
	soap_mark_xsd__nonNegativeInteger(soap, &((xsd__nonNegativeInteger_*)this)->__item);
	soap_embedded(soap, &((xsd__integer_*)this)->__item, SOAP_TYPE_xsd__integer);
	soap_mark_xsd__integer(soap, &((xsd__integer_*)this)->__item);
	soap_embedded(soap, &((xsd__decimal_*)this)->__item, SOAP_TYPE_xsd__decimal);
	soap_mark_xsd__decimal(soap, &((xsd__decimal_*)this)->__item);
}

void xsd__unsignedByte_::soap_default(struct soap *soap)
{
	soap_default_xsd__unsignedByte(soap, &((xsd__unsignedByte_*)this)->__item);
	soap_default_xsd__unsignedShort(soap, &((xsd__unsignedShort_*)this)->__item);
	soap_default_xsd__unsignedInt(soap, &((xsd__unsignedInt_*)this)->__item);
	soap_default_xsd__unsignedLong(soap, &((xsd__unsignedLong_*)this)->__item);
	((xsd__nonNegativeInteger_*)this)->__item = NULL;
	((xsd__integer_*)this)->__item = NULL;
	((xsd__decimal_*)this)->__item = NULL;
}

int xsd__unsignedByte_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__unsignedByte_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__unsignedByte_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__unsignedByte_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__unsignedByte_(struct soap *soap, const char *tag, int id, const xsd__unsignedByte_ *a, const char *type)
{
	soap_out_xsd__unsignedByte(soap, tag, id, &(((xsd__unsignedByte_*)a)->__item), "xsd:unsignedByte");
	return SOAP_OK;
}

void *xsd__unsignedByte_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__unsignedByte_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__unsignedByte_ * SOAP_FMAC4 soap_get_xsd__unsignedByte_(struct soap *soap, xsd__unsignedByte_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__unsignedByte_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__unsignedByte_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__unsignedByte_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__unsignedByte_ * SOAP_FMAC4 soap_in_xsd__unsignedByte_(struct soap *soap, const char *tag, xsd__unsignedByte_ *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (xsd__unsignedByte_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__unsignedByte_, sizeof(xsd__unsignedByte_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__unsignedByte_)
			return (xsd__unsignedByte_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__unsignedByte(soap, tag, &(((xsd__unsignedByte_*)a)->__item), "xsd:unsignedByte"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__unsignedByte_ * SOAP_FMAC6 soap_new_xsd__unsignedByte_(struct soap *soap, int n)
{	return soap_instantiate_xsd__unsignedByte_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__unsignedByte_(struct soap *soap, xsd__unsignedByte_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__unsignedByte_ * SOAP_FMAC6 soap_instantiate_xsd__unsignedByte_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__unsignedByte_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__unsignedByte_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__unsignedByte_;
		if (size)
			*size = sizeof(xsd__unsignedByte_);
	}
	else
	{	cp->ptr = (void*)new xsd__unsignedByte_[n];
		if (size)
			*size = n * sizeof(xsd__unsignedByte_);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__unsignedByte_*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__unsignedByte_(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__unsignedByte_ %p -> %p\n", q, p));
	*(xsd__unsignedByte_*)p = *(xsd__unsignedByte_*)q;
}

void xsd__unsignedShort_::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__unsignedShort_::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((xsd__unsignedShort_*)this)->__item, SOAP_TYPE_xsd__unsignedShort);
	soap_embedded(soap, &((xsd__unsignedInt_*)this)->__item, SOAP_TYPE_xsd__unsignedInt);
	soap_embedded(soap, &((xsd__unsignedLong_*)this)->__item, SOAP_TYPE_xsd__unsignedLong);
	soap_embedded(soap, &((xsd__nonNegativeInteger_*)this)->__item, SOAP_TYPE_xsd__nonNegativeInteger);
	soap_mark_xsd__nonNegativeInteger(soap, &((xsd__nonNegativeInteger_*)this)->__item);
	soap_embedded(soap, &((xsd__integer_*)this)->__item, SOAP_TYPE_xsd__integer);
	soap_mark_xsd__integer(soap, &((xsd__integer_*)this)->__item);
	soap_embedded(soap, &((xsd__decimal_*)this)->__item, SOAP_TYPE_xsd__decimal);
	soap_mark_xsd__decimal(soap, &((xsd__decimal_*)this)->__item);
}

void xsd__unsignedShort_::soap_default(struct soap *soap)
{
	soap_default_xsd__unsignedShort(soap, &((xsd__unsignedShort_*)this)->__item);
	soap_default_xsd__unsignedInt(soap, &((xsd__unsignedInt_*)this)->__item);
	soap_default_xsd__unsignedLong(soap, &((xsd__unsignedLong_*)this)->__item);
	((xsd__nonNegativeInteger_*)this)->__item = NULL;
	((xsd__integer_*)this)->__item = NULL;
	((xsd__decimal_*)this)->__item = NULL;
}

int xsd__unsignedShort_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__unsignedShort_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__unsignedShort_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__unsignedShort_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__unsignedShort_(struct soap *soap, const char *tag, int id, const xsd__unsignedShort_ *a, const char *type)
{
	soap_out_xsd__unsignedShort(soap, tag, id, &(((xsd__unsignedShort_*)a)->__item), "xsd:unsignedShort");
	return SOAP_OK;
}

void *xsd__unsignedShort_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__unsignedShort_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__unsignedShort_ * SOAP_FMAC4 soap_get_xsd__unsignedShort_(struct soap *soap, xsd__unsignedShort_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__unsignedShort_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__unsignedShort_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__unsignedShort_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__unsignedShort_ * SOAP_FMAC4 soap_in_xsd__unsignedShort_(struct soap *soap, const char *tag, xsd__unsignedShort_ *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (xsd__unsignedShort_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__unsignedShort_, sizeof(xsd__unsignedShort_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__unsignedShort_)
			return (xsd__unsignedShort_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__unsignedShort(soap, tag, &(((xsd__unsignedShort_*)a)->__item), "xsd:unsignedShort"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__unsignedShort_ * SOAP_FMAC6 soap_new_xsd__unsignedShort_(struct soap *soap, int n)
{	return soap_instantiate_xsd__unsignedShort_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__unsignedShort_(struct soap *soap, xsd__unsignedShort_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__unsignedShort_ * SOAP_FMAC6 soap_instantiate_xsd__unsignedShort_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__unsignedShort_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__unsignedShort_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "xsd:unsignedByte"))
	{	cp->type = SOAP_TYPE_xsd__unsignedByte_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedByte_;
			if (size)
				*size = sizeof(xsd__unsignedByte_);
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedByte_[n];
			if (size)
				*size = n * sizeof(xsd__unsignedByte_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedByte_*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new xsd__unsignedShort_;
		if (size)
			*size = sizeof(xsd__unsignedShort_);
	}
	else
	{	cp->ptr = (void*)new xsd__unsignedShort_[n];
		if (size)
			*size = n * sizeof(xsd__unsignedShort_);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__unsignedShort_*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__unsignedShort_(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__unsignedShort_ %p -> %p\n", q, p));
	*(xsd__unsignedShort_*)p = *(xsd__unsignedShort_*)q;
}

void xsd__unsignedInt_::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__unsignedInt_::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((xsd__unsignedInt_*)this)->__item, SOAP_TYPE_xsd__unsignedInt);
	soap_embedded(soap, &((xsd__unsignedLong_*)this)->__item, SOAP_TYPE_xsd__unsignedLong);
	soap_embedded(soap, &((xsd__nonNegativeInteger_*)this)->__item, SOAP_TYPE_xsd__nonNegativeInteger);
	soap_mark_xsd__nonNegativeInteger(soap, &((xsd__nonNegativeInteger_*)this)->__item);
	soap_embedded(soap, &((xsd__integer_*)this)->__item, SOAP_TYPE_xsd__integer);
	soap_mark_xsd__integer(soap, &((xsd__integer_*)this)->__item);
	soap_embedded(soap, &((xsd__decimal_*)this)->__item, SOAP_TYPE_xsd__decimal);
	soap_mark_xsd__decimal(soap, &((xsd__decimal_*)this)->__item);
}

void xsd__unsignedInt_::soap_default(struct soap *soap)
{
	soap_default_xsd__unsignedInt(soap, &((xsd__unsignedInt_*)this)->__item);
	soap_default_xsd__unsignedLong(soap, &((xsd__unsignedLong_*)this)->__item);
	((xsd__nonNegativeInteger_*)this)->__item = NULL;
	((xsd__integer_*)this)->__item = NULL;
	((xsd__decimal_*)this)->__item = NULL;
}

int xsd__unsignedInt_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__unsignedInt_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__unsignedInt_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__unsignedInt_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__unsignedInt_(struct soap *soap, const char *tag, int id, const xsd__unsignedInt_ *a, const char *type)
{
	soap_out_xsd__unsignedInt(soap, tag, id, &(((xsd__unsignedInt_*)a)->__item), "xsd:unsignedInt");
	return SOAP_OK;
}

void *xsd__unsignedInt_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__unsignedInt_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__unsignedInt_ * SOAP_FMAC4 soap_get_xsd__unsignedInt_(struct soap *soap, xsd__unsignedInt_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__unsignedInt_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__unsignedInt_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__unsignedInt_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__unsignedInt_ * SOAP_FMAC4 soap_in_xsd__unsignedInt_(struct soap *soap, const char *tag, xsd__unsignedInt_ *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (xsd__unsignedInt_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__unsignedInt_, sizeof(xsd__unsignedInt_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__unsignedInt_)
			return (xsd__unsignedInt_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__unsignedInt(soap, tag, &(((xsd__unsignedInt_*)a)->__item), "xsd:unsignedInt"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__unsignedInt_ * SOAP_FMAC6 soap_new_xsd__unsignedInt_(struct soap *soap, int n)
{	return soap_instantiate_xsd__unsignedInt_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__unsignedInt_(struct soap *soap, xsd__unsignedInt_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__unsignedInt_ * SOAP_FMAC6 soap_instantiate_xsd__unsignedInt_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__unsignedInt_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__unsignedInt_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "xsd:unsignedShort"))
	{	cp->type = SOAP_TYPE_xsd__unsignedShort_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedShort_;
			if (size)
				*size = sizeof(xsd__unsignedShort_);
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedShort_[n];
			if (size)
				*size = n * sizeof(xsd__unsignedShort_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedShort_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:unsignedByte"))
	{	cp->type = SOAP_TYPE_xsd__unsignedByte_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedByte_;
			if (size)
				*size = sizeof(xsd__unsignedByte_);
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedByte_[n];
			if (size)
				*size = n * sizeof(xsd__unsignedByte_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedByte_*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new xsd__unsignedInt_;
		if (size)
			*size = sizeof(xsd__unsignedInt_);
	}
	else
	{	cp->ptr = (void*)new xsd__unsignedInt_[n];
		if (size)
			*size = n * sizeof(xsd__unsignedInt_);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__unsignedInt_*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__unsignedInt_(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__unsignedInt_ %p -> %p\n", q, p));
	*(xsd__unsignedInt_*)p = *(xsd__unsignedInt_*)q;
}

void xsd__unsignedLong_::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__unsignedLong_::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((xsd__unsignedLong_*)this)->__item, SOAP_TYPE_xsd__unsignedLong);
	soap_embedded(soap, &((xsd__nonNegativeInteger_*)this)->__item, SOAP_TYPE_xsd__nonNegativeInteger);
	soap_mark_xsd__nonNegativeInteger(soap, &((xsd__nonNegativeInteger_*)this)->__item);
	soap_embedded(soap, &((xsd__integer_*)this)->__item, SOAP_TYPE_xsd__integer);
	soap_mark_xsd__integer(soap, &((xsd__integer_*)this)->__item);
	soap_embedded(soap, &((xsd__decimal_*)this)->__item, SOAP_TYPE_xsd__decimal);
	soap_mark_xsd__decimal(soap, &((xsd__decimal_*)this)->__item);
}

void xsd__unsignedLong_::soap_default(struct soap *soap)
{
	soap_default_xsd__unsignedLong(soap, &((xsd__unsignedLong_*)this)->__item);
	((xsd__nonNegativeInteger_*)this)->__item = NULL;
	((xsd__integer_*)this)->__item = NULL;
	((xsd__decimal_*)this)->__item = NULL;
}

int xsd__unsignedLong_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__unsignedLong_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__unsignedLong_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__unsignedLong_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__unsignedLong_(struct soap *soap, const char *tag, int id, const xsd__unsignedLong_ *a, const char *type)
{
	soap_out_xsd__unsignedLong(soap, tag, id, &(((xsd__unsignedLong_*)a)->__item), "xsd:unsignedLong");
	return SOAP_OK;
}

void *xsd__unsignedLong_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__unsignedLong_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__unsignedLong_ * SOAP_FMAC4 soap_get_xsd__unsignedLong_(struct soap *soap, xsd__unsignedLong_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__unsignedLong_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__unsignedLong_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__unsignedLong_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__unsignedLong_ * SOAP_FMAC4 soap_in_xsd__unsignedLong_(struct soap *soap, const char *tag, xsd__unsignedLong_ *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (xsd__unsignedLong_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__unsignedLong_, sizeof(xsd__unsignedLong_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__unsignedLong_)
			return (xsd__unsignedLong_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__unsignedLong(soap, tag, &(((xsd__unsignedLong_*)a)->__item), "xsd:unsignedLong"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__unsignedLong_ * SOAP_FMAC6 soap_new_xsd__unsignedLong_(struct soap *soap, int n)
{	return soap_instantiate_xsd__unsignedLong_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__unsignedLong_(struct soap *soap, xsd__unsignedLong_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__unsignedLong_ * SOAP_FMAC6 soap_instantiate_xsd__unsignedLong_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__unsignedLong_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__unsignedLong_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "xsd:unsignedInt"))
	{	cp->type = SOAP_TYPE_xsd__unsignedInt_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedInt_;
			if (size)
				*size = sizeof(xsd__unsignedInt_);
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedInt_[n];
			if (size)
				*size = n * sizeof(xsd__unsignedInt_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedInt_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:unsignedShort"))
	{	cp->type = SOAP_TYPE_xsd__unsignedShort_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedShort_;
			if (size)
				*size = sizeof(xsd__unsignedShort_);
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedShort_[n];
			if (size)
				*size = n * sizeof(xsd__unsignedShort_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedShort_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:unsignedByte"))
	{	cp->type = SOAP_TYPE_xsd__unsignedByte_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedByte_;
			if (size)
				*size = sizeof(xsd__unsignedByte_);
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedByte_[n];
			if (size)
				*size = n * sizeof(xsd__unsignedByte_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedByte_*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new xsd__unsignedLong_;
		if (size)
			*size = sizeof(xsd__unsignedLong_);
	}
	else
	{	cp->ptr = (void*)new xsd__unsignedLong_[n];
		if (size)
			*size = n * sizeof(xsd__unsignedLong_);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__unsignedLong_*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__unsignedLong_(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__unsignedLong_ %p -> %p\n", q, p));
	*(xsd__unsignedLong_*)p = *(xsd__unsignedLong_*)q;
}

void xsd__positiveInteger_::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__positiveInteger_::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((xsd__positiveInteger_*)this)->__item, SOAP_TYPE_xsd__positiveInteger);
	soap_mark_xsd__positiveInteger(soap, &((xsd__positiveInteger_*)this)->__item);
	soap_embedded(soap, &((xsd__nonNegativeInteger_*)this)->__item, SOAP_TYPE_xsd__nonNegativeInteger);
	soap_mark_xsd__nonNegativeInteger(soap, &((xsd__nonNegativeInteger_*)this)->__item);
	soap_embedded(soap, &((xsd__integer_*)this)->__item, SOAP_TYPE_xsd__integer);
	soap_mark_xsd__integer(soap, &((xsd__integer_*)this)->__item);
	soap_embedded(soap, &((xsd__decimal_*)this)->__item, SOAP_TYPE_xsd__decimal);
	soap_mark_xsd__decimal(soap, &((xsd__decimal_*)this)->__item);
}

void xsd__positiveInteger_::soap_default(struct soap *soap)
{
	((xsd__positiveInteger_*)this)->__item = NULL;
	((xsd__nonNegativeInteger_*)this)->__item = NULL;
	((xsd__integer_*)this)->__item = NULL;
	((xsd__decimal_*)this)->__item = NULL;
}

int xsd__positiveInteger_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__positiveInteger_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__positiveInteger_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__positiveInteger_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__positiveInteger_(struct soap *soap, const char *tag, int id, const xsd__positiveInteger_ *a, const char *type)
{
	soap_out_xsd__positiveInteger(soap, tag, id, &(((xsd__positiveInteger_*)a)->__item), "xsd:positiveInteger");
	return SOAP_OK;
}

void *xsd__positiveInteger_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__positiveInteger_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__positiveInteger_ * SOAP_FMAC4 soap_get_xsd__positiveInteger_(struct soap *soap, xsd__positiveInteger_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__positiveInteger_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__positiveInteger_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__positiveInteger_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__positiveInteger_ * SOAP_FMAC4 soap_in_xsd__positiveInteger_(struct soap *soap, const char *tag, xsd__positiveInteger_ *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (xsd__positiveInteger_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__positiveInteger_, sizeof(xsd__positiveInteger_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__positiveInteger_)
			return (xsd__positiveInteger_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__positiveInteger(soap, tag, &(((xsd__positiveInteger_*)a)->__item), "xsd:positiveInteger"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__positiveInteger_ * SOAP_FMAC6 soap_new_xsd__positiveInteger_(struct soap *soap, int n)
{	return soap_instantiate_xsd__positiveInteger_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__positiveInteger_(struct soap *soap, xsd__positiveInteger_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__positiveInteger_ * SOAP_FMAC6 soap_instantiate_xsd__positiveInteger_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__positiveInteger_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__positiveInteger_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__positiveInteger_;
		if (size)
			*size = sizeof(xsd__positiveInteger_);
	}
	else
	{	cp->ptr = (void*)new xsd__positiveInteger_[n];
		if (size)
			*size = n * sizeof(xsd__positiveInteger_);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__positiveInteger_*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__positiveInteger_(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__positiveInteger_ %p -> %p\n", q, p));
	*(xsd__positiveInteger_*)p = *(xsd__positiveInteger_*)q;
}

void xsd__nonNegativeInteger_::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__nonNegativeInteger_::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((xsd__nonNegativeInteger_*)this)->__item, SOAP_TYPE_xsd__nonNegativeInteger);
	soap_mark_xsd__nonNegativeInteger(soap, &((xsd__nonNegativeInteger_*)this)->__item);
	soap_embedded(soap, &((xsd__integer_*)this)->__item, SOAP_TYPE_xsd__integer);
	soap_mark_xsd__integer(soap, &((xsd__integer_*)this)->__item);
	soap_embedded(soap, &((xsd__decimal_*)this)->__item, SOAP_TYPE_xsd__decimal);
	soap_mark_xsd__decimal(soap, &((xsd__decimal_*)this)->__item);
}

void xsd__nonNegativeInteger_::soap_default(struct soap *soap)
{
	((xsd__nonNegativeInteger_*)this)->__item = NULL;
	((xsd__integer_*)this)->__item = NULL;
	((xsd__decimal_*)this)->__item = NULL;
}

int xsd__nonNegativeInteger_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__nonNegativeInteger_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__nonNegativeInteger_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__nonNegativeInteger_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__nonNegativeInteger_(struct soap *soap, const char *tag, int id, const xsd__nonNegativeInteger_ *a, const char *type)
{
	soap_out_xsd__nonNegativeInteger(soap, tag, id, &(((xsd__nonNegativeInteger_*)a)->__item), "xsd:nonNegativeInteger");
	return SOAP_OK;
}

void *xsd__nonNegativeInteger_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__nonNegativeInteger_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__nonNegativeInteger_ * SOAP_FMAC4 soap_get_xsd__nonNegativeInteger_(struct soap *soap, xsd__nonNegativeInteger_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__nonNegativeInteger_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__nonNegativeInteger_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__nonNegativeInteger_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__nonNegativeInteger_ * SOAP_FMAC4 soap_in_xsd__nonNegativeInteger_(struct soap *soap, const char *tag, xsd__nonNegativeInteger_ *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (xsd__nonNegativeInteger_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__nonNegativeInteger_, sizeof(xsd__nonNegativeInteger_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__nonNegativeInteger_)
			return (xsd__nonNegativeInteger_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__nonNegativeInteger(soap, tag, &(((xsd__nonNegativeInteger_*)a)->__item), "xsd:nonNegativeInteger"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__nonNegativeInteger_ * SOAP_FMAC6 soap_new_xsd__nonNegativeInteger_(struct soap *soap, int n)
{	return soap_instantiate_xsd__nonNegativeInteger_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__nonNegativeInteger_(struct soap *soap, xsd__nonNegativeInteger_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__nonNegativeInteger_ * SOAP_FMAC6 soap_instantiate_xsd__nonNegativeInteger_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__nonNegativeInteger_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__nonNegativeInteger_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "xsd:positiveInteger"))
	{	cp->type = SOAP_TYPE_xsd__positiveInteger_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__positiveInteger_;
			if (size)
				*size = sizeof(xsd__positiveInteger_);
		}
		else
		{	cp->ptr = (void*)new xsd__positiveInteger_[n];
			if (size)
				*size = n * sizeof(xsd__positiveInteger_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__positiveInteger_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:unsignedLong"))
	{	cp->type = SOAP_TYPE_xsd__unsignedLong_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedLong_;
			if (size)
				*size = sizeof(xsd__unsignedLong_);
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedLong_[n];
			if (size)
				*size = n * sizeof(xsd__unsignedLong_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedLong_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:unsignedInt"))
	{	cp->type = SOAP_TYPE_xsd__unsignedInt_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedInt_;
			if (size)
				*size = sizeof(xsd__unsignedInt_);
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedInt_[n];
			if (size)
				*size = n * sizeof(xsd__unsignedInt_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedInt_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:unsignedShort"))
	{	cp->type = SOAP_TYPE_xsd__unsignedShort_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedShort_;
			if (size)
				*size = sizeof(xsd__unsignedShort_);
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedShort_[n];
			if (size)
				*size = n * sizeof(xsd__unsignedShort_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedShort_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:unsignedByte"))
	{	cp->type = SOAP_TYPE_xsd__unsignedByte_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedByte_;
			if (size)
				*size = sizeof(xsd__unsignedByte_);
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedByte_[n];
			if (size)
				*size = n * sizeof(xsd__unsignedByte_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedByte_*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new xsd__nonNegativeInteger_;
		if (size)
			*size = sizeof(xsd__nonNegativeInteger_);
	}
	else
	{	cp->ptr = (void*)new xsd__nonNegativeInteger_[n];
		if (size)
			*size = n * sizeof(xsd__nonNegativeInteger_);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__nonNegativeInteger_*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__nonNegativeInteger_(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__nonNegativeInteger_ %p -> %p\n", q, p));
	*(xsd__nonNegativeInteger_*)p = *(xsd__nonNegativeInteger_*)q;
}

void xsd__negativeInteger_::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__negativeInteger_::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((xsd__negativeInteger_*)this)->__item, SOAP_TYPE_xsd__negativeInteger);
	soap_mark_xsd__negativeInteger(soap, &((xsd__negativeInteger_*)this)->__item);
	soap_embedded(soap, &((xsd__nonPositiveInteger_*)this)->__item, SOAP_TYPE_xsd__nonPositiveInteger);
	soap_mark_xsd__nonPositiveInteger(soap, &((xsd__nonPositiveInteger_*)this)->__item);
	soap_embedded(soap, &((xsd__integer_*)this)->__item, SOAP_TYPE_xsd__integer);
	soap_mark_xsd__integer(soap, &((xsd__integer_*)this)->__item);
	soap_embedded(soap, &((xsd__decimal_*)this)->__item, SOAP_TYPE_xsd__decimal);
	soap_mark_xsd__decimal(soap, &((xsd__decimal_*)this)->__item);
}

void xsd__negativeInteger_::soap_default(struct soap *soap)
{
	((xsd__negativeInteger_*)this)->__item = NULL;
	((xsd__nonPositiveInteger_*)this)->__item = NULL;
	((xsd__integer_*)this)->__item = NULL;
	((xsd__decimal_*)this)->__item = NULL;
}

int xsd__negativeInteger_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__negativeInteger_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__negativeInteger_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__negativeInteger_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__negativeInteger_(struct soap *soap, const char *tag, int id, const xsd__negativeInteger_ *a, const char *type)
{
	soap_out_xsd__negativeInteger(soap, tag, id, &(((xsd__negativeInteger_*)a)->__item), "xsd:negativeInteger");
	return SOAP_OK;
}

void *xsd__negativeInteger_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__negativeInteger_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__negativeInteger_ * SOAP_FMAC4 soap_get_xsd__negativeInteger_(struct soap *soap, xsd__negativeInteger_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__negativeInteger_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__negativeInteger_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__negativeInteger_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__negativeInteger_ * SOAP_FMAC4 soap_in_xsd__negativeInteger_(struct soap *soap, const char *tag, xsd__negativeInteger_ *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (xsd__negativeInteger_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__negativeInteger_, sizeof(xsd__negativeInteger_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__negativeInteger_)
			return (xsd__negativeInteger_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__negativeInteger(soap, tag, &(((xsd__negativeInteger_*)a)->__item), "xsd:negativeInteger"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__negativeInteger_ * SOAP_FMAC6 soap_new_xsd__negativeInteger_(struct soap *soap, int n)
{	return soap_instantiate_xsd__negativeInteger_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__negativeInteger_(struct soap *soap, xsd__negativeInteger_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__negativeInteger_ * SOAP_FMAC6 soap_instantiate_xsd__negativeInteger_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__negativeInteger_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__negativeInteger_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__negativeInteger_;
		if (size)
			*size = sizeof(xsd__negativeInteger_);
	}
	else
	{	cp->ptr = (void*)new xsd__negativeInteger_[n];
		if (size)
			*size = n * sizeof(xsd__negativeInteger_);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__negativeInteger_*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__negativeInteger_(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__negativeInteger_ %p -> %p\n", q, p));
	*(xsd__negativeInteger_*)p = *(xsd__negativeInteger_*)q;
}

void xsd__nonPositiveInteger_::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__nonPositiveInteger_::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((xsd__nonPositiveInteger_*)this)->__item, SOAP_TYPE_xsd__nonPositiveInteger);
	soap_mark_xsd__nonPositiveInteger(soap, &((xsd__nonPositiveInteger_*)this)->__item);
	soap_embedded(soap, &((xsd__integer_*)this)->__item, SOAP_TYPE_xsd__integer);
	soap_mark_xsd__integer(soap, &((xsd__integer_*)this)->__item);
	soap_embedded(soap, &((xsd__decimal_*)this)->__item, SOAP_TYPE_xsd__decimal);
	soap_mark_xsd__decimal(soap, &((xsd__decimal_*)this)->__item);
}

void xsd__nonPositiveInteger_::soap_default(struct soap *soap)
{
	((xsd__nonPositiveInteger_*)this)->__item = NULL;
	((xsd__integer_*)this)->__item = NULL;
	((xsd__decimal_*)this)->__item = NULL;
}

int xsd__nonPositiveInteger_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__nonPositiveInteger_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__nonPositiveInteger_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__nonPositiveInteger_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__nonPositiveInteger_(struct soap *soap, const char *tag, int id, const xsd__nonPositiveInteger_ *a, const char *type)
{
	soap_out_xsd__nonPositiveInteger(soap, tag, id, &(((xsd__nonPositiveInteger_*)a)->__item), "xsd:nonPositiveInteger");
	return SOAP_OK;
}

void *xsd__nonPositiveInteger_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__nonPositiveInteger_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__nonPositiveInteger_ * SOAP_FMAC4 soap_get_xsd__nonPositiveInteger_(struct soap *soap, xsd__nonPositiveInteger_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__nonPositiveInteger_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__nonPositiveInteger_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__nonPositiveInteger_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__nonPositiveInteger_ * SOAP_FMAC4 soap_in_xsd__nonPositiveInteger_(struct soap *soap, const char *tag, xsd__nonPositiveInteger_ *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (xsd__nonPositiveInteger_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__nonPositiveInteger_, sizeof(xsd__nonPositiveInteger_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__nonPositiveInteger_)
			return (xsd__nonPositiveInteger_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__nonPositiveInteger(soap, tag, &(((xsd__nonPositiveInteger_*)a)->__item), "xsd:nonPositiveInteger"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__nonPositiveInteger_ * SOAP_FMAC6 soap_new_xsd__nonPositiveInteger_(struct soap *soap, int n)
{	return soap_instantiate_xsd__nonPositiveInteger_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__nonPositiveInteger_(struct soap *soap, xsd__nonPositiveInteger_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__nonPositiveInteger_ * SOAP_FMAC6 soap_instantiate_xsd__nonPositiveInteger_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__nonPositiveInteger_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__nonPositiveInteger_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "xsd:negativeInteger"))
	{	cp->type = SOAP_TYPE_xsd__negativeInteger_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__negativeInteger_;
			if (size)
				*size = sizeof(xsd__negativeInteger_);
		}
		else
		{	cp->ptr = (void*)new xsd__negativeInteger_[n];
			if (size)
				*size = n * sizeof(xsd__negativeInteger_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__negativeInteger_*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new xsd__nonPositiveInteger_;
		if (size)
			*size = sizeof(xsd__nonPositiveInteger_);
	}
	else
	{	cp->ptr = (void*)new xsd__nonPositiveInteger_[n];
		if (size)
			*size = n * sizeof(xsd__nonPositiveInteger_);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__nonPositiveInteger_*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__nonPositiveInteger_(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__nonPositiveInteger_ %p -> %p\n", q, p));
	*(xsd__nonPositiveInteger_*)p = *(xsd__nonPositiveInteger_*)q;
}

void xsd__byte_::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__byte_::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((xsd__byte_*)this)->__item, SOAP_TYPE_xsd__byte);
	soap_embedded(soap, &((xsd__short_*)this)->__item, SOAP_TYPE_xsd__short);
	soap_embedded(soap, &((xsd__int_*)this)->__item, SOAP_TYPE_xsd__int);
	soap_embedded(soap, &((xsd__long_*)this)->__item, SOAP_TYPE_xsd__long);
	soap_embedded(soap, &((xsd__integer_*)this)->__item, SOAP_TYPE_xsd__integer);
	soap_mark_xsd__integer(soap, &((xsd__integer_*)this)->__item);
	soap_embedded(soap, &((xsd__decimal_*)this)->__item, SOAP_TYPE_xsd__decimal);
	soap_mark_xsd__decimal(soap, &((xsd__decimal_*)this)->__item);
}

void xsd__byte_::soap_default(struct soap *soap)
{
	soap_default_xsd__byte(soap, &((xsd__byte_*)this)->__item);
	soap_default_xsd__short(soap, &((xsd__short_*)this)->__item);
	soap_default_xsd__int(soap, &((xsd__int_*)this)->__item);
	soap_default_xsd__long(soap, &((xsd__long_*)this)->__item);
	((xsd__integer_*)this)->__item = NULL;
	((xsd__decimal_*)this)->__item = NULL;
}

int xsd__byte_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__byte_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__byte_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__byte_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__byte_(struct soap *soap, const char *tag, int id, const xsd__byte_ *a, const char *type)
{
	soap_out_xsd__byte(soap, tag, id, &(((xsd__byte_*)a)->__item), "xsd:byte");
	return SOAP_OK;
}

void *xsd__byte_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__byte_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__byte_ * SOAP_FMAC4 soap_get_xsd__byte_(struct soap *soap, xsd__byte_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__byte_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__byte_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__byte_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__byte_ * SOAP_FMAC4 soap_in_xsd__byte_(struct soap *soap, const char *tag, xsd__byte_ *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (xsd__byte_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__byte_, sizeof(xsd__byte_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__byte_)
			return (xsd__byte_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__byte(soap, tag, &(((xsd__byte_*)a)->__item), "xsd:byte"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__byte_ * SOAP_FMAC6 soap_new_xsd__byte_(struct soap *soap, int n)
{	return soap_instantiate_xsd__byte_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__byte_(struct soap *soap, xsd__byte_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__byte_ * SOAP_FMAC6 soap_instantiate_xsd__byte_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__byte_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__byte_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__byte_;
		if (size)
			*size = sizeof(xsd__byte_);
	}
	else
	{	cp->ptr = (void*)new xsd__byte_[n];
		if (size)
			*size = n * sizeof(xsd__byte_);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__byte_*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__byte_(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__byte_ %p -> %p\n", q, p));
	*(xsd__byte_*)p = *(xsd__byte_*)q;
}

void xsd__short_::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__short_::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((xsd__short_*)this)->__item, SOAP_TYPE_xsd__short);
	soap_embedded(soap, &((xsd__int_*)this)->__item, SOAP_TYPE_xsd__int);
	soap_embedded(soap, &((xsd__long_*)this)->__item, SOAP_TYPE_xsd__long);
	soap_embedded(soap, &((xsd__integer_*)this)->__item, SOAP_TYPE_xsd__integer);
	soap_mark_xsd__integer(soap, &((xsd__integer_*)this)->__item);
	soap_embedded(soap, &((xsd__decimal_*)this)->__item, SOAP_TYPE_xsd__decimal);
	soap_mark_xsd__decimal(soap, &((xsd__decimal_*)this)->__item);
}

void xsd__short_::soap_default(struct soap *soap)
{
	soap_default_xsd__short(soap, &((xsd__short_*)this)->__item);
	soap_default_xsd__int(soap, &((xsd__int_*)this)->__item);
	soap_default_xsd__long(soap, &((xsd__long_*)this)->__item);
	((xsd__integer_*)this)->__item = NULL;
	((xsd__decimal_*)this)->__item = NULL;
}

int xsd__short_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__short_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__short_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__short_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__short_(struct soap *soap, const char *tag, int id, const xsd__short_ *a, const char *type)
{
	soap_out_xsd__short(soap, tag, id, &(((xsd__short_*)a)->__item), "xsd:short");
	return SOAP_OK;
}

void *xsd__short_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__short_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__short_ * SOAP_FMAC4 soap_get_xsd__short_(struct soap *soap, xsd__short_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__short_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__short_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__short_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__short_ * SOAP_FMAC4 soap_in_xsd__short_(struct soap *soap, const char *tag, xsd__short_ *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (xsd__short_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__short_, sizeof(xsd__short_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__short_)
			return (xsd__short_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__short(soap, tag, &(((xsd__short_*)a)->__item), "xsd:short"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__short_ * SOAP_FMAC6 soap_new_xsd__short_(struct soap *soap, int n)
{	return soap_instantiate_xsd__short_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__short_(struct soap *soap, xsd__short_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__short_ * SOAP_FMAC6 soap_instantiate_xsd__short_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__short_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__short_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "xsd:byte"))
	{	cp->type = SOAP_TYPE_xsd__byte_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__byte_;
			if (size)
				*size = sizeof(xsd__byte_);
		}
		else
		{	cp->ptr = (void*)new xsd__byte_[n];
			if (size)
				*size = n * sizeof(xsd__byte_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__byte_*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new xsd__short_;
		if (size)
			*size = sizeof(xsd__short_);
	}
	else
	{	cp->ptr = (void*)new xsd__short_[n];
		if (size)
			*size = n * sizeof(xsd__short_);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__short_*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__short_(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__short_ %p -> %p\n", q, p));
	*(xsd__short_*)p = *(xsd__short_*)q;
}

void xsd__int_::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__int_::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((xsd__int_*)this)->__item, SOAP_TYPE_xsd__int);
	soap_embedded(soap, &((xsd__long_*)this)->__item, SOAP_TYPE_xsd__long);
	soap_embedded(soap, &((xsd__integer_*)this)->__item, SOAP_TYPE_xsd__integer);
	soap_mark_xsd__integer(soap, &((xsd__integer_*)this)->__item);
	soap_embedded(soap, &((xsd__decimal_*)this)->__item, SOAP_TYPE_xsd__decimal);
	soap_mark_xsd__decimal(soap, &((xsd__decimal_*)this)->__item);
}

void xsd__int_::soap_default(struct soap *soap)
{
	soap_default_xsd__int(soap, &((xsd__int_*)this)->__item);
	soap_default_xsd__long(soap, &((xsd__long_*)this)->__item);
	((xsd__integer_*)this)->__item = NULL;
	((xsd__decimal_*)this)->__item = NULL;
}

int xsd__int_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__int_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__int_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__int_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__int_(struct soap *soap, const char *tag, int id, const xsd__int_ *a, const char *type)
{
	soap_out_xsd__int(soap, tag, id, &(((xsd__int_*)a)->__item), "xsd:int");
	return SOAP_OK;
}

void *xsd__int_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__int_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__int_ * SOAP_FMAC4 soap_get_xsd__int_(struct soap *soap, xsd__int_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__int_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__int_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__int_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__int_ * SOAP_FMAC4 soap_in_xsd__int_(struct soap *soap, const char *tag, xsd__int_ *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (xsd__int_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__int_, sizeof(xsd__int_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__int_)
			return (xsd__int_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__int(soap, tag, &(((xsd__int_*)a)->__item), "xsd:int"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__int_ * SOAP_FMAC6 soap_new_xsd__int_(struct soap *soap, int n)
{	return soap_instantiate_xsd__int_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__int_(struct soap *soap, xsd__int_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__int_ * SOAP_FMAC6 soap_instantiate_xsd__int_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__int_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__int_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "xsd:short"))
	{	cp->type = SOAP_TYPE_xsd__short_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__short_;
			if (size)
				*size = sizeof(xsd__short_);
		}
		else
		{	cp->ptr = (void*)new xsd__short_[n];
			if (size)
				*size = n * sizeof(xsd__short_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__short_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:byte"))
	{	cp->type = SOAP_TYPE_xsd__byte_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__byte_;
			if (size)
				*size = sizeof(xsd__byte_);
		}
		else
		{	cp->ptr = (void*)new xsd__byte_[n];
			if (size)
				*size = n * sizeof(xsd__byte_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__byte_*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new xsd__int_;
		if (size)
			*size = sizeof(xsd__int_);
	}
	else
	{	cp->ptr = (void*)new xsd__int_[n];
		if (size)
			*size = n * sizeof(xsd__int_);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__int_*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__int_(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__int_ %p -> %p\n", q, p));
	*(xsd__int_*)p = *(xsd__int_*)q;
}

void xsd__long_::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__long_::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((xsd__long_*)this)->__item, SOAP_TYPE_xsd__long);
	soap_embedded(soap, &((xsd__integer_*)this)->__item, SOAP_TYPE_xsd__integer);
	soap_mark_xsd__integer(soap, &((xsd__integer_*)this)->__item);
	soap_embedded(soap, &((xsd__decimal_*)this)->__item, SOAP_TYPE_xsd__decimal);
	soap_mark_xsd__decimal(soap, &((xsd__decimal_*)this)->__item);
}

void xsd__long_::soap_default(struct soap *soap)
{
	soap_default_xsd__long(soap, &((xsd__long_*)this)->__item);
	((xsd__integer_*)this)->__item = NULL;
	((xsd__decimal_*)this)->__item = NULL;
}

int xsd__long_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__long_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__long_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__long_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__long_(struct soap *soap, const char *tag, int id, const xsd__long_ *a, const char *type)
{
	soap_out_xsd__long(soap, tag, id, &(((xsd__long_*)a)->__item), "xsd:long");
	return SOAP_OK;
}

void *xsd__long_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__long_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__long_ * SOAP_FMAC4 soap_get_xsd__long_(struct soap *soap, xsd__long_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__long_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__long_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__long_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__long_ * SOAP_FMAC4 soap_in_xsd__long_(struct soap *soap, const char *tag, xsd__long_ *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (xsd__long_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__long_, sizeof(xsd__long_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__long_)
			return (xsd__long_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__long(soap, tag, &(((xsd__long_*)a)->__item), "xsd:long"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__long_ * SOAP_FMAC6 soap_new_xsd__long_(struct soap *soap, int n)
{	return soap_instantiate_xsd__long_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__long_(struct soap *soap, xsd__long_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__long_ * SOAP_FMAC6 soap_instantiate_xsd__long_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__long_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__long_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "xsd:int"))
	{	cp->type = SOAP_TYPE_xsd__int_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__int_;
			if (size)
				*size = sizeof(xsd__int_);
		}
		else
		{	cp->ptr = (void*)new xsd__int_[n];
			if (size)
				*size = n * sizeof(xsd__int_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__int_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:short"))
	{	cp->type = SOAP_TYPE_xsd__short_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__short_;
			if (size)
				*size = sizeof(xsd__short_);
		}
		else
		{	cp->ptr = (void*)new xsd__short_[n];
			if (size)
				*size = n * sizeof(xsd__short_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__short_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:byte"))
	{	cp->type = SOAP_TYPE_xsd__byte_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__byte_;
			if (size)
				*size = sizeof(xsd__byte_);
		}
		else
		{	cp->ptr = (void*)new xsd__byte_[n];
			if (size)
				*size = n * sizeof(xsd__byte_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__byte_*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new xsd__long_;
		if (size)
			*size = sizeof(xsd__long_);
	}
	else
	{	cp->ptr = (void*)new xsd__long_[n];
		if (size)
			*size = n * sizeof(xsd__long_);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__long_*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__long_(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__long_ %p -> %p\n", q, p));
	*(xsd__long_*)p = *(xsd__long_*)q;
}

void xsd__integer_::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__integer_::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((xsd__integer_*)this)->__item, SOAP_TYPE_xsd__integer);
	soap_mark_xsd__integer(soap, &((xsd__integer_*)this)->__item);
	soap_embedded(soap, &((xsd__decimal_*)this)->__item, SOAP_TYPE_xsd__decimal);
	soap_mark_xsd__decimal(soap, &((xsd__decimal_*)this)->__item);
}

void xsd__integer_::soap_default(struct soap *soap)
{
	((xsd__integer_*)this)->__item = NULL;
	((xsd__decimal_*)this)->__item = NULL;
}

int xsd__integer_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__integer_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__integer_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__integer_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__integer_(struct soap *soap, const char *tag, int id, const xsd__integer_ *a, const char *type)
{
	soap_out_xsd__integer(soap, tag, id, &(((xsd__integer_*)a)->__item), "xsd:integer");
	return SOAP_OK;
}

void *xsd__integer_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__integer_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__integer_ * SOAP_FMAC4 soap_get_xsd__integer_(struct soap *soap, xsd__integer_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__integer_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__integer_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__integer_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__integer_ * SOAP_FMAC4 soap_in_xsd__integer_(struct soap *soap, const char *tag, xsd__integer_ *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (xsd__integer_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__integer_, sizeof(xsd__integer_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__integer_)
			return (xsd__integer_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__integer(soap, tag, &(((xsd__integer_*)a)->__item), "xsd:integer"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__integer_ * SOAP_FMAC6 soap_new_xsd__integer_(struct soap *soap, int n)
{	return soap_instantiate_xsd__integer_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__integer_(struct soap *soap, xsd__integer_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__integer_ * SOAP_FMAC6 soap_instantiate_xsd__integer_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__integer_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__integer_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "xsd:long"))
	{	cp->type = SOAP_TYPE_xsd__long_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__long_;
			if (size)
				*size = sizeof(xsd__long_);
		}
		else
		{	cp->ptr = (void*)new xsd__long_[n];
			if (size)
				*size = n * sizeof(xsd__long_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__long_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:int"))
	{	cp->type = SOAP_TYPE_xsd__int_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__int_;
			if (size)
				*size = sizeof(xsd__int_);
		}
		else
		{	cp->ptr = (void*)new xsd__int_[n];
			if (size)
				*size = n * sizeof(xsd__int_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__int_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:short"))
	{	cp->type = SOAP_TYPE_xsd__short_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__short_;
			if (size)
				*size = sizeof(xsd__short_);
		}
		else
		{	cp->ptr = (void*)new xsd__short_[n];
			if (size)
				*size = n * sizeof(xsd__short_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__short_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:byte"))
	{	cp->type = SOAP_TYPE_xsd__byte_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__byte_;
			if (size)
				*size = sizeof(xsd__byte_);
		}
		else
		{	cp->ptr = (void*)new xsd__byte_[n];
			if (size)
				*size = n * sizeof(xsd__byte_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__byte_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:nonPositiveInteger"))
	{	cp->type = SOAP_TYPE_xsd__nonPositiveInteger_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__nonPositiveInteger_;
			if (size)
				*size = sizeof(xsd__nonPositiveInteger_);
		}
		else
		{	cp->ptr = (void*)new xsd__nonPositiveInteger_[n];
			if (size)
				*size = n * sizeof(xsd__nonPositiveInteger_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__nonPositiveInteger_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:negativeInteger"))
	{	cp->type = SOAP_TYPE_xsd__negativeInteger_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__negativeInteger_;
			if (size)
				*size = sizeof(xsd__negativeInteger_);
		}
		else
		{	cp->ptr = (void*)new xsd__negativeInteger_[n];
			if (size)
				*size = n * sizeof(xsd__negativeInteger_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__negativeInteger_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:nonNegativeInteger"))
	{	cp->type = SOAP_TYPE_xsd__nonNegativeInteger_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__nonNegativeInteger_;
			if (size)
				*size = sizeof(xsd__nonNegativeInteger_);
		}
		else
		{	cp->ptr = (void*)new xsd__nonNegativeInteger_[n];
			if (size)
				*size = n * sizeof(xsd__nonNegativeInteger_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__nonNegativeInteger_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:positiveInteger"))
	{	cp->type = SOAP_TYPE_xsd__positiveInteger_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__positiveInteger_;
			if (size)
				*size = sizeof(xsd__positiveInteger_);
		}
		else
		{	cp->ptr = (void*)new xsd__positiveInteger_[n];
			if (size)
				*size = n * sizeof(xsd__positiveInteger_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__positiveInteger_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:unsignedLong"))
	{	cp->type = SOAP_TYPE_xsd__unsignedLong_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedLong_;
			if (size)
				*size = sizeof(xsd__unsignedLong_);
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedLong_[n];
			if (size)
				*size = n * sizeof(xsd__unsignedLong_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedLong_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:unsignedInt"))
	{	cp->type = SOAP_TYPE_xsd__unsignedInt_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedInt_;
			if (size)
				*size = sizeof(xsd__unsignedInt_);
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedInt_[n];
			if (size)
				*size = n * sizeof(xsd__unsignedInt_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedInt_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:unsignedShort"))
	{	cp->type = SOAP_TYPE_xsd__unsignedShort_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedShort_;
			if (size)
				*size = sizeof(xsd__unsignedShort_);
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedShort_[n];
			if (size)
				*size = n * sizeof(xsd__unsignedShort_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedShort_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:unsignedByte"))
	{	cp->type = SOAP_TYPE_xsd__unsignedByte_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedByte_;
			if (size)
				*size = sizeof(xsd__unsignedByte_);
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedByte_[n];
			if (size)
				*size = n * sizeof(xsd__unsignedByte_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedByte_*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new xsd__integer_;
		if (size)
			*size = sizeof(xsd__integer_);
	}
	else
	{	cp->ptr = (void*)new xsd__integer_[n];
		if (size)
			*size = n * sizeof(xsd__integer_);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__integer_*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__integer_(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__integer_ %p -> %p\n", q, p));
	*(xsd__integer_*)p = *(xsd__integer_*)q;
}

void xsd__decimal_::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__decimal_::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((xsd__decimal_*)this)->__item, SOAP_TYPE_xsd__decimal);
	soap_mark_xsd__decimal(soap, &((xsd__decimal_*)this)->__item);
}

void xsd__decimal_::soap_default(struct soap *soap)
{
	((xsd__decimal_*)this)->__item = NULL;
}

int xsd__decimal_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__decimal_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__decimal_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__decimal_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__decimal_(struct soap *soap, const char *tag, int id, const xsd__decimal_ *a, const char *type)
{
	soap_out_xsd__decimal(soap, tag, id, &(((xsd__decimal_*)a)->__item), "xsd:decimal");
	return SOAP_OK;
}

void *xsd__decimal_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__decimal_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__decimal_ * SOAP_FMAC4 soap_get_xsd__decimal_(struct soap *soap, xsd__decimal_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__decimal_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__decimal_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__decimal_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__decimal_ * SOAP_FMAC4 soap_in_xsd__decimal_(struct soap *soap, const char *tag, xsd__decimal_ *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (xsd__decimal_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__decimal_, sizeof(xsd__decimal_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__decimal_)
			return (xsd__decimal_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__decimal(soap, tag, &(((xsd__decimal_*)a)->__item), "xsd:decimal"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__decimal_ * SOAP_FMAC6 soap_new_xsd__decimal_(struct soap *soap, int n)
{	return soap_instantiate_xsd__decimal_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__decimal_(struct soap *soap, xsd__decimal_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__decimal_ * SOAP_FMAC6 soap_instantiate_xsd__decimal_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__decimal_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__decimal_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "xsd:integer"))
	{	cp->type = SOAP_TYPE_xsd__integer_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__integer_;
			if (size)
				*size = sizeof(xsd__integer_);
		}
		else
		{	cp->ptr = (void*)new xsd__integer_[n];
			if (size)
				*size = n * sizeof(xsd__integer_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__integer_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:long"))
	{	cp->type = SOAP_TYPE_xsd__long_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__long_;
			if (size)
				*size = sizeof(xsd__long_);
		}
		else
		{	cp->ptr = (void*)new xsd__long_[n];
			if (size)
				*size = n * sizeof(xsd__long_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__long_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:int"))
	{	cp->type = SOAP_TYPE_xsd__int_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__int_;
			if (size)
				*size = sizeof(xsd__int_);
		}
		else
		{	cp->ptr = (void*)new xsd__int_[n];
			if (size)
				*size = n * sizeof(xsd__int_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__int_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:short"))
	{	cp->type = SOAP_TYPE_xsd__short_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__short_;
			if (size)
				*size = sizeof(xsd__short_);
		}
		else
		{	cp->ptr = (void*)new xsd__short_[n];
			if (size)
				*size = n * sizeof(xsd__short_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__short_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:byte"))
	{	cp->type = SOAP_TYPE_xsd__byte_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__byte_;
			if (size)
				*size = sizeof(xsd__byte_);
		}
		else
		{	cp->ptr = (void*)new xsd__byte_[n];
			if (size)
				*size = n * sizeof(xsd__byte_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__byte_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:nonPositiveInteger"))
	{	cp->type = SOAP_TYPE_xsd__nonPositiveInteger_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__nonPositiveInteger_;
			if (size)
				*size = sizeof(xsd__nonPositiveInteger_);
		}
		else
		{	cp->ptr = (void*)new xsd__nonPositiveInteger_[n];
			if (size)
				*size = n * sizeof(xsd__nonPositiveInteger_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__nonPositiveInteger_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:negativeInteger"))
	{	cp->type = SOAP_TYPE_xsd__negativeInteger_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__negativeInteger_;
			if (size)
				*size = sizeof(xsd__negativeInteger_);
		}
		else
		{	cp->ptr = (void*)new xsd__negativeInteger_[n];
			if (size)
				*size = n * sizeof(xsd__negativeInteger_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__negativeInteger_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:nonNegativeInteger"))
	{	cp->type = SOAP_TYPE_xsd__nonNegativeInteger_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__nonNegativeInteger_;
			if (size)
				*size = sizeof(xsd__nonNegativeInteger_);
		}
		else
		{	cp->ptr = (void*)new xsd__nonNegativeInteger_[n];
			if (size)
				*size = n * sizeof(xsd__nonNegativeInteger_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__nonNegativeInteger_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:positiveInteger"))
	{	cp->type = SOAP_TYPE_xsd__positiveInteger_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__positiveInteger_;
			if (size)
				*size = sizeof(xsd__positiveInteger_);
		}
		else
		{	cp->ptr = (void*)new xsd__positiveInteger_[n];
			if (size)
				*size = n * sizeof(xsd__positiveInteger_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__positiveInteger_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:unsignedLong"))
	{	cp->type = SOAP_TYPE_xsd__unsignedLong_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedLong_;
			if (size)
				*size = sizeof(xsd__unsignedLong_);
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedLong_[n];
			if (size)
				*size = n * sizeof(xsd__unsignedLong_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedLong_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:unsignedInt"))
	{	cp->type = SOAP_TYPE_xsd__unsignedInt_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedInt_;
			if (size)
				*size = sizeof(xsd__unsignedInt_);
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedInt_[n];
			if (size)
				*size = n * sizeof(xsd__unsignedInt_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedInt_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:unsignedShort"))
	{	cp->type = SOAP_TYPE_xsd__unsignedShort_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedShort_;
			if (size)
				*size = sizeof(xsd__unsignedShort_);
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedShort_[n];
			if (size)
				*size = n * sizeof(xsd__unsignedShort_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedShort_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:unsignedByte"))
	{	cp->type = SOAP_TYPE_xsd__unsignedByte_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedByte_;
			if (size)
				*size = sizeof(xsd__unsignedByte_);
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedByte_[n];
			if (size)
				*size = n * sizeof(xsd__unsignedByte_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedByte_*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new xsd__decimal_;
		if (size)
			*size = sizeof(xsd__decimal_);
	}
	else
	{	cp->ptr = (void*)new xsd__decimal_[n];
		if (size)
			*size = n * sizeof(xsd__decimal_);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__decimal_*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__decimal_(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__decimal_ %p -> %p\n", q, p));
	*(xsd__decimal_*)p = *(xsd__decimal_*)q;
}

void xsd__time_::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__time_::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((xsd__time_*)this)->__item, SOAP_TYPE_xsd__time);
	soap_mark_xsd__time(soap, &((xsd__time_*)this)->__item);
}

void xsd__time_::soap_default(struct soap *soap)
{
	((xsd__time_*)this)->__item = NULL;
}

int xsd__time_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__time_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__time_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__time_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__time_(struct soap *soap, const char *tag, int id, const xsd__time_ *a, const char *type)
{
	soap_out_xsd__time(soap, tag, id, &(((xsd__time_*)a)->__item), "xsd:time");
	return SOAP_OK;
}

void *xsd__time_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__time_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__time_ * SOAP_FMAC4 soap_get_xsd__time_(struct soap *soap, xsd__time_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__time_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__time_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__time_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__time_ * SOAP_FMAC4 soap_in_xsd__time_(struct soap *soap, const char *tag, xsd__time_ *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (xsd__time_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__time_, sizeof(xsd__time_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__time_)
			return (xsd__time_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__time(soap, tag, &(((xsd__time_*)a)->__item), "xsd:time"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__time_ * SOAP_FMAC6 soap_new_xsd__time_(struct soap *soap, int n)
{	return soap_instantiate_xsd__time_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__time_(struct soap *soap, xsd__time_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__time_ * SOAP_FMAC6 soap_instantiate_xsd__time_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__time_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__time_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__time_;
		if (size)
			*size = sizeof(xsd__time_);
	}
	else
	{	cp->ptr = (void*)new xsd__time_[n];
		if (size)
			*size = n * sizeof(xsd__time_);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__time_*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__time_(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__time_ %p -> %p\n", q, p));
	*(xsd__time_*)p = *(xsd__time_*)q;
}

void xsd__float_::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__float_::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((xsd__float_*)this)->__item, SOAP_TYPE_xsd__float);
}

void xsd__float_::soap_default(struct soap *soap)
{
	soap_default_xsd__float(soap, &((xsd__float_*)this)->__item);
}

int xsd__float_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__float_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__float_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__float_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__float_(struct soap *soap, const char *tag, int id, const xsd__float_ *a, const char *type)
{
	soap_out_xsd__float(soap, tag, id, &(((xsd__float_*)a)->__item), "xsd:float");
	return SOAP_OK;
}

void *xsd__float_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__float_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__float_ * SOAP_FMAC4 soap_get_xsd__float_(struct soap *soap, xsd__float_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__float_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__float_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__float_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__float_ * SOAP_FMAC4 soap_in_xsd__float_(struct soap *soap, const char *tag, xsd__float_ *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (xsd__float_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__float_, sizeof(xsd__float_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__float_)
			return (xsd__float_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__float(soap, tag, &(((xsd__float_*)a)->__item), "xsd:float"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__float_ * SOAP_FMAC6 soap_new_xsd__float_(struct soap *soap, int n)
{	return soap_instantiate_xsd__float_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__float_(struct soap *soap, xsd__float_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__float_ * SOAP_FMAC6 soap_instantiate_xsd__float_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__float_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__float_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__float_;
		if (size)
			*size = sizeof(xsd__float_);
	}
	else
	{	cp->ptr = (void*)new xsd__float_[n];
		if (size)
			*size = n * sizeof(xsd__float_);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__float_*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__float_(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__float_ %p -> %p\n", q, p));
	*(xsd__float_*)p = *(xsd__float_*)q;
}

void xsd__duration_::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__duration_::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((xsd__duration_*)this)->__item, SOAP_TYPE_xsd__duration);
	soap_mark_xsd__duration(soap, &((xsd__duration_*)this)->__item);
}

void xsd__duration_::soap_default(struct soap *soap)
{
	((xsd__duration_*)this)->__item = NULL;
}

int xsd__duration_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__duration_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__duration_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__duration_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__duration_(struct soap *soap, const char *tag, int id, const xsd__duration_ *a, const char *type)
{
	soap_out_xsd__duration(soap, tag, id, &(((xsd__duration_*)a)->__item), "xsd:duration");
	return SOAP_OK;
}

void *xsd__duration_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__duration_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__duration_ * SOAP_FMAC4 soap_get_xsd__duration_(struct soap *soap, xsd__duration_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__duration_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__duration_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__duration_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__duration_ * SOAP_FMAC4 soap_in_xsd__duration_(struct soap *soap, const char *tag, xsd__duration_ *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (xsd__duration_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__duration_, sizeof(xsd__duration_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__duration_)
			return (xsd__duration_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__duration(soap, tag, &(((xsd__duration_*)a)->__item), "xsd:duration"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__duration_ * SOAP_FMAC6 soap_new_xsd__duration_(struct soap *soap, int n)
{	return soap_instantiate_xsd__duration_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__duration_(struct soap *soap, xsd__duration_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__duration_ * SOAP_FMAC6 soap_instantiate_xsd__duration_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__duration_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__duration_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__duration_;
		if (size)
			*size = sizeof(xsd__duration_);
	}
	else
	{	cp->ptr = (void*)new xsd__duration_[n];
		if (size)
			*size = n * sizeof(xsd__duration_);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__duration_*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__duration_(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__duration_ %p -> %p\n", q, p));
	*(xsd__duration_*)p = *(xsd__duration_*)q;
}

void xsd__double_::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__double_::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((xsd__double_*)this)->__item, SOAP_TYPE_xsd__double);
}

void xsd__double_::soap_default(struct soap *soap)
{
	soap_default_xsd__double(soap, &((xsd__double_*)this)->__item);
}

int xsd__double_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__double_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__double_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__double_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__double_(struct soap *soap, const char *tag, int id, const xsd__double_ *a, const char *type)
{
	soap_out_xsd__double(soap, tag, id, &(((xsd__double_*)a)->__item), "xsd:double");
	return SOAP_OK;
}

void *xsd__double_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__double_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__double_ * SOAP_FMAC4 soap_get_xsd__double_(struct soap *soap, xsd__double_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__double_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__double_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__double_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__double_ * SOAP_FMAC4 soap_in_xsd__double_(struct soap *soap, const char *tag, xsd__double_ *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (xsd__double_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__double_, sizeof(xsd__double_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__double_)
			return (xsd__double_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__double(soap, tag, &(((xsd__double_*)a)->__item), "xsd:double"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__double_ * SOAP_FMAC6 soap_new_xsd__double_(struct soap *soap, int n)
{	return soap_instantiate_xsd__double_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__double_(struct soap *soap, xsd__double_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__double_ * SOAP_FMAC6 soap_instantiate_xsd__double_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__double_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__double_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__double_;
		if (size)
			*size = sizeof(xsd__double_);
	}
	else
	{	cp->ptr = (void*)new xsd__double_[n];
		if (size)
			*size = n * sizeof(xsd__double_);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__double_*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__double_(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__double_ %p -> %p\n", q, p));
	*(xsd__double_*)p = *(xsd__double_*)q;
}

void xsd__dateTime_::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__dateTime_::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((xsd__dateTime_*)this)->__item, SOAP_TYPE_xsd__dateTime);
	soap_mark_xsd__dateTime(soap, &((xsd__dateTime_*)this)->__item);
}

void xsd__dateTime_::soap_default(struct soap *soap)
{
	((xsd__dateTime_*)this)->__item = NULL;
}

int xsd__dateTime_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__dateTime_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__dateTime_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__dateTime_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__dateTime_(struct soap *soap, const char *tag, int id, const xsd__dateTime_ *a, const char *type)
{
	soap_out_xsd__dateTime(soap, tag, id, &(((xsd__dateTime_*)a)->__item), "xsd:dateTime");
	return SOAP_OK;
}

void *xsd__dateTime_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__dateTime_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__dateTime_ * SOAP_FMAC4 soap_get_xsd__dateTime_(struct soap *soap, xsd__dateTime_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__dateTime_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__dateTime_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__dateTime_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__dateTime_ * SOAP_FMAC4 soap_in_xsd__dateTime_(struct soap *soap, const char *tag, xsd__dateTime_ *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (xsd__dateTime_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__dateTime_, sizeof(xsd__dateTime_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__dateTime_)
			return (xsd__dateTime_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__dateTime(soap, tag, &(((xsd__dateTime_*)a)->__item), "xsd:dateTime"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__dateTime_ * SOAP_FMAC6 soap_new_xsd__dateTime_(struct soap *soap, int n)
{	return soap_instantiate_xsd__dateTime_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__dateTime_(struct soap *soap, xsd__dateTime_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__dateTime_ * SOAP_FMAC6 soap_instantiate_xsd__dateTime_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__dateTime_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__dateTime_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__dateTime_;
		if (size)
			*size = sizeof(xsd__dateTime_);
	}
	else
	{	cp->ptr = (void*)new xsd__dateTime_[n];
		if (size)
			*size = n * sizeof(xsd__dateTime_);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__dateTime_*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__dateTime_(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__dateTime_ %p -> %p\n", q, p));
	*(xsd__dateTime_*)p = *(xsd__dateTime_*)q;
}

void xsd__date_::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__date_::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((xsd__date_*)this)->__item, SOAP_TYPE_xsd__date);
	soap_mark_xsd__date(soap, &((xsd__date_*)this)->__item);
}

void xsd__date_::soap_default(struct soap *soap)
{
	((xsd__date_*)this)->__item = NULL;
}

int xsd__date_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__date_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__date_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__date_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__date_(struct soap *soap, const char *tag, int id, const xsd__date_ *a, const char *type)
{
	soap_out_xsd__date(soap, tag, id, &(((xsd__date_*)a)->__item), "xsd:date");
	return SOAP_OK;
}

void *xsd__date_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__date_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__date_ * SOAP_FMAC4 soap_get_xsd__date_(struct soap *soap, xsd__date_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__date_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__date_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__date_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__date_ * SOAP_FMAC4 soap_in_xsd__date_(struct soap *soap, const char *tag, xsd__date_ *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (xsd__date_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__date_, sizeof(xsd__date_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__date_)
			return (xsd__date_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__date(soap, tag, &(((xsd__date_*)a)->__item), "xsd:date"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__date_ * SOAP_FMAC6 soap_new_xsd__date_(struct soap *soap, int n)
{	return soap_instantiate_xsd__date_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__date_(struct soap *soap, xsd__date_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__date_ * SOAP_FMAC6 soap_instantiate_xsd__date_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__date_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__date_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__date_;
		if (size)
			*size = sizeof(xsd__date_);
	}
	else
	{	cp->ptr = (void*)new xsd__date_[n];
		if (size)
			*size = n * sizeof(xsd__date_);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__date_*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__date_(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__date_ %p -> %p\n", q, p));
	*(xsd__date_*)p = *(xsd__date_*)q;
}

void xsd__boolean_::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__boolean_::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((xsd__boolean_*)this)->__item, SOAP_TYPE_xsd__boolean);
}

void xsd__boolean_::soap_default(struct soap *soap)
{
	soap_default_xsd__boolean(soap, &((xsd__boolean_*)this)->__item);
}

int xsd__boolean_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__boolean_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__boolean_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__boolean_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__boolean_(struct soap *soap, const char *tag, int id, const xsd__boolean_ *a, const char *type)
{
	soap_out_xsd__boolean(soap, tag, id, &(((xsd__boolean_*)a)->__item), "xsd:boolean");
	return SOAP_OK;
}

void *xsd__boolean_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__boolean_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__boolean_ * SOAP_FMAC4 soap_get_xsd__boolean_(struct soap *soap, xsd__boolean_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__boolean_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__boolean_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__boolean_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__boolean_ * SOAP_FMAC4 soap_in_xsd__boolean_(struct soap *soap, const char *tag, xsd__boolean_ *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (xsd__boolean_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__boolean_, sizeof(xsd__boolean_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__boolean_)
			return (xsd__boolean_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__boolean(soap, tag, &(((xsd__boolean_*)a)->__item), "xsd:boolean"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__boolean_ * SOAP_FMAC6 soap_new_xsd__boolean_(struct soap *soap, int n)
{	return soap_instantiate_xsd__boolean_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__boolean_(struct soap *soap, xsd__boolean_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__boolean_ * SOAP_FMAC6 soap_instantiate_xsd__boolean_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__boolean_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__boolean_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__boolean_;
		if (size)
			*size = sizeof(xsd__boolean_);
	}
	else
	{	cp->ptr = (void*)new xsd__boolean_[n];
		if (size)
			*size = n * sizeof(xsd__boolean_);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__boolean_*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__boolean_(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__boolean_ %p -> %p\n", q, p));
	*(xsd__boolean_*)p = *(xsd__boolean_*)q;
}

void xsd__anyURI_::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__anyURI_::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((xsd__anyURI_*)this)->__item, SOAP_TYPE_xsd__anyURI);
	soap_mark_xsd__anyURI(soap, &((xsd__anyURI_*)this)->__item);
}

void xsd__anyURI_::soap_default(struct soap *soap)
{
	((xsd__anyURI_*)this)->__item = NULL;
}

int xsd__anyURI_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__anyURI_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__anyURI_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__anyURI_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI_(struct soap *soap, const char *tag, int id, const xsd__anyURI_ *a, const char *type)
{
	soap_out_xsd__anyURI(soap, tag, id, &(((xsd__anyURI_*)a)->__item), "xsd:anyURI");
	return SOAP_OK;
}

void *xsd__anyURI_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__anyURI_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__anyURI_ * SOAP_FMAC4 soap_get_xsd__anyURI_(struct soap *soap, xsd__anyURI_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyURI_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__anyURI_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__anyURI_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__anyURI_ * SOAP_FMAC4 soap_in_xsd__anyURI_(struct soap *soap, const char *tag, xsd__anyURI_ *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (xsd__anyURI_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__anyURI_, sizeof(xsd__anyURI_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__anyURI_)
			return (xsd__anyURI_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__anyURI(soap, tag, &(((xsd__anyURI_*)a)->__item), "xsd:anyURI"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__anyURI_ * SOAP_FMAC6 soap_new_xsd__anyURI_(struct soap *soap, int n)
{	return soap_instantiate_xsd__anyURI_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__anyURI_(struct soap *soap, xsd__anyURI_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__anyURI_ * SOAP_FMAC6 soap_instantiate_xsd__anyURI_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__anyURI_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__anyURI_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__anyURI_;
		if (size)
			*size = sizeof(xsd__anyURI_);
	}
	else
	{	cp->ptr = (void*)new xsd__anyURI_[n];
		if (size)
			*size = n * sizeof(xsd__anyURI_);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__anyURI_*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__anyURI_(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__anyURI_ %p -> %p\n", q, p));
	*(xsd__anyURI_*)p = *(xsd__anyURI_*)q;
}

void xsd__anySimpleType::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__anySimpleType::soap_mark(struct soap *soap) const
{
}

void xsd__anySimpleType::soap_default(struct soap *soap)
{
}

int xsd__anySimpleType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__anySimpleType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__anySimpleType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__anySimpleType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anySimpleType(struct soap *soap, const char *tag, int id, const xsd__anySimpleType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xsd__anySimpleType), "xsd:anySimpleType");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *xsd__anySimpleType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__anySimpleType(soap, this, tag, type);
}

SOAP_FMAC3 xsd__anySimpleType * SOAP_FMAC4 soap_get_xsd__anySimpleType(struct soap *soap, xsd__anySimpleType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anySimpleType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__anySimpleType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__anySimpleType(soap, tag, this, type);
}

SOAP_FMAC3 xsd__anySimpleType * SOAP_FMAC4 soap_in_xsd__anySimpleType(struct soap *soap, const char *tag, xsd__anySimpleType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (xsd__anySimpleType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__anySimpleType, sizeof(xsd__anySimpleType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__anySimpleType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (xsd__anySimpleType *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (xsd__anySimpleType *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_xsd__anySimpleType, 0, sizeof(xsd__anySimpleType), 0, soap_copy_xsd__anySimpleType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 xsd__anySimpleType * SOAP_FMAC6 soap_new_xsd__anySimpleType(struct soap *soap, int n)
{	return soap_instantiate_xsd__anySimpleType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__anySimpleType(struct soap *soap, xsd__anySimpleType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__anySimpleType * SOAP_FMAC6 soap_instantiate_xsd__anySimpleType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__anySimpleType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__anySimpleType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "xsd:anyURI"))
	{	cp->type = SOAP_TYPE_xsd__anyURI_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__anyURI_;
			if (size)
				*size = sizeof(xsd__anyURI_);
		}
		else
		{	cp->ptr = (void*)new xsd__anyURI_[n];
			if (size)
				*size = n * sizeof(xsd__anyURI_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__anyURI_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:boolean"))
	{	cp->type = SOAP_TYPE_xsd__boolean_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__boolean_;
			if (size)
				*size = sizeof(xsd__boolean_);
		}
		else
		{	cp->ptr = (void*)new xsd__boolean_[n];
			if (size)
				*size = n * sizeof(xsd__boolean_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__boolean_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:date"))
	{	cp->type = SOAP_TYPE_xsd__date_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__date_;
			if (size)
				*size = sizeof(xsd__date_);
		}
		else
		{	cp->ptr = (void*)new xsd__date_[n];
			if (size)
				*size = n * sizeof(xsd__date_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__date_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:dateTime"))
	{	cp->type = SOAP_TYPE_xsd__dateTime_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__dateTime_;
			if (size)
				*size = sizeof(xsd__dateTime_);
		}
		else
		{	cp->ptr = (void*)new xsd__dateTime_[n];
			if (size)
				*size = n * sizeof(xsd__dateTime_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__dateTime_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:double"))
	{	cp->type = SOAP_TYPE_xsd__double_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__double_;
			if (size)
				*size = sizeof(xsd__double_);
		}
		else
		{	cp->ptr = (void*)new xsd__double_[n];
			if (size)
				*size = n * sizeof(xsd__double_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__double_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:duration"))
	{	cp->type = SOAP_TYPE_xsd__duration_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__duration_;
			if (size)
				*size = sizeof(xsd__duration_);
		}
		else
		{	cp->ptr = (void*)new xsd__duration_[n];
			if (size)
				*size = n * sizeof(xsd__duration_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__duration_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:float"))
	{	cp->type = SOAP_TYPE_xsd__float_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__float_;
			if (size)
				*size = sizeof(xsd__float_);
		}
		else
		{	cp->ptr = (void*)new xsd__float_[n];
			if (size)
				*size = n * sizeof(xsd__float_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__float_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:time"))
	{	cp->type = SOAP_TYPE_xsd__time_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__time_;
			if (size)
				*size = sizeof(xsd__time_);
		}
		else
		{	cp->ptr = (void*)new xsd__time_[n];
			if (size)
				*size = n * sizeof(xsd__time_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__time_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:decimal"))
	{	cp->type = SOAP_TYPE_xsd__decimal_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__decimal_;
			if (size)
				*size = sizeof(xsd__decimal_);
		}
		else
		{	cp->ptr = (void*)new xsd__decimal_[n];
			if (size)
				*size = n * sizeof(xsd__decimal_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__decimal_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:integer"))
	{	cp->type = SOAP_TYPE_xsd__integer_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__integer_;
			if (size)
				*size = sizeof(xsd__integer_);
		}
		else
		{	cp->ptr = (void*)new xsd__integer_[n];
			if (size)
				*size = n * sizeof(xsd__integer_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__integer_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:long"))
	{	cp->type = SOAP_TYPE_xsd__long_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__long_;
			if (size)
				*size = sizeof(xsd__long_);
		}
		else
		{	cp->ptr = (void*)new xsd__long_[n];
			if (size)
				*size = n * sizeof(xsd__long_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__long_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:int"))
	{	cp->type = SOAP_TYPE_xsd__int_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__int_;
			if (size)
				*size = sizeof(xsd__int_);
		}
		else
		{	cp->ptr = (void*)new xsd__int_[n];
			if (size)
				*size = n * sizeof(xsd__int_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__int_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:short"))
	{	cp->type = SOAP_TYPE_xsd__short_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__short_;
			if (size)
				*size = sizeof(xsd__short_);
		}
		else
		{	cp->ptr = (void*)new xsd__short_[n];
			if (size)
				*size = n * sizeof(xsd__short_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__short_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:byte"))
	{	cp->type = SOAP_TYPE_xsd__byte_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__byte_;
			if (size)
				*size = sizeof(xsd__byte_);
		}
		else
		{	cp->ptr = (void*)new xsd__byte_[n];
			if (size)
				*size = n * sizeof(xsd__byte_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__byte_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:nonPositiveInteger"))
	{	cp->type = SOAP_TYPE_xsd__nonPositiveInteger_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__nonPositiveInteger_;
			if (size)
				*size = sizeof(xsd__nonPositiveInteger_);
		}
		else
		{	cp->ptr = (void*)new xsd__nonPositiveInteger_[n];
			if (size)
				*size = n * sizeof(xsd__nonPositiveInteger_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__nonPositiveInteger_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:negativeInteger"))
	{	cp->type = SOAP_TYPE_xsd__negativeInteger_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__negativeInteger_;
			if (size)
				*size = sizeof(xsd__negativeInteger_);
		}
		else
		{	cp->ptr = (void*)new xsd__negativeInteger_[n];
			if (size)
				*size = n * sizeof(xsd__negativeInteger_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__negativeInteger_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:nonNegativeInteger"))
	{	cp->type = SOAP_TYPE_xsd__nonNegativeInteger_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__nonNegativeInteger_;
			if (size)
				*size = sizeof(xsd__nonNegativeInteger_);
		}
		else
		{	cp->ptr = (void*)new xsd__nonNegativeInteger_[n];
			if (size)
				*size = n * sizeof(xsd__nonNegativeInteger_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__nonNegativeInteger_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:positiveInteger"))
	{	cp->type = SOAP_TYPE_xsd__positiveInteger_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__positiveInteger_;
			if (size)
				*size = sizeof(xsd__positiveInteger_);
		}
		else
		{	cp->ptr = (void*)new xsd__positiveInteger_[n];
			if (size)
				*size = n * sizeof(xsd__positiveInteger_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__positiveInteger_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:unsignedLong"))
	{	cp->type = SOAP_TYPE_xsd__unsignedLong_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedLong_;
			if (size)
				*size = sizeof(xsd__unsignedLong_);
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedLong_[n];
			if (size)
				*size = n * sizeof(xsd__unsignedLong_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedLong_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:unsignedInt"))
	{	cp->type = SOAP_TYPE_xsd__unsignedInt_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedInt_;
			if (size)
				*size = sizeof(xsd__unsignedInt_);
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedInt_[n];
			if (size)
				*size = n * sizeof(xsd__unsignedInt_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedInt_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:unsignedShort"))
	{	cp->type = SOAP_TYPE_xsd__unsignedShort_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedShort_;
			if (size)
				*size = sizeof(xsd__unsignedShort_);
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedShort_[n];
			if (size)
				*size = n * sizeof(xsd__unsignedShort_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedShort_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:unsignedByte"))
	{	cp->type = SOAP_TYPE_xsd__unsignedByte_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedByte_;
			if (size)
				*size = sizeof(xsd__unsignedByte_);
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedByte_[n];
			if (size)
				*size = n * sizeof(xsd__unsignedByte_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedByte_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:wstring"))
	{	cp->type = SOAP_TYPE_xsd__wstring_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__wstring_;
			if (size)
				*size = sizeof(xsd__wstring_);
		}
		else
		{	cp->ptr = (void*)new xsd__wstring_[n];
			if (size)
				*size = n * sizeof(xsd__wstring_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__wstring_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:string"))
	{	cp->type = SOAP_TYPE_xsd__string_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__string_;
			if (size)
				*size = sizeof(xsd__string_);
		}
		else
		{	cp->ptr = (void*)new xsd__string_[n];
			if (size)
				*size = n * sizeof(xsd__string_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__string_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:normalizedString"))
	{	cp->type = SOAP_TYPE_xsd__normalizedString_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__normalizedString_;
			if (size)
				*size = sizeof(xsd__normalizedString_);
		}
		else
		{	cp->ptr = (void*)new xsd__normalizedString_[n];
			if (size)
				*size = n * sizeof(xsd__normalizedString_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__normalizedString_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:token"))
	{	cp->type = SOAP_TYPE_xsd__token_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__token_;
			if (size)
				*size = sizeof(xsd__token_);
		}
		else
		{	cp->ptr = (void*)new xsd__token_[n];
			if (size)
				*size = n * sizeof(xsd__token_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__token_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:base64Binary"))
	{	cp->type = SOAP_TYPE_xsd__base64Binary;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__base64Binary;
			if (size)
				*size = sizeof(xsd__base64Binary);
		}
		else
		{	cp->ptr = (void*)new xsd__base64Binary[n];
			if (size)
				*size = n * sizeof(xsd__base64Binary);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__base64Binary*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:hexBinary"))
	{	cp->type = SOAP_TYPE_xsd__hexBinary;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__hexBinary;
			if (size)
				*size = sizeof(xsd__hexBinary);
		}
		else
		{	cp->ptr = (void*)new xsd__hexBinary[n];
			if (size)
				*size = n * sizeof(xsd__hexBinary);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__hexBinary*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new xsd__anySimpleType;
		if (size)
			*size = sizeof(xsd__anySimpleType);
	}
	else
	{	cp->ptr = (void*)new xsd__anySimpleType[n];
		if (size)
			*size = n * sizeof(xsd__anySimpleType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__anySimpleType*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__anySimpleType(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__anySimpleType %p -> %p\n", q, p));
	*(xsd__anySimpleType*)p = *(xsd__anySimpleType*)q;
}

void xsd__anyType::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__anyType::soap_mark(struct soap *soap) const
{
}

void xsd__anyType::soap_default(struct soap *soap)
{
}

int xsd__anyType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__anyType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__anyType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__anyType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyType(struct soap *soap, const char *tag, int id, const xsd__anyType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xsd__anyType), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *xsd__anyType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__anyType(soap, this, tag, type);
}

SOAP_FMAC3 xsd__anyType * SOAP_FMAC4 soap_get_xsd__anyType(struct soap *soap, xsd__anyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__anyType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__anyType(soap, tag, this, type);
}

SOAP_FMAC3 xsd__anyType * SOAP_FMAC4 soap_in_xsd__anyType(struct soap *soap, const char *tag, xsd__anyType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (xsd__anyType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__anyType, sizeof(xsd__anyType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__anyType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (xsd__anyType *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (xsd__anyType *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_xsd__anyType, 0, sizeof(xsd__anyType), 0, soap_copy_xsd__anyType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 xsd__anyType * SOAP_FMAC6 soap_new_xsd__anyType(struct soap *soap, int n)
{	return soap_instantiate_xsd__anyType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__anyType(struct soap *soap, xsd__anyType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__anyType * SOAP_FMAC6 soap_instantiate_xsd__anyType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__anyType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__anyType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "xsd:anySimpleType"))
	{	cp->type = SOAP_TYPE_xsd__anySimpleType;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__anySimpleType;
			if (size)
				*size = sizeof(xsd__anySimpleType);
		}
		else
		{	cp->ptr = (void*)new xsd__anySimpleType[n];
			if (size)
				*size = n * sizeof(xsd__anySimpleType);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__anySimpleType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:anyURI"))
	{	cp->type = SOAP_TYPE_xsd__anyURI_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__anyURI_;
			if (size)
				*size = sizeof(xsd__anyURI_);
		}
		else
		{	cp->ptr = (void*)new xsd__anyURI_[n];
			if (size)
				*size = n * sizeof(xsd__anyURI_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__anyURI_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:boolean"))
	{	cp->type = SOAP_TYPE_xsd__boolean_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__boolean_;
			if (size)
				*size = sizeof(xsd__boolean_);
		}
		else
		{	cp->ptr = (void*)new xsd__boolean_[n];
			if (size)
				*size = n * sizeof(xsd__boolean_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__boolean_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:date"))
	{	cp->type = SOAP_TYPE_xsd__date_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__date_;
			if (size)
				*size = sizeof(xsd__date_);
		}
		else
		{	cp->ptr = (void*)new xsd__date_[n];
			if (size)
				*size = n * sizeof(xsd__date_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__date_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:dateTime"))
	{	cp->type = SOAP_TYPE_xsd__dateTime_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__dateTime_;
			if (size)
				*size = sizeof(xsd__dateTime_);
		}
		else
		{	cp->ptr = (void*)new xsd__dateTime_[n];
			if (size)
				*size = n * sizeof(xsd__dateTime_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__dateTime_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:double"))
	{	cp->type = SOAP_TYPE_xsd__double_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__double_;
			if (size)
				*size = sizeof(xsd__double_);
		}
		else
		{	cp->ptr = (void*)new xsd__double_[n];
			if (size)
				*size = n * sizeof(xsd__double_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__double_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:duration"))
	{	cp->type = SOAP_TYPE_xsd__duration_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__duration_;
			if (size)
				*size = sizeof(xsd__duration_);
		}
		else
		{	cp->ptr = (void*)new xsd__duration_[n];
			if (size)
				*size = n * sizeof(xsd__duration_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__duration_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:float"))
	{	cp->type = SOAP_TYPE_xsd__float_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__float_;
			if (size)
				*size = sizeof(xsd__float_);
		}
		else
		{	cp->ptr = (void*)new xsd__float_[n];
			if (size)
				*size = n * sizeof(xsd__float_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__float_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:time"))
	{	cp->type = SOAP_TYPE_xsd__time_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__time_;
			if (size)
				*size = sizeof(xsd__time_);
		}
		else
		{	cp->ptr = (void*)new xsd__time_[n];
			if (size)
				*size = n * sizeof(xsd__time_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__time_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:decimal"))
	{	cp->type = SOAP_TYPE_xsd__decimal_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__decimal_;
			if (size)
				*size = sizeof(xsd__decimal_);
		}
		else
		{	cp->ptr = (void*)new xsd__decimal_[n];
			if (size)
				*size = n * sizeof(xsd__decimal_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__decimal_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:integer"))
	{	cp->type = SOAP_TYPE_xsd__integer_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__integer_;
			if (size)
				*size = sizeof(xsd__integer_);
		}
		else
		{	cp->ptr = (void*)new xsd__integer_[n];
			if (size)
				*size = n * sizeof(xsd__integer_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__integer_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:long"))
	{	cp->type = SOAP_TYPE_xsd__long_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__long_;
			if (size)
				*size = sizeof(xsd__long_);
		}
		else
		{	cp->ptr = (void*)new xsd__long_[n];
			if (size)
				*size = n * sizeof(xsd__long_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__long_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:int"))
	{	cp->type = SOAP_TYPE_xsd__int_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__int_;
			if (size)
				*size = sizeof(xsd__int_);
		}
		else
		{	cp->ptr = (void*)new xsd__int_[n];
			if (size)
				*size = n * sizeof(xsd__int_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__int_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:short"))
	{	cp->type = SOAP_TYPE_xsd__short_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__short_;
			if (size)
				*size = sizeof(xsd__short_);
		}
		else
		{	cp->ptr = (void*)new xsd__short_[n];
			if (size)
				*size = n * sizeof(xsd__short_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__short_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:byte"))
	{	cp->type = SOAP_TYPE_xsd__byte_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__byte_;
			if (size)
				*size = sizeof(xsd__byte_);
		}
		else
		{	cp->ptr = (void*)new xsd__byte_[n];
			if (size)
				*size = n * sizeof(xsd__byte_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__byte_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:nonPositiveInteger"))
	{	cp->type = SOAP_TYPE_xsd__nonPositiveInteger_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__nonPositiveInteger_;
			if (size)
				*size = sizeof(xsd__nonPositiveInteger_);
		}
		else
		{	cp->ptr = (void*)new xsd__nonPositiveInteger_[n];
			if (size)
				*size = n * sizeof(xsd__nonPositiveInteger_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__nonPositiveInteger_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:negativeInteger"))
	{	cp->type = SOAP_TYPE_xsd__negativeInteger_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__negativeInteger_;
			if (size)
				*size = sizeof(xsd__negativeInteger_);
		}
		else
		{	cp->ptr = (void*)new xsd__negativeInteger_[n];
			if (size)
				*size = n * sizeof(xsd__negativeInteger_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__negativeInteger_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:nonNegativeInteger"))
	{	cp->type = SOAP_TYPE_xsd__nonNegativeInteger_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__nonNegativeInteger_;
			if (size)
				*size = sizeof(xsd__nonNegativeInteger_);
		}
		else
		{	cp->ptr = (void*)new xsd__nonNegativeInteger_[n];
			if (size)
				*size = n * sizeof(xsd__nonNegativeInteger_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__nonNegativeInteger_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:positiveInteger"))
	{	cp->type = SOAP_TYPE_xsd__positiveInteger_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__positiveInteger_;
			if (size)
				*size = sizeof(xsd__positiveInteger_);
		}
		else
		{	cp->ptr = (void*)new xsd__positiveInteger_[n];
			if (size)
				*size = n * sizeof(xsd__positiveInteger_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__positiveInteger_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:unsignedLong"))
	{	cp->type = SOAP_TYPE_xsd__unsignedLong_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedLong_;
			if (size)
				*size = sizeof(xsd__unsignedLong_);
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedLong_[n];
			if (size)
				*size = n * sizeof(xsd__unsignedLong_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedLong_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:unsignedInt"))
	{	cp->type = SOAP_TYPE_xsd__unsignedInt_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedInt_;
			if (size)
				*size = sizeof(xsd__unsignedInt_);
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedInt_[n];
			if (size)
				*size = n * sizeof(xsd__unsignedInt_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedInt_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:unsignedShort"))
	{	cp->type = SOAP_TYPE_xsd__unsignedShort_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedShort_;
			if (size)
				*size = sizeof(xsd__unsignedShort_);
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedShort_[n];
			if (size)
				*size = n * sizeof(xsd__unsignedShort_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedShort_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:unsignedByte"))
	{	cp->type = SOAP_TYPE_xsd__unsignedByte_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedByte_;
			if (size)
				*size = sizeof(xsd__unsignedByte_);
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedByte_[n];
			if (size)
				*size = n * sizeof(xsd__unsignedByte_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedByte_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:wstring"))
	{	cp->type = SOAP_TYPE_xsd__wstring_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__wstring_;
			if (size)
				*size = sizeof(xsd__wstring_);
		}
		else
		{	cp->ptr = (void*)new xsd__wstring_[n];
			if (size)
				*size = n * sizeof(xsd__wstring_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__wstring_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:string"))
	{	cp->type = SOAP_TYPE_xsd__string_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__string_;
			if (size)
				*size = sizeof(xsd__string_);
		}
		else
		{	cp->ptr = (void*)new xsd__string_[n];
			if (size)
				*size = n * sizeof(xsd__string_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__string_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:normalizedString"))
	{	cp->type = SOAP_TYPE_xsd__normalizedString_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__normalizedString_;
			if (size)
				*size = sizeof(xsd__normalizedString_);
		}
		else
		{	cp->ptr = (void*)new xsd__normalizedString_[n];
			if (size)
				*size = n * sizeof(xsd__normalizedString_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__normalizedString_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:token"))
	{	cp->type = SOAP_TYPE_xsd__token_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__token_;
			if (size)
				*size = sizeof(xsd__token_);
		}
		else
		{	cp->ptr = (void*)new xsd__token_[n];
			if (size)
				*size = n * sizeof(xsd__token_);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__token_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:base64Binary"))
	{	cp->type = SOAP_TYPE_xsd__base64Binary;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__base64Binary;
			if (size)
				*size = sizeof(xsd__base64Binary);
		}
		else
		{	cp->ptr = (void*)new xsd__base64Binary[n];
			if (size)
				*size = n * sizeof(xsd__base64Binary);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__base64Binary*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:hexBinary"))
	{	cp->type = SOAP_TYPE_xsd__hexBinary;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__hexBinary;
			if (size)
				*size = sizeof(xsd__hexBinary);
		}
		else
		{	cp->ptr = (void*)new xsd__hexBinary[n];
			if (size)
				*size = n * sizeof(xsd__hexBinary);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__hexBinary*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "param:params"))
	{	cp->type = SOAP_TYPE_param__params;
		if (n < 0)
		{	cp->ptr = (void*)new param__params;
			if (size)
				*size = sizeof(param__params);
		}
		else
		{	cp->ptr = (void*)new param__params[n];
			if (size)
				*size = n * sizeof(param__params);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (param__params*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "param:arrayvalue"))
	{	cp->type = SOAP_TYPE_param__arrayvalue;
		if (n < 0)
		{	cp->ptr = (void*)new param__arrayvalue;
			if (size)
				*size = sizeof(param__arrayvalue);
		}
		else
		{	cp->ptr = (void*)new param__arrayvalue[n];
			if (size)
				*size = n * sizeof(param__arrayvalue);
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (param__arrayvalue*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new xsd__anyType;
		if (size)
			*size = sizeof(xsd__anyType);
	}
	else
	{	cp->ptr = (void*)new xsd__anyType[n];
		if (size)
			*size = n * sizeof(xsd__anyType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__anyType*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__anyType(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__anyType %p -> %p\n", q, p));
	*(xsd__anyType*)p = *(xsd__anyType*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault const*a)
{
	soap_mark_SOAP_ENV__Fault(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	soap_embedded(soap, &a->faultcode, SOAP_TYPE__QName);
	soap_mark__QName(soap, &a->faultcode);
	soap_embedded(soap, &a->faultstring, SOAP_TYPE_string);
	soap_mark_string(soap, &a->faultstring);
	soap_embedded(soap, &a->faultactor, SOAP_TYPE_string);
	soap_mark_string(soap, &a->faultactor);
	soap_embedded(soap, &a->detail, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	soap_mark_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_embedded(soap, &a->SOAP_ENV__Code, SOAP_TYPE_PointerToSOAP_ENV__Code);
	soap_mark_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_embedded(soap, &a->SOAP_ENV__Reason, SOAP_TYPE_string);
	soap_mark_string(soap, &a->SOAP_ENV__Reason);
	soap_embedded(soap, &a->SOAP_ENV__Detail, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	soap_mark_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	a->faultcode = NULL;
	a->faultstring = NULL;
	a->faultactor = NULL;
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type);
	soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, "");
	soap_out_string(soap, "faultstring", -1, &a->faultstring, "");
	soap_out_string(soap, "faultactor", -1, &a->faultactor, "");
	soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, "");
	soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, "");
	soap_out_string(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, "");
	soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	short soap_flag_faultcode = 1, soap_flag_faultstring = 1, soap_flag_faultactor = 1, soap_flag_detail = 1, soap_flag_SOAP_ENV__Code = 1, soap_flag_SOAP_ENV__Reason = 1, soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode = 0;
					continue;
				}
			if (soap_flag_faultstring && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "faultstring", &a->faultstring, ""))
				{	soap_flag_faultstring = 0;
					continue;
				}
			if (soap_flag_faultactor && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "faultactor", &a->faultactor, ""))
				{	soap_flag_faultactor = 0;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail = 0;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code = 0;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason = 0;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail const*a)
{
	soap_mark_SOAP_ENV__Detail(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type);
	soap_putelement(soap, a->fault, "fault", -1, a->__type);
	soap_outliteral(soap, "-any", &a->__any);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	short soap_flag_fault = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code const*a)
{
	soap_mark_SOAP_ENV__Code(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	soap_embedded(soap, &a->SOAP_ENV__Value, SOAP_TYPE__QName);
	soap_mark__QName(soap, &a->SOAP_ENV__Value);
	soap_embedded(soap, &a->SOAP_ENV__Node, SOAP_TYPE_string);
	soap_mark_string(soap, &a->SOAP_ENV__Node);
	soap_embedded(soap, &a->SOAP_ENV__Role, SOAP_TYPE_string);
	soap_mark_string(soap, &a->SOAP_ENV__Role);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	a->SOAP_ENV__Value = NULL;
	a->SOAP_ENV__Node = NULL;
	a->SOAP_ENV__Role = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type);
	soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, "");
	soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, "");
	soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	short soap_flag_SOAP_ENV__Value = 1, soap_flag_SOAP_ENV__Node = 1, soap_flag_SOAP_ENV__Role = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value = 0;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, ""))
				{	soap_flag_SOAP_ENV__Node = 0;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, ""))
				{	soap_flag_SOAP_ENV__Role = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header const*a)
{
	soap_mark_SOAP_ENV__Header(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	/* transient dummy skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	/* transient dummy skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type);
	/* transient dummy skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient dummy skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_aklwngt__klft_GetNextFileChunk(struct soap *soap, struct aklwngt__klft_GetNextFileChunk const*a)
{
	soap_mark_aklwngt__klft_GetNextFileChunk(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_aklwngt__klft_GetNextFileChunk(struct soap *soap, const struct aklwngt__klft_GetNextFileChunk *a)
{
	soap_embedded(soap, &a->szSessionId, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->szSessionId);
	soap_embedded(soap, &a->fileName, SOAP_TYPE_xsd__wstring);
	soap_mark_xsd__wstring(soap, &a->fileName);
	soap_embedded(soap, &a->startFilePos, SOAP_TYPE_xsd__unsignedLong);
	soap_embedded(soap, &a->neededSize, SOAP_TYPE_xsd__unsignedLong);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_aklwngt__klft_GetNextFileChunk(struct soap *soap, struct aklwngt__klft_GetNextFileChunk *a)
{
	a->szSessionId = NULL;
	a->fileName = NULL;
	soap_default_xsd__unsignedLong(soap, &a->startFilePos);
	soap_default_xsd__unsignedLong(soap, &a->neededSize);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_aklwngt__klft_GetNextFileChunk(struct soap *soap, const struct aklwngt__klft_GetNextFileChunk *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_aklwngt__klft_GetNextFileChunk);
	if (soap_out_aklwngt__klft_GetNextFileChunk(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_aklwngt__klft_GetNextFileChunk(struct soap *soap, const char *tag, int id, const struct aklwngt__klft_GetNextFileChunk *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_aklwngt__klft_GetNextFileChunk), type);
	soap_out_xsd__string(soap, "szSessionId", -1, &a->szSessionId, "");
	soap_out_xsd__wstring(soap, "fileName", -1, &a->fileName, "");
	soap_out_xsd__unsignedLong(soap, "startFilePos", -1, &a->startFilePos, "");
	soap_out_xsd__unsignedLong(soap, "neededSize", -1, &a->neededSize, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct aklwngt__klft_GetNextFileChunk * SOAP_FMAC4 soap_get_aklwngt__klft_GetNextFileChunk(struct soap *soap, struct aklwngt__klft_GetNextFileChunk *p, const char *tag, const char *type)
{
	if ((p = soap_in_aklwngt__klft_GetNextFileChunk(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct aklwngt__klft_GetNextFileChunk * SOAP_FMAC4 soap_in_aklwngt__klft_GetNextFileChunk(struct soap *soap, const char *tag, struct aklwngt__klft_GetNextFileChunk *a, const char *type)
{
	short soap_flag_szSessionId = 1, soap_flag_fileName = 1, soap_flag_startFilePos = 1, soap_flag_neededSize = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct aklwngt__klft_GetNextFileChunk *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_aklwngt__klft_GetNextFileChunk, sizeof(struct aklwngt__klft_GetNextFileChunk), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_aklwngt__klft_GetNextFileChunk(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_szSessionId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "szSessionId", &a->szSessionId, "xsd:string"))
				{	soap_flag_szSessionId = 0;
					continue;
				}
			if (soap_flag_fileName && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__wstring(soap, "fileName", &a->fileName, "xsd:wstring"))
				{	soap_flag_fileName = 0;
					continue;
				}
			if (soap_flag_startFilePos && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__unsignedLong(soap, "startFilePos", &a->startFilePos, "xsd:unsignedLong"))
				{	soap_flag_startFilePos = 0;
					continue;
				}
			if (soap_flag_neededSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__unsignedLong(soap, "neededSize", &a->neededSize, "xsd:unsignedLong"))
				{	soap_flag_neededSize = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_startFilePos || soap_flag_neededSize))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct aklwngt__klft_GetNextFileChunk *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_aklwngt__klft_GetNextFileChunk, 0, sizeof(struct aklwngt__klft_GetNextFileChunk), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_aklwngt__klft_GetNextFileChunkResponse(struct soap *soap, struct aklwngt__klft_GetNextFileChunkResponse const*a)
{
	soap_mark_aklwngt__klft_GetNextFileChunkResponse(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_aklwngt__klft_GetNextFileChunkResponse(struct soap *soap, const struct aklwngt__klft_GetNextFileChunkResponse *a)
{
	soap_embedded(soap, &a->chunk, SOAP_TYPE_aklwngt__klft_file_chunk_t);
	soap_mark_aklwngt__klft_file_chunk_t(soap, &a->chunk);
	soap_embedded(soap, &a->oError, SOAP_TYPE_PointerToparam_error);
	soap_mark_PointerToparam_error(soap, &a->oError);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_aklwngt__klft_GetNextFileChunkResponse(struct soap *soap, struct aklwngt__klft_GetNextFileChunkResponse *a)
{
	soap_default_aklwngt__klft_file_chunk_t(soap, &a->chunk);
	a->oError = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_aklwngt__klft_GetNextFileChunkResponse(struct soap *soap, const struct aklwngt__klft_GetNextFileChunkResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_aklwngt__klft_GetNextFileChunkResponse);
	if (soap_out_aklwngt__klft_GetNextFileChunkResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_aklwngt__klft_GetNextFileChunkResponse(struct soap *soap, const char *tag, int id, const struct aklwngt__klft_GetNextFileChunkResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_aklwngt__klft_GetNextFileChunkResponse), type);
	soap_element_result(soap, "chunk");
	soap_out_aklwngt__klft_file_chunk_t(soap, "chunk", -1, &a->chunk, "");
	soap_out_PointerToparam_error(soap, "oError", -1, &a->oError, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct aklwngt__klft_GetNextFileChunkResponse * SOAP_FMAC4 soap_get_aklwngt__klft_GetNextFileChunkResponse(struct soap *soap, struct aklwngt__klft_GetNextFileChunkResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_aklwngt__klft_GetNextFileChunkResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct aklwngt__klft_GetNextFileChunkResponse * SOAP_FMAC4 soap_in_aklwngt__klft_GetNextFileChunkResponse(struct soap *soap, const char *tag, struct aklwngt__klft_GetNextFileChunkResponse *a, const char *type)
{
	short soap_flag_chunk = 1, soap_flag_oError = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct aklwngt__klft_GetNextFileChunkResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_aklwngt__klft_GetNextFileChunkResponse, sizeof(struct aklwngt__klft_GetNextFileChunkResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_aklwngt__klft_GetNextFileChunkResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_chunk && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_aklwngt__klft_file_chunk_t(soap, "chunk", &a->chunk, "aklwngt:klft-file-chunk-t"))
				{	soap_flag_chunk = 0;
					continue;
				}
			if (soap_flag_oError && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToparam_error(soap, "oError", &a->oError, ""))
				{	soap_flag_oError = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_chunk))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct aklwngt__klft_GetNextFileChunkResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_aklwngt__klft_GetNextFileChunkResponse, 0, sizeof(struct aklwngt__klft_GetNextFileChunkResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_aklwngt__klft_GetFileInfo(struct soap *soap, struct aklwngt__klft_GetFileInfo const*a)
{
	soap_mark_aklwngt__klft_GetFileInfo(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_aklwngt__klft_GetFileInfo(struct soap *soap, const struct aklwngt__klft_GetFileInfo *a)
{
	soap_embedded(soap, &a->szSessionId, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->szSessionId);
	soap_embedded(soap, &a->fileName, SOAP_TYPE_xsd__wstring);
	soap_mark_xsd__wstring(soap, &a->fileName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_aklwngt__klft_GetFileInfo(struct soap *soap, struct aklwngt__klft_GetFileInfo *a)
{
	a->szSessionId = NULL;
	a->fileName = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_aklwngt__klft_GetFileInfo(struct soap *soap, const struct aklwngt__klft_GetFileInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_aklwngt__klft_GetFileInfo);
	if (soap_out_aklwngt__klft_GetFileInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_aklwngt__klft_GetFileInfo(struct soap *soap, const char *tag, int id, const struct aklwngt__klft_GetFileInfo *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_aklwngt__klft_GetFileInfo), type);
	soap_out_xsd__string(soap, "szSessionId", -1, &a->szSessionId, "");
	soap_out_xsd__wstring(soap, "fileName", -1, &a->fileName, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct aklwngt__klft_GetFileInfo * SOAP_FMAC4 soap_get_aklwngt__klft_GetFileInfo(struct soap *soap, struct aklwngt__klft_GetFileInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_aklwngt__klft_GetFileInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct aklwngt__klft_GetFileInfo * SOAP_FMAC4 soap_in_aklwngt__klft_GetFileInfo(struct soap *soap, const char *tag, struct aklwngt__klft_GetFileInfo *a, const char *type)
{
	short soap_flag_szSessionId = 1, soap_flag_fileName = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct aklwngt__klft_GetFileInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_aklwngt__klft_GetFileInfo, sizeof(struct aklwngt__klft_GetFileInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_aklwngt__klft_GetFileInfo(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_szSessionId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "szSessionId", &a->szSessionId, "xsd:string"))
				{	soap_flag_szSessionId = 0;
					continue;
				}
			if (soap_flag_fileName && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__wstring(soap, "fileName", &a->fileName, "xsd:wstring"))
				{	soap_flag_fileName = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct aklwngt__klft_GetFileInfo *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_aklwngt__klft_GetFileInfo, 0, sizeof(struct aklwngt__klft_GetFileInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_aklwngt__klft_GetFileInfoResponse(struct soap *soap, struct aklwngt__klft_GetFileInfoResponse const*a)
{
	soap_mark_aklwngt__klft_GetFileInfoResponse(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_aklwngt__klft_GetFileInfoResponse(struct soap *soap, const struct aklwngt__klft_GetFileInfoResponse *a)
{
	soap_embedded(soap, &a->info, SOAP_TYPE_aklwngt__klft_file_info_t);
	soap_mark_aklwngt__klft_file_info_t(soap, &a->info);
	soap_embedded(soap, &a->oError, SOAP_TYPE_PointerToparam_error);
	soap_mark_PointerToparam_error(soap, &a->oError);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_aklwngt__klft_GetFileInfoResponse(struct soap *soap, struct aklwngt__klft_GetFileInfoResponse *a)
{
	soap_default_aklwngt__klft_file_info_t(soap, &a->info);
	a->oError = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_aklwngt__klft_GetFileInfoResponse(struct soap *soap, const struct aklwngt__klft_GetFileInfoResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_aklwngt__klft_GetFileInfoResponse);
	if (soap_out_aklwngt__klft_GetFileInfoResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_aklwngt__klft_GetFileInfoResponse(struct soap *soap, const char *tag, int id, const struct aklwngt__klft_GetFileInfoResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_aklwngt__klft_GetFileInfoResponse), type);
	soap_element_result(soap, "info");
	soap_out_aklwngt__klft_file_info_t(soap, "info", -1, &a->info, "");
	soap_out_PointerToparam_error(soap, "oError", -1, &a->oError, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct aklwngt__klft_GetFileInfoResponse * SOAP_FMAC4 soap_get_aklwngt__klft_GetFileInfoResponse(struct soap *soap, struct aklwngt__klft_GetFileInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_aklwngt__klft_GetFileInfoResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct aklwngt__klft_GetFileInfoResponse * SOAP_FMAC4 soap_in_aklwngt__klft_GetFileInfoResponse(struct soap *soap, const char *tag, struct aklwngt__klft_GetFileInfoResponse *a, const char *type)
{
	short soap_flag_info = 1, soap_flag_oError = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct aklwngt__klft_GetFileInfoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_aklwngt__klft_GetFileInfoResponse, sizeof(struct aklwngt__klft_GetFileInfoResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_aklwngt__klft_GetFileInfoResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_info && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_aklwngt__klft_file_info_t(soap, "info", &a->info, "aklwngt:klft-file-info-t"))
				{	soap_flag_info = 0;
					continue;
				}
			if (soap_flag_oError && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToparam_error(soap, "oError", &a->oError, ""))
				{	soap_flag_oError = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_info))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct aklwngt__klft_GetFileInfoResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_aklwngt__klft_GetFileInfoResponse, 0, sizeof(struct aklwngt__klft_GetFileInfoResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_aklwngt__PutEvents(struct soap *soap, struct aklwngt__PutEvents const*a)
{
	soap_mark_aklwngt__PutEvents(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_aklwngt__PutEvents(struct soap *soap, const struct aklwngt__PutEvents *a)
{
	soap_embedded(soap, &a->szSessionId, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->szSessionId);
	soap_embedded(soap, &a->oEventsInfoArray, SOAP_TYPE_PointerToaklwngt__event_info_array);
	soap_mark_PointerToaklwngt__event_info_array(soap, &a->oEventsInfoArray);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_aklwngt__PutEvents(struct soap *soap, struct aklwngt__PutEvents *a)
{
	a->szSessionId = NULL;
	a->oEventsInfoArray = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_aklwngt__PutEvents(struct soap *soap, const struct aklwngt__PutEvents *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_aklwngt__PutEvents);
	if (soap_out_aklwngt__PutEvents(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_aklwngt__PutEvents(struct soap *soap, const char *tag, int id, const struct aklwngt__PutEvents *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_aklwngt__PutEvents), type);
	soap_out_xsd__string(soap, "szSessionId", -1, &a->szSessionId, "");
	soap_out_PointerToaklwngt__event_info_array(soap, "oEventsInfoArray", -1, &a->oEventsInfoArray, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct aklwngt__PutEvents * SOAP_FMAC4 soap_get_aklwngt__PutEvents(struct soap *soap, struct aklwngt__PutEvents *p, const char *tag, const char *type)
{
	if ((p = soap_in_aklwngt__PutEvents(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct aklwngt__PutEvents * SOAP_FMAC4 soap_in_aklwngt__PutEvents(struct soap *soap, const char *tag, struct aklwngt__PutEvents *a, const char *type)
{
	short soap_flag_szSessionId = 1, soap_flag_oEventsInfoArray = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct aklwngt__PutEvents *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_aklwngt__PutEvents, sizeof(struct aklwngt__PutEvents), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_aklwngt__PutEvents(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_szSessionId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "szSessionId", &a->szSessionId, "xsd:string"))
				{	soap_flag_szSessionId = 0;
					continue;
				}
			if (soap_flag_oEventsInfoArray && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToaklwngt__event_info_array(soap, "oEventsInfoArray", &a->oEventsInfoArray, "aklwngt:event-info-array"))
				{	soap_flag_oEventsInfoArray = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct aklwngt__PutEvents *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_aklwngt__PutEvents, 0, sizeof(struct aklwngt__PutEvents), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_aklwngt__PutEventsResponse(struct soap *soap, struct aklwngt__PutEventsResponse const*a)
{
	soap_mark_aklwngt__PutEventsResponse(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_aklwngt__PutEventsResponse(struct soap *soap, const struct aklwngt__PutEventsResponse *a)
{
	soap_embedded(soap, &a->oError, SOAP_TYPE_PointerToparam_error);
	soap_mark_PointerToparam_error(soap, &a->oError);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_aklwngt__PutEventsResponse(struct soap *soap, struct aklwngt__PutEventsResponse *a)
{
	a->oError = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_aklwngt__PutEventsResponse(struct soap *soap, const struct aklwngt__PutEventsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_aklwngt__PutEventsResponse);
	if (soap_out_aklwngt__PutEventsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_aklwngt__PutEventsResponse(struct soap *soap, const char *tag, int id, const struct aklwngt__PutEventsResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_aklwngt__PutEventsResponse), type);
	if (a->oError)
		soap_element_result(soap, "oError");
	soap_out_PointerToparam_error(soap, "oError", -1, &a->oError, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct aklwngt__PutEventsResponse * SOAP_FMAC4 soap_get_aklwngt__PutEventsResponse(struct soap *soap, struct aklwngt__PutEventsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_aklwngt__PutEventsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct aklwngt__PutEventsResponse * SOAP_FMAC4 soap_in_aklwngt__PutEventsResponse(struct soap *soap, const char *tag, struct aklwngt__PutEventsResponse *a, const char *type)
{
	short soap_flag_oError = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct aklwngt__PutEventsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_aklwngt__PutEventsResponse, sizeof(struct aklwngt__PutEventsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_aklwngt__PutEventsResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_oError && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToparam_error(soap, "oError", &a->oError, ""))
				{	soap_flag_oError = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct aklwngt__PutEventsResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_aklwngt__PutEventsResponse, 0, sizeof(struct aklwngt__PutEventsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_aklwngt__PutResult(struct soap *soap, struct aklwngt__PutResult const*a)
{
	soap_mark_aklwngt__PutResult(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_aklwngt__PutResult(struct soap *soap, const struct aklwngt__PutResult *a)
{
	soap_embedded(soap, &a->szSessionId, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->szSessionId);
	soap_embedded(soap, &a->result, SOAP_TYPE_PointerToaklwngt__command);
	soap_mark_PointerToaklwngt__command(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_aklwngt__PutResult(struct soap *soap, struct aklwngt__PutResult *a)
{
	a->szSessionId = NULL;
	a->result = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_aklwngt__PutResult(struct soap *soap, const struct aklwngt__PutResult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_aklwngt__PutResult);
	if (soap_out_aklwngt__PutResult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_aklwngt__PutResult(struct soap *soap, const char *tag, int id, const struct aklwngt__PutResult *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_aklwngt__PutResult), type);
	soap_out_xsd__string(soap, "szSessionId", -1, &a->szSessionId, "");
	soap_out_PointerToaklwngt__command(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct aklwngt__PutResult * SOAP_FMAC4 soap_get_aklwngt__PutResult(struct soap *soap, struct aklwngt__PutResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_aklwngt__PutResult(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct aklwngt__PutResult * SOAP_FMAC4 soap_in_aklwngt__PutResult(struct soap *soap, const char *tag, struct aklwngt__PutResult *a, const char *type)
{
	short soap_flag_szSessionId = 1, soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct aklwngt__PutResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_aklwngt__PutResult, sizeof(struct aklwngt__PutResult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_aklwngt__PutResult(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_szSessionId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "szSessionId", &a->szSessionId, "xsd:string"))
				{	soap_flag_szSessionId = 0;
					continue;
				}
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToaklwngt__command(soap, "result", &a->result, "aklwngt:command"))
				{	soap_flag_result = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct aklwngt__PutResult *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_aklwngt__PutResult, 0, sizeof(struct aklwngt__PutResult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_aklwngt__PutResultResponse(struct soap *soap, struct aklwngt__PutResultResponse const*a)
{
	soap_mark_aklwngt__PutResultResponse(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_aklwngt__PutResultResponse(struct soap *soap, const struct aklwngt__PutResultResponse *a)
{
	soap_embedded(soap, &a->oNextCommand, SOAP_TYPE_aklwngt__command);
	soap_mark_aklwngt__command(soap, &a->oNextCommand);
	soap_embedded(soap, &a->oError, SOAP_TYPE_PointerToparam_error);
	soap_mark_PointerToparam_error(soap, &a->oError);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_aklwngt__PutResultResponse(struct soap *soap, struct aklwngt__PutResultResponse *a)
{
	soap_default_aklwngt__command(soap, &a->oNextCommand);
	a->oError = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_aklwngt__PutResultResponse(struct soap *soap, const struct aklwngt__PutResultResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_aklwngt__PutResultResponse);
	if (soap_out_aklwngt__PutResultResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_aklwngt__PutResultResponse(struct soap *soap, const char *tag, int id, const struct aklwngt__PutResultResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_aklwngt__PutResultResponse), type);
	soap_element_result(soap, "oNextCommand");
	soap_out_aklwngt__command(soap, "oNextCommand", -1, &a->oNextCommand, "");
	soap_out_PointerToparam_error(soap, "oError", -1, &a->oError, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct aklwngt__PutResultResponse * SOAP_FMAC4 soap_get_aklwngt__PutResultResponse(struct soap *soap, struct aklwngt__PutResultResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_aklwngt__PutResultResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct aklwngt__PutResultResponse * SOAP_FMAC4 soap_in_aklwngt__PutResultResponse(struct soap *soap, const char *tag, struct aklwngt__PutResultResponse *a, const char *type)
{
	short soap_flag_oNextCommand = 1, soap_flag_oError = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct aklwngt__PutResultResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_aklwngt__PutResultResponse, sizeof(struct aklwngt__PutResultResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_aklwngt__PutResultResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_oNextCommand && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_aklwngt__command(soap, "oNextCommand", &a->oNextCommand, "aklwngt:command"))
				{	soap_flag_oNextCommand = 0;
					continue;
				}
			if (soap_flag_oError && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToparam_error(soap, "oError", &a->oError, ""))
				{	soap_flag_oError = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_oNextCommand))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct aklwngt__PutResultResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_aklwngt__PutResultResponse, 0, sizeof(struct aklwngt__PutResultResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_aklwngt__Heartbeat(struct soap *soap, struct aklwngt__Heartbeat const*a)
{
	soap_mark_aklwngt__Heartbeat(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_aklwngt__Heartbeat(struct soap *soap, const struct aklwngt__Heartbeat *a)
{
	soap_embedded(soap, &a->szSessionId, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->szSessionId);
	soap_embedded(soap, &a->oMaySynchronize, SOAP_TYPE_PointerToaklwngt__sync_info);
	soap_mark_PointerToaklwngt__sync_info(soap, &a->oMaySynchronize);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_aklwngt__Heartbeat(struct soap *soap, struct aklwngt__Heartbeat *a)
{
	a->szSessionId = NULL;
	a->oMaySynchronize = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_aklwngt__Heartbeat(struct soap *soap, const struct aklwngt__Heartbeat *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_aklwngt__Heartbeat);
	if (soap_out_aklwngt__Heartbeat(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_aklwngt__Heartbeat(struct soap *soap, const char *tag, int id, const struct aklwngt__Heartbeat *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_aklwngt__Heartbeat), type);
	soap_out_xsd__string(soap, "szSessionId", -1, &a->szSessionId, "");
	soap_out_PointerToaklwngt__sync_info(soap, "oMaySynchronize", -1, &a->oMaySynchronize, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct aklwngt__Heartbeat * SOAP_FMAC4 soap_get_aklwngt__Heartbeat(struct soap *soap, struct aklwngt__Heartbeat *p, const char *tag, const char *type)
{
	if ((p = soap_in_aklwngt__Heartbeat(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct aklwngt__Heartbeat * SOAP_FMAC4 soap_in_aklwngt__Heartbeat(struct soap *soap, const char *tag, struct aklwngt__Heartbeat *a, const char *type)
{
	short soap_flag_szSessionId = 1, soap_flag_oMaySynchronize = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct aklwngt__Heartbeat *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_aklwngt__Heartbeat, sizeof(struct aklwngt__Heartbeat), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_aklwngt__Heartbeat(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_szSessionId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "szSessionId", &a->szSessionId, "xsd:string"))
				{	soap_flag_szSessionId = 0;
					continue;
				}
			if (soap_flag_oMaySynchronize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToaklwngt__sync_info(soap, "oMaySynchronize", &a->oMaySynchronize, "aklwngt:sync-info"))
				{	soap_flag_oMaySynchronize = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct aklwngt__Heartbeat *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_aklwngt__Heartbeat, 0, sizeof(struct aklwngt__Heartbeat), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_aklwngt__HeartbeatResponse(struct soap *soap, struct aklwngt__HeartbeatResponse const*a)
{
	soap_mark_aklwngt__HeartbeatResponse(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_aklwngt__HeartbeatResponse(struct soap *soap, const struct aklwngt__HeartbeatResponse *a)
{
	soap_embedded(soap, &a->oCommand, SOAP_TYPE_aklwngt__command);
	soap_mark_aklwngt__command(soap, &a->oCommand);
	soap_embedded(soap, &a->oError, SOAP_TYPE_PointerToparam_error);
	soap_mark_PointerToparam_error(soap, &a->oError);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_aklwngt__HeartbeatResponse(struct soap *soap, struct aklwngt__HeartbeatResponse *a)
{
	soap_default_aklwngt__command(soap, &a->oCommand);
	a->oError = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_aklwngt__HeartbeatResponse(struct soap *soap, const struct aklwngt__HeartbeatResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_aklwngt__HeartbeatResponse);
	if (soap_out_aklwngt__HeartbeatResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_aklwngt__HeartbeatResponse(struct soap *soap, const char *tag, int id, const struct aklwngt__HeartbeatResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_aklwngt__HeartbeatResponse), type);
	soap_element_result(soap, "oCommand");
	soap_out_aklwngt__command(soap, "oCommand", -1, &a->oCommand, "");
	soap_out_PointerToparam_error(soap, "oError", -1, &a->oError, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct aklwngt__HeartbeatResponse * SOAP_FMAC4 soap_get_aklwngt__HeartbeatResponse(struct soap *soap, struct aklwngt__HeartbeatResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_aklwngt__HeartbeatResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct aklwngt__HeartbeatResponse * SOAP_FMAC4 soap_in_aklwngt__HeartbeatResponse(struct soap *soap, const char *tag, struct aklwngt__HeartbeatResponse *a, const char *type)
{
	short soap_flag_oCommand = 1, soap_flag_oError = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct aklwngt__HeartbeatResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_aklwngt__HeartbeatResponse, sizeof(struct aklwngt__HeartbeatResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_aklwngt__HeartbeatResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_oCommand && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_aklwngt__command(soap, "oCommand", &a->oCommand, "aklwngt:command"))
				{	soap_flag_oCommand = 0;
					continue;
				}
			if (soap_flag_oError && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToparam_error(soap, "oError", &a->oError, ""))
				{	soap_flag_oError = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_oCommand))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct aklwngt__HeartbeatResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_aklwngt__HeartbeatResponse, 0, sizeof(struct aklwngt__HeartbeatResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_aklwngt__SessionEnd(struct soap *soap, struct aklwngt__SessionEnd const*a)
{
	soap_mark_aklwngt__SessionEnd(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_aklwngt__SessionEnd(struct soap *soap, const struct aklwngt__SessionEnd *a)
{
	soap_embedded(soap, &a->szSessionId, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->szSessionId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_aklwngt__SessionEnd(struct soap *soap, struct aklwngt__SessionEnd *a)
{
	a->szSessionId = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_aklwngt__SessionEnd(struct soap *soap, const struct aklwngt__SessionEnd *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_aklwngt__SessionEnd);
	if (soap_out_aklwngt__SessionEnd(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_aklwngt__SessionEnd(struct soap *soap, const char *tag, int id, const struct aklwngt__SessionEnd *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_aklwngt__SessionEnd), type);
	soap_out_xsd__string(soap, "szSessionId", -1, &a->szSessionId, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct aklwngt__SessionEnd * SOAP_FMAC4 soap_get_aklwngt__SessionEnd(struct soap *soap, struct aklwngt__SessionEnd *p, const char *tag, const char *type)
{
	if ((p = soap_in_aklwngt__SessionEnd(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct aklwngt__SessionEnd * SOAP_FMAC4 soap_in_aklwngt__SessionEnd(struct soap *soap, const char *tag, struct aklwngt__SessionEnd *a, const char *type)
{
	short soap_flag_szSessionId = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct aklwngt__SessionEnd *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_aklwngt__SessionEnd, sizeof(struct aklwngt__SessionEnd), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_aklwngt__SessionEnd(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_szSessionId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "szSessionId", &a->szSessionId, "xsd:string"))
				{	soap_flag_szSessionId = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct aklwngt__SessionEnd *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_aklwngt__SessionEnd, 0, sizeof(struct aklwngt__SessionEnd), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_aklwngt__SessionEndResponse(struct soap *soap, struct aklwngt__SessionEndResponse const*a)
{
	soap_mark_aklwngt__SessionEndResponse(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_aklwngt__SessionEndResponse(struct soap *soap, const struct aklwngt__SessionEndResponse *a)
{
	soap_embedded(soap, &a->oError, SOAP_TYPE_PointerToparam_error);
	soap_mark_PointerToparam_error(soap, &a->oError);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_aklwngt__SessionEndResponse(struct soap *soap, struct aklwngt__SessionEndResponse *a)
{
	a->oError = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_aklwngt__SessionEndResponse(struct soap *soap, const struct aklwngt__SessionEndResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_aklwngt__SessionEndResponse);
	if (soap_out_aklwngt__SessionEndResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_aklwngt__SessionEndResponse(struct soap *soap, const char *tag, int id, const struct aklwngt__SessionEndResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_aklwngt__SessionEndResponse), type);
	if (a->oError)
		soap_element_result(soap, "oError");
	soap_out_PointerToparam_error(soap, "oError", -1, &a->oError, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct aklwngt__SessionEndResponse * SOAP_FMAC4 soap_get_aklwngt__SessionEndResponse(struct soap *soap, struct aklwngt__SessionEndResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_aklwngt__SessionEndResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct aklwngt__SessionEndResponse * SOAP_FMAC4 soap_in_aklwngt__SessionEndResponse(struct soap *soap, const char *tag, struct aklwngt__SessionEndResponse *a, const char *type)
{
	short soap_flag_oError = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct aklwngt__SessionEndResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_aklwngt__SessionEndResponse, sizeof(struct aklwngt__SessionEndResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_aklwngt__SessionEndResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_oError && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToparam_error(soap, "oError", &a->oError, ""))
				{	soap_flag_oError = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct aklwngt__SessionEndResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_aklwngt__SessionEndResponse, 0, sizeof(struct aklwngt__SessionEndResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_aklwngt__SessionBegin(struct soap *soap, struct aklwngt__SessionBegin const*a)
{
	soap_mark_aklwngt__SessionBegin(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_aklwngt__SessionBegin(struct soap *soap, const struct aklwngt__SessionBegin *a)
{
	soap_embedded(soap, &a->szDeviceId, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->szDeviceId);
	soap_embedded(soap, &a->szPassword, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->szPassword);
	soap_embedded(soap, &a->nProtocolVersion, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_aklwngt__SessionBegin(struct soap *soap, struct aklwngt__SessionBegin *a)
{
	a->szDeviceId = NULL;
	a->szPassword = NULL;
	soap_default_int(soap, &a->nProtocolVersion);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_aklwngt__SessionBegin(struct soap *soap, const struct aklwngt__SessionBegin *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_aklwngt__SessionBegin);
	if (soap_out_aklwngt__SessionBegin(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_aklwngt__SessionBegin(struct soap *soap, const char *tag, int id, const struct aklwngt__SessionBegin *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_aklwngt__SessionBegin), type);
	soap_out_xsd__string(soap, "szDeviceId", -1, &a->szDeviceId, "");
	soap_out_xsd__string(soap, "szPassword", -1, &a->szPassword, "");
	soap_out_int(soap, "nProtocolVersion", -1, &a->nProtocolVersion, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct aklwngt__SessionBegin * SOAP_FMAC4 soap_get_aklwngt__SessionBegin(struct soap *soap, struct aklwngt__SessionBegin *p, const char *tag, const char *type)
{
	if ((p = soap_in_aklwngt__SessionBegin(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct aklwngt__SessionBegin * SOAP_FMAC4 soap_in_aklwngt__SessionBegin(struct soap *soap, const char *tag, struct aklwngt__SessionBegin *a, const char *type)
{
	short soap_flag_szDeviceId = 1, soap_flag_szPassword = 1, soap_flag_nProtocolVersion = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct aklwngt__SessionBegin *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_aklwngt__SessionBegin, sizeof(struct aklwngt__SessionBegin), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_aklwngt__SessionBegin(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_szDeviceId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "szDeviceId", &a->szDeviceId, "xsd:string"))
				{	soap_flag_szDeviceId = 0;
					continue;
				}
			if (soap_flag_szPassword && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "szPassword", &a->szPassword, "xsd:string"))
				{	soap_flag_szPassword = 0;
					continue;
				}
			if (soap_flag_nProtocolVersion && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nProtocolVersion", &a->nProtocolVersion, ""))
				{	soap_flag_nProtocolVersion = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_nProtocolVersion))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct aklwngt__SessionBegin *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_aklwngt__SessionBegin, 0, sizeof(struct aklwngt__SessionBegin), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_aklwngt__SessionBeginResponse(struct soap *soap, struct aklwngt__SessionBeginResponse const*a)
{
	soap_mark_aklwngt__SessionBeginResponse(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_aklwngt__SessionBeginResponse(struct soap *soap, const struct aklwngt__SessionBeginResponse *a)
{
	soap_embedded(soap, &a->szSessionId, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->szSessionId);
	soap_embedded(soap, &a->nProtocolVersion, SOAP_TYPE_int);
	soap_embedded(soap, &a->oError, SOAP_TYPE_PointerToparam_error);
	soap_mark_PointerToparam_error(soap, &a->oError);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_aklwngt__SessionBeginResponse(struct soap *soap, struct aklwngt__SessionBeginResponse *a)
{
	a->szSessionId = NULL;
	soap_default_int(soap, &a->nProtocolVersion);
	a->oError = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_aklwngt__SessionBeginResponse(struct soap *soap, const struct aklwngt__SessionBeginResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_aklwngt__SessionBeginResponse);
	if (soap_out_aklwngt__SessionBeginResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_aklwngt__SessionBeginResponse(struct soap *soap, const char *tag, int id, const struct aklwngt__SessionBeginResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_aklwngt__SessionBeginResponse), type);
	if (a->szSessionId)
		soap_element_result(soap, "szSessionId");
	soap_out_xsd__string(soap, "szSessionId", -1, &a->szSessionId, "");
	soap_out_int(soap, "nProtocolVersion", -1, &a->nProtocolVersion, "");
	soap_out_PointerToparam_error(soap, "oError", -1, &a->oError, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct aklwngt__SessionBeginResponse * SOAP_FMAC4 soap_get_aklwngt__SessionBeginResponse(struct soap *soap, struct aklwngt__SessionBeginResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_aklwngt__SessionBeginResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct aklwngt__SessionBeginResponse * SOAP_FMAC4 soap_in_aklwngt__SessionBeginResponse(struct soap *soap, const char *tag, struct aklwngt__SessionBeginResponse *a, const char *type)
{
	short soap_flag_szSessionId = 1, soap_flag_nProtocolVersion = 1, soap_flag_oError = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct aklwngt__SessionBeginResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_aklwngt__SessionBeginResponse, sizeof(struct aklwngt__SessionBeginResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_aklwngt__SessionBeginResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_szSessionId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "szSessionId", &a->szSessionId, "xsd:string"))
				{	soap_flag_szSessionId = 0;
					continue;
				}
			if (soap_flag_nProtocolVersion && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nProtocolVersion", &a->nProtocolVersion, ""))
				{	soap_flag_nProtocolVersion = 0;
					continue;
				}
			if (soap_flag_oError && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToparam_error(soap, "oError", &a->oError, ""))
				{	soap_flag_oError = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_nProtocolVersion))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct aklwngt__SessionBeginResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_aklwngt__SessionBeginResponse, 0, sizeof(struct aklwngt__SessionBeginResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_aklwngt__klft_file_info_t(struct soap *soap, struct aklwngt__klft_file_info_t const*a)
{
	soap_mark_aklwngt__klft_file_info_t(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_aklwngt__klft_file_info_t(struct soap *soap, const struct aklwngt__klft_file_info_t *a)
{
	soap_embedded(soap, &a->fileName, SOAP_TYPE_xsd__wstring);
	soap_mark_xsd__wstring(soap, &a->fileName);
	soap_embedded(soap, &a->isDir, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->readPermission, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->createTime, SOAP_TYPE_xsd__dateTime);
	soap_mark_xsd__dateTime(soap, &a->createTime);
	soap_embedded(soap, &a->fullFileSize, SOAP_TYPE_xsd__unsignedLong);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_aklwngt__klft_file_info_t(struct soap *soap, struct aklwngt__klft_file_info_t *a)
{
	a->fileName = NULL;
	soap_default_xsd__boolean(soap, &a->isDir);
	soap_default_xsd__boolean(soap, &a->readPermission);
	a->createTime = NULL;
	soap_default_xsd__unsignedLong(soap, &a->fullFileSize);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_aklwngt__klft_file_info_t(struct soap *soap, const struct aklwngt__klft_file_info_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_aklwngt__klft_file_info_t);
	if (soap_out_aklwngt__klft_file_info_t(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_aklwngt__klft_file_info_t(struct soap *soap, const char *tag, int id, const struct aklwngt__klft_file_info_t *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_aklwngt__klft_file_info_t), type);
	soap_out_xsd__wstring(soap, "fileName", -1, &a->fileName, "");
	soap_out_xsd__boolean(soap, "isDir", -1, &a->isDir, "");
	soap_out_xsd__boolean(soap, "readPermission", -1, &a->readPermission, "");
	soap_out_xsd__dateTime(soap, "createTime", -1, &a->createTime, "");
	soap_out_xsd__unsignedLong(soap, "fullFileSize", -1, &a->fullFileSize, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct aklwngt__klft_file_info_t * SOAP_FMAC4 soap_get_aklwngt__klft_file_info_t(struct soap *soap, struct aklwngt__klft_file_info_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_aklwngt__klft_file_info_t(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct aklwngt__klft_file_info_t * SOAP_FMAC4 soap_in_aklwngt__klft_file_info_t(struct soap *soap, const char *tag, struct aklwngt__klft_file_info_t *a, const char *type)
{
	short soap_flag_fileName = 1, soap_flag_isDir = 1, soap_flag_readPermission = 1, soap_flag_createTime = 1, soap_flag_fullFileSize = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct aklwngt__klft_file_info_t *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_aklwngt__klft_file_info_t, sizeof(struct aklwngt__klft_file_info_t), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_aklwngt__klft_file_info_t(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fileName && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__wstring(soap, "fileName", &a->fileName, "xsd:wstring"))
				{	soap_flag_fileName = 0;
					continue;
				}
			if (soap_flag_isDir && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "isDir", &a->isDir, "xsd:boolean"))
				{	soap_flag_isDir = 0;
					continue;
				}
			if (soap_flag_readPermission && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "readPermission", &a->readPermission, "xsd:boolean"))
				{	soap_flag_readPermission = 0;
					continue;
				}
			if (soap_flag_createTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__dateTime(soap, "createTime", &a->createTime, "xsd:dateTime"))
				{	soap_flag_createTime = 0;
					continue;
				}
			if (soap_flag_fullFileSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__unsignedLong(soap, "fullFileSize", &a->fullFileSize, "xsd:unsignedLong"))
				{	soap_flag_fullFileSize = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_isDir || soap_flag_readPermission || soap_flag_fullFileSize))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct aklwngt__klft_file_info_t *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_aklwngt__klft_file_info_t, 0, sizeof(struct aklwngt__klft_file_info_t), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_aklwngt__klft_file_chunk_t(struct soap *soap, struct aklwngt__klft_file_chunk_t const*a)
{
	soap_mark_aklwngt__klft_file_chunk_t(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_aklwngt__klft_file_chunk_t(struct soap *soap, const struct aklwngt__klft_file_chunk_t *a)
{
	soap_embedded(soap, &a->fileName, SOAP_TYPE_xsd__wstring);
	soap_mark_xsd__wstring(soap, &a->fileName);
	soap_embedded(soap, &a->CRC, SOAP_TYPE_xsd__unsignedLong);
	soap_embedded(soap, &a->startPosInFile, SOAP_TYPE_xsd__unsignedLong);
	soap_embedded(soap, &a->fullFileSize, SOAP_TYPE_xsd__unsignedLong);
	soap_embedded(soap, &a->buff, SOAP_TYPE_aklwngt__klft_file_chunk_buff);
	soap_mark_aklwngt__klft_file_chunk_buff(soap, &a->buff);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_aklwngt__klft_file_chunk_t(struct soap *soap, struct aklwngt__klft_file_chunk_t *a)
{
	a->fileName = NULL;
	soap_default_xsd__unsignedLong(soap, &a->CRC);
	soap_default_xsd__unsignedLong(soap, &a->startPosInFile);
	soap_default_xsd__unsignedLong(soap, &a->fullFileSize);
	soap_default_aklwngt__klft_file_chunk_buff(soap, &a->buff);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_aklwngt__klft_file_chunk_t(struct soap *soap, const struct aklwngt__klft_file_chunk_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_aklwngt__klft_file_chunk_t);
	if (soap_out_aklwngt__klft_file_chunk_t(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_aklwngt__klft_file_chunk_t(struct soap *soap, const char *tag, int id, const struct aklwngt__klft_file_chunk_t *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_aklwngt__klft_file_chunk_t), type);
	soap_out_xsd__wstring(soap, "fileName", -1, &a->fileName, "");
	soap_out_xsd__unsignedLong(soap, "CRC", -1, &a->CRC, "");
	soap_out_xsd__unsignedLong(soap, "startPosInFile", -1, &a->startPosInFile, "");
	soap_out_xsd__unsignedLong(soap, "fullFileSize", -1, &a->fullFileSize, "");
	soap_out_aklwngt__klft_file_chunk_buff(soap, "buff", -1, &a->buff, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct aklwngt__klft_file_chunk_t * SOAP_FMAC4 soap_get_aklwngt__klft_file_chunk_t(struct soap *soap, struct aklwngt__klft_file_chunk_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_aklwngt__klft_file_chunk_t(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct aklwngt__klft_file_chunk_t * SOAP_FMAC4 soap_in_aklwngt__klft_file_chunk_t(struct soap *soap, const char *tag, struct aklwngt__klft_file_chunk_t *a, const char *type)
{
	short soap_flag_fileName = 1, soap_flag_CRC = 1, soap_flag_startPosInFile = 1, soap_flag_fullFileSize = 1, soap_flag_buff = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct aklwngt__klft_file_chunk_t *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_aklwngt__klft_file_chunk_t, sizeof(struct aklwngt__klft_file_chunk_t), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_aklwngt__klft_file_chunk_t(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fileName && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__wstring(soap, "fileName", &a->fileName, "xsd:wstring"))
				{	soap_flag_fileName = 0;
					continue;
				}
			if (soap_flag_CRC && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__unsignedLong(soap, "CRC", &a->CRC, "xsd:unsignedLong"))
				{	soap_flag_CRC = 0;
					continue;
				}
			if (soap_flag_startPosInFile && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__unsignedLong(soap, "startPosInFile", &a->startPosInFile, "xsd:unsignedLong"))
				{	soap_flag_startPosInFile = 0;
					continue;
				}
			if (soap_flag_fullFileSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__unsignedLong(soap, "fullFileSize", &a->fullFileSize, "xsd:unsignedLong"))
				{	soap_flag_fullFileSize = 0;
					continue;
				}
			if (soap_flag_buff && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_aklwngt__klft_file_chunk_buff(soap, "buff", &a->buff, "aklwngt:klft-file-chunk-buff"))
				{	soap_flag_buff = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CRC || soap_flag_startPosInFile || soap_flag_fullFileSize || soap_flag_buff))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct aklwngt__klft_file_chunk_t *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_aklwngt__klft_file_chunk_t, 0, sizeof(struct aklwngt__klft_file_chunk_t), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_aklwngt__klft_file_chunk_buff(struct soap *soap, struct aklwngt__klft_file_chunk_buff const*a)
{
	soap_mark_aklwngt__klft_file_chunk_buff(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_aklwngt__klft_file_chunk_buff(struct soap *soap, struct aklwngt__klft_file_chunk_buff const*a)
{
	if (a->__ptr)
		soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_aklwngt__klft_file_chunk_buff);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_aklwngt__klft_file_chunk_buff(struct soap *soap, struct aklwngt__klft_file_chunk_buff *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_aklwngt__klft_file_chunk_buff(struct soap *soap, const struct aklwngt__klft_file_chunk_buff *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_aklwngt__klft_file_chunk_buff);
	if (soap_out_aklwngt__klft_file_chunk_buff(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_aklwngt__klft_file_chunk_buff(struct soap *soap, const char *tag, int id, const struct aklwngt__klft_file_chunk_buff *a, const char *type)
{
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_aklwngt__klft_file_chunk_buff);
	if (id < 0)
		return soap->error;
	soap_element_begin_out(soap, tag, id, type);
	soap_putbase64(soap, a->__ptr, a->__size);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct aklwngt__klft_file_chunk_buff * SOAP_FMAC4 soap_get_aklwngt__klft_file_chunk_buff(struct soap *soap, struct aklwngt__klft_file_chunk_buff *p, const char *tag, const char *type)
{
	if ((p = soap_in_aklwngt__klft_file_chunk_buff(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct aklwngt__klft_file_chunk_buff * SOAP_FMAC4 soap_in_aklwngt__klft_file_chunk_buff(struct soap *soap, const char *tag, struct aklwngt__klft_file_chunk_buff *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct aklwngt__klft_file_chunk_buff *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_aklwngt__klft_file_chunk_buff, sizeof(struct aklwngt__klft_file_chunk_buff), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_aklwngt__klft_file_chunk_buff(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct aklwngt__klft_file_chunk_buff *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_aklwngt__klft_file_chunk_buff, 0, sizeof(struct aklwngt__klft_file_chunk_buff), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_aklwngt__event_info_array(struct soap *soap, struct aklwngt__event_info_array const*a)
{
	soap_mark_aklwngt__event_info_array(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_aklwngt__event_info_array(struct soap *soap, struct aklwngt__event_info_array const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_aklwngt__event_info_array))
		for (i = 0; i < a->__size; i++)
		{	soap_embedded(soap, a->__ptr + i, SOAP_TYPE_aklwngt__event_info);
			soap_mark_aklwngt__event_info(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_aklwngt__event_info_array(struct soap *soap, struct aklwngt__event_info_array *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_aklwngt__event_info_array(struct soap *soap, const struct aklwngt__event_info_array *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_aklwngt__event_info_array);
	if (soap_out_aklwngt__event_info_array(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_aklwngt__event_info_array(struct soap *soap, const char *tag, int id, const struct aklwngt__event_info_array *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_aklwngt__event_info_array);
	if (id < 0)
		return soap->error;
	soap_element_begin_out(soap, tag, id, type);
	for (i = 0; i < n; i++)
	{
		soap_out_aklwngt__event_info(soap, "item", -1, &a->__ptr[i], "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct aklwngt__event_info_array * SOAP_FMAC4 soap_get_aklwngt__event_info_array(struct soap *soap, struct aklwngt__event_info_array *p, const char *tag, const char *type)
{
	if ((p = soap_in_aklwngt__event_info_array(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct aklwngt__event_info_array * SOAP_FMAC4 soap_in_aklwngt__event_info_array(struct soap *soap, const char *tag, struct aklwngt__event_info_array *a, const char *type)
{	int i, j;
	struct aklwngt__event_info *p;
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct aklwngt__event_info_array *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_aklwngt__event_info_array, sizeof(struct aklwngt__event_info_array), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_aklwngt__event_info_array(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct aklwngt__event_info *)soap_malloc(soap, sizeof(struct aklwngt__event_info) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_aklwngt__event_info(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_aklwngt__event_info(soap, NULL, a->__ptr + i, "aklwngt:event-info"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (struct aklwngt__event_info *)soap_push_block(soap, sizeof(struct aklwngt__event_info));
				if (!p)
					return NULL;
				soap_default_aklwngt__event_info(soap, p);
				if (!soap_in_aklwngt__event_info(soap, NULL, p, "aklwngt:event-info"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (struct aklwngt__event_info *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct aklwngt__event_info_array *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_aklwngt__event_info_array, 0, sizeof(struct aklwngt__event_info_array), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_aklwngt__event_info(struct soap *soap, struct aklwngt__event_info const*a)
{
	soap_mark_aklwngt__event_info(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_aklwngt__event_info(struct soap *soap, const struct aklwngt__event_info *a)
{
	soap_embedded(soap, &a->eventId, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->eventId);
	soap_embedded(soap, &a->body, SOAP_TYPE_aklwngt__event_body);
	soap_mark_aklwngt__event_body(soap, &a->body);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_aklwngt__event_info(struct soap *soap, struct aklwngt__event_info *a)
{
	a->eventId = NULL;
	soap_default_aklwngt__event_body(soap, &a->body);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_aklwngt__event_info(struct soap *soap, const struct aklwngt__event_info *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_aklwngt__event_info);
	if (soap_out_aklwngt__event_info(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_aklwngt__event_info(struct soap *soap, const char *tag, int id, const struct aklwngt__event_info *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_aklwngt__event_info), type);
	soap_out_xsd__string(soap, "eventId", -1, &a->eventId, "");
	soap_out_aklwngt__event_body(soap, "body", -1, &a->body, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct aklwngt__event_info * SOAP_FMAC4 soap_get_aklwngt__event_info(struct soap *soap, struct aklwngt__event_info *p, const char *tag, const char *type)
{
	if ((p = soap_in_aklwngt__event_info(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct aklwngt__event_info * SOAP_FMAC4 soap_in_aklwngt__event_info(struct soap *soap, const char *tag, struct aklwngt__event_info *a, const char *type)
{
	short soap_flag_eventId = 1, soap_flag_body = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct aklwngt__event_info *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_aklwngt__event_info, sizeof(struct aklwngt__event_info), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_aklwngt__event_info(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eventId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "eventId", &a->eventId, "xsd:string"))
				{	soap_flag_eventId = 0;
					continue;
				}
			if (soap_flag_body && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_aklwngt__event_body(soap, "body", &a->body, "aklwngt:event-body"))
				{	soap_flag_body = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_body))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct aklwngt__event_info *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_aklwngt__event_info, 0, sizeof(struct aklwngt__event_info), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_aklwngt__event_body(struct soap *soap, struct aklwngt__event_body const*a)
{
	soap_mark_aklwngt__event_body(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_aklwngt__event_body(struct soap *soap, const struct aklwngt__event_body *a)
{
	soap_embedded(soap, &a->severity, SOAP_TYPE_xsd__int);
	soap_embedded(soap, &a->product_name, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->product_name);
	soap_embedded(soap, &a->product_version, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->product_version);
	soap_embedded(soap, &a->event_type, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->event_type);
	soap_embedded(soap, &a->event_type_display_name, SOAP_TYPE_xsd__wstring);
	soap_mark_xsd__wstring(soap, &a->event_type_display_name);
	soap_embedded(soap, &a->descr, SOAP_TYPE_xsd__wstring);
	soap_mark_xsd__wstring(soap, &a->descr);
	soap_embedded(soap, &a->locid, SOAP_TYPE_xsd__int);
	soap_embedded(soap, &a->rise_time, SOAP_TYPE_xsd__dateTime);
	soap_mark_xsd__dateTime(soap, &a->rise_time);
	soap_embedded(soap, &a->rise_time_ms, SOAP_TYPE_xsd__int);
	soap_embedded(soap, &a->par1, SOAP_TYPE_xsd__wstring);
	soap_mark_xsd__wstring(soap, &a->par1);
	soap_embedded(soap, &a->par2, SOAP_TYPE_xsd__wstring);
	soap_mark_xsd__wstring(soap, &a->par2);
	soap_embedded(soap, &a->par3, SOAP_TYPE_xsd__wstring);
	soap_mark_xsd__wstring(soap, &a->par3);
	soap_embedded(soap, &a->par4, SOAP_TYPE_xsd__wstring);
	soap_mark_xsd__wstring(soap, &a->par4);
	soap_embedded(soap, &a->par5, SOAP_TYPE_xsd__wstring);
	soap_mark_xsd__wstring(soap, &a->par5);
	soap_embedded(soap, &a->par6, SOAP_TYPE_xsd__wstring);
	soap_mark_xsd__wstring(soap, &a->par6);
	soap_embedded(soap, &a->par7, SOAP_TYPE_xsd__wstring);
	soap_mark_xsd__wstring(soap, &a->par7);
	soap_embedded(soap, &a->par8, SOAP_TYPE_xsd__wstring);
	soap_mark_xsd__wstring(soap, &a->par8);
	soap_embedded(soap, &a->par9, SOAP_TYPE_xsd__wstring);
	soap_mark_xsd__wstring(soap, &a->par9);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_aklwngt__event_body(struct soap *soap, struct aklwngt__event_body *a)
{
	soap_default_xsd__int(soap, &a->severity);
	a->product_name = NULL;
	a->product_version = NULL;
	a->event_type = NULL;
	a->event_type_display_name = NULL;
	a->descr = NULL;
	soap_default_xsd__int(soap, &a->locid);
	a->rise_time = NULL;
	soap_default_xsd__int(soap, &a->rise_time_ms);
	a->par1 = NULL;
	a->par2 = NULL;
	a->par3 = NULL;
	a->par4 = NULL;
	a->par5 = NULL;
	a->par6 = NULL;
	a->par7 = NULL;
	a->par8 = NULL;
	a->par9 = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_aklwngt__event_body(struct soap *soap, const struct aklwngt__event_body *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_aklwngt__event_body);
	if (soap_out_aklwngt__event_body(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_aklwngt__event_body(struct soap *soap, const char *tag, int id, const struct aklwngt__event_body *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_aklwngt__event_body), type);
	soap_out_xsd__int(soap, "severity", -1, &a->severity, "");
	soap_out_xsd__string(soap, "product-name", -1, &a->product_name, "");
	soap_out_xsd__string(soap, "product-version", -1, &a->product_version, "");
	soap_out_xsd__string(soap, "event-type", -1, &a->event_type, "");
	soap_out_xsd__wstring(soap, "event-type-display-name", -1, &a->event_type_display_name, "");
	soap_out_xsd__wstring(soap, "descr", -1, &a->descr, "");
	soap_out_xsd__int(soap, "locid", -1, &a->locid, "");
	soap_out_xsd__dateTime(soap, "rise-time", -1, &a->rise_time, "");
	soap_out_xsd__int(soap, "rise-time-ms", -1, &a->rise_time_ms, "");
	soap_out_xsd__wstring(soap, "par1", -1, &a->par1, "");
	soap_out_xsd__wstring(soap, "par2", -1, &a->par2, "");
	soap_out_xsd__wstring(soap, "par3", -1, &a->par3, "");
	soap_out_xsd__wstring(soap, "par4", -1, &a->par4, "");
	soap_out_xsd__wstring(soap, "par5", -1, &a->par5, "");
	soap_out_xsd__wstring(soap, "par6", -1, &a->par6, "");
	soap_out_xsd__wstring(soap, "par7", -1, &a->par7, "");
	soap_out_xsd__wstring(soap, "par8", -1, &a->par8, "");
	soap_out_xsd__wstring(soap, "par9", -1, &a->par9, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct aklwngt__event_body * SOAP_FMAC4 soap_get_aklwngt__event_body(struct soap *soap, struct aklwngt__event_body *p, const char *tag, const char *type)
{
	if ((p = soap_in_aklwngt__event_body(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct aklwngt__event_body * SOAP_FMAC4 soap_in_aklwngt__event_body(struct soap *soap, const char *tag, struct aklwngt__event_body *a, const char *type)
{
	short soap_flag_severity = 1, soap_flag_product_name = 1, soap_flag_product_version = 1, soap_flag_event_type = 1, soap_flag_event_type_display_name = 1, soap_flag_descr = 1, soap_flag_locid = 1, soap_flag_rise_time = 1, soap_flag_rise_time_ms = 1, soap_flag_par1 = 1, soap_flag_par2 = 1, soap_flag_par3 = 1, soap_flag_par4 = 1, soap_flag_par5 = 1, soap_flag_par6 = 1, soap_flag_par7 = 1, soap_flag_par8 = 1, soap_flag_par9 = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct aklwngt__event_body *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_aklwngt__event_body, sizeof(struct aklwngt__event_body), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_aklwngt__event_body(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_severity && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "severity", &a->severity, "xsd:int"))
				{	soap_flag_severity = 0;
					continue;
				}
			if (soap_flag_product_name && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "product-name", &a->product_name, "xsd:string"))
				{	soap_flag_product_name = 0;
					continue;
				}
			if (soap_flag_product_version && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "product-version", &a->product_version, "xsd:string"))
				{	soap_flag_product_version = 0;
					continue;
				}
			if (soap_flag_event_type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "event-type", &a->event_type, "xsd:string"))
				{	soap_flag_event_type = 0;
					continue;
				}
			if (soap_flag_event_type_display_name && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__wstring(soap, "event-type-display-name", &a->event_type_display_name, "xsd:wstring"))
				{	soap_flag_event_type_display_name = 0;
					continue;
				}
			if (soap_flag_descr && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__wstring(soap, "descr", &a->descr, "xsd:wstring"))
				{	soap_flag_descr = 0;
					continue;
				}
			if (soap_flag_locid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "locid", &a->locid, "xsd:int"))
				{	soap_flag_locid = 0;
					continue;
				}
			if (soap_flag_rise_time && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__dateTime(soap, "rise-time", &a->rise_time, "xsd:dateTime"))
				{	soap_flag_rise_time = 0;
					continue;
				}
			if (soap_flag_rise_time_ms && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "rise-time-ms", &a->rise_time_ms, "xsd:int"))
				{	soap_flag_rise_time_ms = 0;
					continue;
				}
			if (soap_flag_par1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__wstring(soap, "par1", &a->par1, "xsd:wstring"))
				{	soap_flag_par1 = 0;
					continue;
				}
			if (soap_flag_par2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__wstring(soap, "par2", &a->par2, "xsd:wstring"))
				{	soap_flag_par2 = 0;
					continue;
				}
			if (soap_flag_par3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__wstring(soap, "par3", &a->par3, "xsd:wstring"))
				{	soap_flag_par3 = 0;
					continue;
				}
			if (soap_flag_par4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__wstring(soap, "par4", &a->par4, "xsd:wstring"))
				{	soap_flag_par4 = 0;
					continue;
				}
			if (soap_flag_par5 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__wstring(soap, "par5", &a->par5, "xsd:wstring"))
				{	soap_flag_par5 = 0;
					continue;
				}
			if (soap_flag_par6 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__wstring(soap, "par6", &a->par6, "xsd:wstring"))
				{	soap_flag_par6 = 0;
					continue;
				}
			if (soap_flag_par7 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__wstring(soap, "par7", &a->par7, "xsd:wstring"))
				{	soap_flag_par7 = 0;
					continue;
				}
			if (soap_flag_par8 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__wstring(soap, "par8", &a->par8, "xsd:wstring"))
				{	soap_flag_par8 = 0;
					continue;
				}
			if (soap_flag_par9 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__wstring(soap, "par9", &a->par9, "xsd:wstring"))
				{	soap_flag_par9 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_severity || soap_flag_locid || soap_flag_rise_time_ms))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct aklwngt__event_body *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_aklwngt__event_body, 0, sizeof(struct aklwngt__event_body), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_aklwngt__sync_info(struct soap *soap, struct aklwngt__sync_info const*a)
{
	soap_mark_aklwngt__sync_info(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_aklwngt__sync_info(struct soap *soap, const struct aklwngt__sync_info *a)
{
	soap_embedded(soap, &a->hash_stgs, SOAP_TYPE_xsd__base64Binary);
	a->hash_stgs.soap_mark(soap);
	soap_embedded(soap, &a->hash_pol, SOAP_TYPE_xsd__base64Binary);
	a->hash_pol.soap_mark(soap);
	soap_embedded(soap, &a->hash_sbsc, SOAP_TYPE_xsd__base64Binary);
	a->hash_sbsc.soap_mark(soap);
	soap_embedded(soap, &a->hash_info, SOAP_TYPE_xsd__base64Binary);
	a->hash_info.soap_mark(soap);
	soap_embedded(soap, &a->hash_state, SOAP_TYPE_xsd__base64Binary);
	a->hash_state.soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_aklwngt__sync_info(struct soap *soap, struct aklwngt__sync_info *a)
{
	a->hash_stgs.xsd__base64Binary::soap_default(soap);
	a->hash_pol.xsd__base64Binary::soap_default(soap);
	a->hash_sbsc.xsd__base64Binary::soap_default(soap);
	a->hash_info.xsd__base64Binary::soap_default(soap);
	a->hash_state.xsd__base64Binary::soap_default(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_aklwngt__sync_info(struct soap *soap, const struct aklwngt__sync_info *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_aklwngt__sync_info);
	if (soap_out_aklwngt__sync_info(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_aklwngt__sync_info(struct soap *soap, const char *tag, int id, const struct aklwngt__sync_info *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_aklwngt__sync_info), type);
	a->hash_stgs.soap_out(soap, "hash-stgs", -1, "");
	a->hash_pol.soap_out(soap, "hash-pol", -1, "");
	a->hash_sbsc.soap_out(soap, "hash-sbsc", -1, "");
	a->hash_info.soap_out(soap, "hash-info", -1, "");
	a->hash_state.soap_out(soap, "hash-state", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct aklwngt__sync_info * SOAP_FMAC4 soap_get_aklwngt__sync_info(struct soap *soap, struct aklwngt__sync_info *p, const char *tag, const char *type)
{
	if ((p = soap_in_aklwngt__sync_info(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct aklwngt__sync_info * SOAP_FMAC4 soap_in_aklwngt__sync_info(struct soap *soap, const char *tag, struct aklwngt__sync_info *a, const char *type)
{
	short soap_flag_hash_stgs = 1, soap_flag_hash_pol = 1, soap_flag_hash_sbsc = 1, soap_flag_hash_info = 1, soap_flag_hash_state = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct aklwngt__sync_info *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_aklwngt__sync_info, sizeof(struct aklwngt__sync_info), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_aklwngt__sync_info(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_hash_stgs && soap->error == SOAP_TAG_MISMATCH)
				if (a->hash_stgs.soap_in(soap, "hash-stgs", "xsd:base64Binary"))
				{	soap_flag_hash_stgs = 0;
					continue;
				}
			if (soap_flag_hash_pol && soap->error == SOAP_TAG_MISMATCH)
				if (a->hash_pol.soap_in(soap, "hash-pol", "xsd:base64Binary"))
				{	soap_flag_hash_pol = 0;
					continue;
				}
			if (soap_flag_hash_sbsc && soap->error == SOAP_TAG_MISMATCH)
				if (a->hash_sbsc.soap_in(soap, "hash-sbsc", "xsd:base64Binary"))
				{	soap_flag_hash_sbsc = 0;
					continue;
				}
			if (soap_flag_hash_info && soap->error == SOAP_TAG_MISMATCH)
				if (a->hash_info.soap_in(soap, "hash-info", "xsd:base64Binary"))
				{	soap_flag_hash_info = 0;
					continue;
				}
			if (soap_flag_hash_state && soap->error == SOAP_TAG_MISMATCH)
				if (a->hash_state.soap_in(soap, "hash-state", "xsd:base64Binary"))
				{	soap_flag_hash_state = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_hash_stgs || soap_flag_hash_pol || soap_flag_hash_sbsc || soap_flag_hash_info || soap_flag_hash_state))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct aklwngt__sync_info *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_aklwngt__sync_info, 0, sizeof(struct aklwngt__sync_info), 0, soap_copy_aklwngt__sync_info);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct aklwngt__sync_info * SOAP_FMAC6 soap_new_aklwngt__sync_info(struct soap *soap, int n)
{	return soap_instantiate_aklwngt__sync_info(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_aklwngt__sync_info(struct soap *soap, struct aklwngt__sync_info *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 struct aklwngt__sync_info * SOAP_FMAC6 soap_instantiate_aklwngt__sync_info(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_aklwngt__sync_info(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_aklwngt__sync_info, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct aklwngt__sync_info;
		if (size)
			*size = sizeof(struct aklwngt__sync_info);
	}
	else
	{	cp->ptr = (void*)new struct aklwngt__sync_info[n];
		if (size)
			*size = n * sizeof(struct aklwngt__sync_info);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct aklwngt__sync_info*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_aklwngt__sync_info(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct aklwngt__sync_info %p -> %p\n", q, p));
	*(struct aklwngt__sync_info*)p = *(struct aklwngt__sync_info*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_aklwngt__command(struct soap *soap, struct aklwngt__command const*a)
{
	soap_mark_aklwngt__command(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_aklwngt__command(struct soap *soap, const struct aklwngt__command *a)
{
	soap_embedded(soap, &a->code, SOAP_TYPE_xsd__int);
	soap_embedded(soap, &a->data, SOAP_TYPE_PointerToaklwngt__anyCmd);
	soap_mark_PointerToaklwngt__anyCmd(soap, &a->data);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_aklwngt__command(struct soap *soap, struct aklwngt__command *a)
{
	soap_default_xsd__int(soap, &a->code);
	a->data = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_aklwngt__command(struct soap *soap, const struct aklwngt__command *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_aklwngt__command);
	if (soap_out_aklwngt__command(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_aklwngt__command(struct soap *soap, const char *tag, int id, const struct aklwngt__command *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_aklwngt__command), type);
	soap_out_xsd__int(soap, "code", -1, &a->code, "");
	soap_out_PointerToaklwngt__anyCmd(soap, "data", -1, &a->data, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct aklwngt__command * SOAP_FMAC4 soap_get_aklwngt__command(struct soap *soap, struct aklwngt__command *p, const char *tag, const char *type)
{
	if ((p = soap_in_aklwngt__command(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct aklwngt__command * SOAP_FMAC4 soap_in_aklwngt__command(struct soap *soap, const char *tag, struct aklwngt__command *a, const char *type)
{
	short soap_flag_code = 1, soap_flag_data = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct aklwngt__command *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_aklwngt__command, sizeof(struct aklwngt__command), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_aklwngt__command(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "code", &a->code, "xsd:int"))
				{	soap_flag_code = 0;
					continue;
				}
			if (soap_flag_data && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToaklwngt__anyCmd(soap, "data", &a->data, "aklwngt:anyCmd"))
				{	soap_flag_data = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_code))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct aklwngt__command *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_aklwngt__command, 0, sizeof(struct aklwngt__command), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_aklwngt__LicenseInfo(struct soap *soap, struct aklwngt__LicenseInfo const*a)
{
	soap_mark_aklwngt__LicenseInfo(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_aklwngt__LicenseInfo(struct soap *soap, const struct aklwngt__LicenseInfo *a)
{
	soap_embedded(soap, &a->keyCurrent, SOAP_TYPE_PointerToaklwngt__LicKeyInfo);
	soap_mark_PointerToaklwngt__LicKeyInfo(soap, &a->keyCurrent);
	soap_embedded(soap, &a->keyNext, SOAP_TYPE_PointerToaklwngt__LicKeyInfo);
	soap_mark_PointerToaklwngt__LicKeyInfo(soap, &a->keyNext);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_aklwngt__LicenseInfo(struct soap *soap, struct aklwngt__LicenseInfo *a)
{
	a->keyCurrent = NULL;
	a->keyNext = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_aklwngt__LicenseInfo(struct soap *soap, const struct aklwngt__LicenseInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_aklwngt__LicenseInfo);
	if (soap_out_aklwngt__LicenseInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_aklwngt__LicenseInfo(struct soap *soap, const char *tag, int id, const struct aklwngt__LicenseInfo *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_aklwngt__LicenseInfo), type);
	soap_out_PointerToaklwngt__LicKeyInfo(soap, "keyCurrent", -1, &a->keyCurrent, "");
	soap_out_PointerToaklwngt__LicKeyInfo(soap, "keyNext", -1, &a->keyNext, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct aklwngt__LicenseInfo * SOAP_FMAC4 soap_get_aklwngt__LicenseInfo(struct soap *soap, struct aklwngt__LicenseInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_aklwngt__LicenseInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct aklwngt__LicenseInfo * SOAP_FMAC4 soap_in_aklwngt__LicenseInfo(struct soap *soap, const char *tag, struct aklwngt__LicenseInfo *a, const char *type)
{
	short soap_flag_keyCurrent = 1, soap_flag_keyNext = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct aklwngt__LicenseInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_aklwngt__LicenseInfo, sizeof(struct aklwngt__LicenseInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_aklwngt__LicenseInfo(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_keyCurrent && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToaklwngt__LicKeyInfo(soap, "keyCurrent", &a->keyCurrent, "aklwngt:LicKeyInfo"))
				{	soap_flag_keyCurrent = 0;
					continue;
				}
			if (soap_flag_keyNext && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToaklwngt__LicKeyInfo(soap, "keyNext", &a->keyNext, "aklwngt:LicKeyInfo"))
				{	soap_flag_keyNext = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct aklwngt__LicenseInfo *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_aklwngt__LicenseInfo, 0, sizeof(struct aklwngt__LicenseInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_aklwngt__LicKeyInfo(struct soap *soap, struct aklwngt__LicKeyInfo const*a)
{
	soap_mark_aklwngt__LicKeyInfo(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_aklwngt__LicKeyInfo(struct soap *soap, const struct aklwngt__LicKeyInfo *a)
{
	soap_embedded(soap, &a->keyType, SOAP_TYPE_xsd__int);
	soap_embedded(soap, &a->keyProdSuiteID, SOAP_TYPE_xsd__int);
	soap_embedded(soap, &a->keyAppID, SOAP_TYPE_xsd__int);
	soap_embedded(soap, &a->keyInstallDate, SOAP_TYPE_xsd__dateTime);
	soap_mark_xsd__dateTime(soap, &a->keyInstallDate);
	soap_embedded(soap, &a->keyExpirationDate, SOAP_TYPE_xsd__dateTime);
	soap_mark_xsd__dateTime(soap, &a->keyExpirationDate);
	soap_embedded(soap, &a->keyLicPeriod, SOAP_TYPE_xsd__int);
	soap_embedded(soap, &a->keyLicCount, SOAP_TYPE_xsd__int);
	soap_embedded(soap, &a->keySerial, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->keySerial);
	soap_embedded(soap, &a->keyMajVer, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->keyMajVer);
	soap_embedded(soap, &a->keyProdName, SOAP_TYPE_xsd__wstring);
	soap_mark_xsd__wstring(soap, &a->keyProdName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_aklwngt__LicKeyInfo(struct soap *soap, struct aklwngt__LicKeyInfo *a)
{
	soap_default_xsd__int(soap, &a->keyType);
	soap_default_xsd__int(soap, &a->keyProdSuiteID);
	soap_default_xsd__int(soap, &a->keyAppID);
	a->keyInstallDate = NULL;
	a->keyExpirationDate = NULL;
	soap_default_xsd__int(soap, &a->keyLicPeriod);
	soap_default_xsd__int(soap, &a->keyLicCount);
	a->keySerial = NULL;
	a->keyMajVer = NULL;
	a->keyProdName = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_aklwngt__LicKeyInfo(struct soap *soap, const struct aklwngt__LicKeyInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_aklwngt__LicKeyInfo);
	if (soap_out_aklwngt__LicKeyInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_aklwngt__LicKeyInfo(struct soap *soap, const char *tag, int id, const struct aklwngt__LicKeyInfo *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_aklwngt__LicKeyInfo), type);
	soap_out_xsd__int(soap, "keyType", -1, &a->keyType, "");
	soap_out_xsd__int(soap, "keyProdSuiteID", -1, &a->keyProdSuiteID, "");
	soap_out_xsd__int(soap, "keyAppID", -1, &a->keyAppID, "");
	soap_out_xsd__dateTime(soap, "keyInstallDate", -1, &a->keyInstallDate, "");
	soap_out_xsd__dateTime(soap, "keyExpirationDate", -1, &a->keyExpirationDate, "");
	soap_out_xsd__int(soap, "keyLicPeriod", -1, &a->keyLicPeriod, "");
	soap_out_xsd__int(soap, "keyLicCount", -1, &a->keyLicCount, "");
	soap_out_xsd__string(soap, "keySerial", -1, &a->keySerial, "");
	soap_out_xsd__string(soap, "keyMajVer", -1, &a->keyMajVer, "");
	soap_out_xsd__wstring(soap, "keyProdName", -1, &a->keyProdName, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct aklwngt__LicKeyInfo * SOAP_FMAC4 soap_get_aklwngt__LicKeyInfo(struct soap *soap, struct aklwngt__LicKeyInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_aklwngt__LicKeyInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct aklwngt__LicKeyInfo * SOAP_FMAC4 soap_in_aklwngt__LicKeyInfo(struct soap *soap, const char *tag, struct aklwngt__LicKeyInfo *a, const char *type)
{
	short soap_flag_keyType = 1, soap_flag_keyProdSuiteID = 1, soap_flag_keyAppID = 1, soap_flag_keyInstallDate = 1, soap_flag_keyExpirationDate = 1, soap_flag_keyLicPeriod = 1, soap_flag_keyLicCount = 1, soap_flag_keySerial = 1, soap_flag_keyMajVer = 1, soap_flag_keyProdName = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct aklwngt__LicKeyInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_aklwngt__LicKeyInfo, sizeof(struct aklwngt__LicKeyInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_aklwngt__LicKeyInfo(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_keyType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "keyType", &a->keyType, "xsd:int"))
				{	soap_flag_keyType = 0;
					continue;
				}
			if (soap_flag_keyProdSuiteID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "keyProdSuiteID", &a->keyProdSuiteID, "xsd:int"))
				{	soap_flag_keyProdSuiteID = 0;
					continue;
				}
			if (soap_flag_keyAppID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "keyAppID", &a->keyAppID, "xsd:int"))
				{	soap_flag_keyAppID = 0;
					continue;
				}
			if (soap_flag_keyInstallDate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__dateTime(soap, "keyInstallDate", &a->keyInstallDate, "xsd:dateTime"))
				{	soap_flag_keyInstallDate = 0;
					continue;
				}
			if (soap_flag_keyExpirationDate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__dateTime(soap, "keyExpirationDate", &a->keyExpirationDate, "xsd:dateTime"))
				{	soap_flag_keyExpirationDate = 0;
					continue;
				}
			if (soap_flag_keyLicPeriod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "keyLicPeriod", &a->keyLicPeriod, "xsd:int"))
				{	soap_flag_keyLicPeriod = 0;
					continue;
				}
			if (soap_flag_keyLicCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "keyLicCount", &a->keyLicCount, "xsd:int"))
				{	soap_flag_keyLicCount = 0;
					continue;
				}
			if (soap_flag_keySerial && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "keySerial", &a->keySerial, "xsd:string"))
				{	soap_flag_keySerial = 0;
					continue;
				}
			if (soap_flag_keyMajVer && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "keyMajVer", &a->keyMajVer, "xsd:string"))
				{	soap_flag_keyMajVer = 0;
					continue;
				}
			if (soap_flag_keyProdName && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__wstring(soap, "keyProdName", &a->keyProdName, "xsd:wstring"))
				{	soap_flag_keyProdName = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_keyType || soap_flag_keyProdSuiteID || soap_flag_keyAppID || soap_flag_keyLicPeriod || soap_flag_keyLicCount))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct aklwngt__LicKeyInfo *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_aklwngt__LicKeyInfo, 0, sizeof(struct aklwngt__LicKeyInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_aklwngt__ProdInfo(struct soap *soap, struct aklwngt__ProdInfo const*a)
{
	soap_mark_aklwngt__ProdInfo(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_aklwngt__ProdInfo(struct soap *soap, const struct aklwngt__ProdInfo *a)
{
	soap_embedded(soap, &a->product_name, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->product_name);
	soap_embedded(soap, &a->product_version, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->product_version);
	soap_embedded(soap, &a->installTime, SOAP_TYPE_xsd__dateTime);
	soap_mark_xsd__dateTime(soap, &a->installTime);
	soap_embedded(soap, &a->dn, SOAP_TYPE_xsd__wstring);
	soap_mark_xsd__wstring(soap, &a->dn);
	soap_embedded(soap, &a->prodVersion, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->prodVersion);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_aklwngt__ProdInfo(struct soap *soap, struct aklwngt__ProdInfo *a)
{
	a->product_name = NULL;
	a->product_version = NULL;
	a->installTime = NULL;
	a->dn = NULL;
	a->prodVersion = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_aklwngt__ProdInfo(struct soap *soap, const struct aklwngt__ProdInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_aklwngt__ProdInfo);
	if (soap_out_aklwngt__ProdInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_aklwngt__ProdInfo(struct soap *soap, const char *tag, int id, const struct aklwngt__ProdInfo *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_aklwngt__ProdInfo), type);
	soap_out_xsd__string(soap, "product-name", -1, &a->product_name, "");
	soap_out_xsd__string(soap, "product-version", -1, &a->product_version, "");
	soap_out_xsd__dateTime(soap, "installTime", -1, &a->installTime, "");
	soap_out_xsd__wstring(soap, "dn", -1, &a->dn, "");
	soap_out_xsd__string(soap, "prodVersion", -1, &a->prodVersion, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct aklwngt__ProdInfo * SOAP_FMAC4 soap_get_aklwngt__ProdInfo(struct soap *soap, struct aklwngt__ProdInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_aklwngt__ProdInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct aklwngt__ProdInfo * SOAP_FMAC4 soap_in_aklwngt__ProdInfo(struct soap *soap, const char *tag, struct aklwngt__ProdInfo *a, const char *type)
{
	short soap_flag_product_name = 1, soap_flag_product_version = 1, soap_flag_installTime = 1, soap_flag_dn = 1, soap_flag_prodVersion = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct aklwngt__ProdInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_aklwngt__ProdInfo, sizeof(struct aklwngt__ProdInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_aklwngt__ProdInfo(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_product_name && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "product-name", &a->product_name, "xsd:string"))
				{	soap_flag_product_name = 0;
					continue;
				}
			if (soap_flag_product_version && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "product-version", &a->product_version, "xsd:string"))
				{	soap_flag_product_version = 0;
					continue;
				}
			if (soap_flag_installTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__dateTime(soap, "installTime", &a->installTime, "xsd:dateTime"))
				{	soap_flag_installTime = 0;
					continue;
				}
			if (soap_flag_dn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__wstring(soap, "dn", &a->dn, "xsd:wstring"))
				{	soap_flag_dn = 0;
					continue;
				}
			if (soap_flag_prodVersion && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "prodVersion", &a->prodVersion, "xsd:string"))
				{	soap_flag_prodVersion = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct aklwngt__ProdInfo *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_aklwngt__ProdInfo, 0, sizeof(struct aklwngt__ProdInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_aklwngt__DevInfo(struct soap *soap, struct aklwngt__DevInfo const*a)
{
	soap_mark_aklwngt__DevInfo(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_aklwngt__DevInfo(struct soap *soap, const struct aklwngt__DevInfo *a)
{
	soap_embedded(soap, &a->presumedName, SOAP_TYPE_xsd__wstring);
	soap_mark_xsd__wstring(soap, &a->presumedName);
	soap_embedded(soap, &a->presumedGroup, SOAP_TYPE_xsd__wstring);
	soap_mark_xsd__wstring(soap, &a->presumedGroup);
	soap_embedded(soap, &a->os_type, SOAP_TYPE_xsd__int);
	soap_embedded(soap, &a->os_ver_major, SOAP_TYPE_xsd__int);
	soap_embedded(soap, &a->os_ver_minor, SOAP_TYPE_xsd__int);
	soap_embedded(soap, &a->os_manufacturer, SOAP_TYPE_xsd__wstring);
	soap_mark_xsd__wstring(soap, &a->os_manufacturer);
	soap_embedded(soap, &a->os_name, SOAP_TYPE_xsd__wstring);
	soap_mark_xsd__wstring(soap, &a->os_name);
	soap_embedded(soap, &a->os_ver, SOAP_TYPE_xsd__wstring);
	soap_mark_xsd__wstring(soap, &a->os_ver);
	soap_embedded(soap, &a->memory, SOAP_TYPE_xsd__unsignedLong);
	soap_embedded(soap, &a->processor_family, SOAP_TYPE_xsd__wstring);
	soap_mark_xsd__wstring(soap, &a->processor_family);
	soap_embedded(soap, &a->system_name, SOAP_TYPE_xsd__wstring);
	soap_mark_xsd__wstring(soap, &a->system_name);
	soap_embedded(soap, &a->system_type, SOAP_TYPE_xsd__wstring);
	soap_mark_xsd__wstring(soap, &a->system_type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_aklwngt__DevInfo(struct soap *soap, struct aklwngt__DevInfo *a)
{
	a->presumedName = NULL;
	a->presumedGroup = NULL;
	soap_default_xsd__int(soap, &a->os_type);
	soap_default_xsd__int(soap, &a->os_ver_major);
	soap_default_xsd__int(soap, &a->os_ver_minor);
	a->os_manufacturer = NULL;
	a->os_name = NULL;
	a->os_ver = NULL;
	soap_default_xsd__unsignedLong(soap, &a->memory);
	a->processor_family = NULL;
	a->system_name = NULL;
	a->system_type = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_aklwngt__DevInfo(struct soap *soap, const struct aklwngt__DevInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_aklwngt__DevInfo);
	if (soap_out_aklwngt__DevInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_aklwngt__DevInfo(struct soap *soap, const char *tag, int id, const struct aklwngt__DevInfo *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_aklwngt__DevInfo), type);
	soap_out_xsd__wstring(soap, "presumedName", -1, &a->presumedName, "");
	soap_out_xsd__wstring(soap, "presumedGroup", -1, &a->presumedGroup, "");
	soap_out_xsd__int(soap, "os-type", -1, &a->os_type, "");
	soap_out_xsd__int(soap, "os-ver-major", -1, &a->os_ver_major, "");
	soap_out_xsd__int(soap, "os-ver-minor", -1, &a->os_ver_minor, "");
	soap_out_xsd__wstring(soap, "os-manufacturer", -1, &a->os_manufacturer, "");
	soap_out_xsd__wstring(soap, "os-name", -1, &a->os_name, "");
	soap_out_xsd__wstring(soap, "os-ver", -1, &a->os_ver, "");
	soap_out_xsd__unsignedLong(soap, "memory", -1, &a->memory, "");
	soap_out_xsd__wstring(soap, "processor-family", -1, &a->processor_family, "");
	soap_out_xsd__wstring(soap, "system-name", -1, &a->system_name, "");
	soap_out_xsd__wstring(soap, "system-type", -1, &a->system_type, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct aklwngt__DevInfo * SOAP_FMAC4 soap_get_aklwngt__DevInfo(struct soap *soap, struct aklwngt__DevInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_aklwngt__DevInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct aklwngt__DevInfo * SOAP_FMAC4 soap_in_aklwngt__DevInfo(struct soap *soap, const char *tag, struct aklwngt__DevInfo *a, const char *type)
{
	short soap_flag_presumedName = 1, soap_flag_presumedGroup = 1, soap_flag_os_type = 1, soap_flag_os_ver_major = 1, soap_flag_os_ver_minor = 1, soap_flag_os_manufacturer = 1, soap_flag_os_name = 1, soap_flag_os_ver = 1, soap_flag_memory = 1, soap_flag_processor_family = 1, soap_flag_system_name = 1, soap_flag_system_type = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct aklwngt__DevInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_aklwngt__DevInfo, sizeof(struct aklwngt__DevInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_aklwngt__DevInfo(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_presumedName && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__wstring(soap, "presumedName", &a->presumedName, "xsd:wstring"))
				{	soap_flag_presumedName = 0;
					continue;
				}
			if (soap_flag_presumedGroup && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__wstring(soap, "presumedGroup", &a->presumedGroup, "xsd:wstring"))
				{	soap_flag_presumedGroup = 0;
					continue;
				}
			if (soap_flag_os_type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "os-type", &a->os_type, "xsd:int"))
				{	soap_flag_os_type = 0;
					continue;
				}
			if (soap_flag_os_ver_major && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "os-ver-major", &a->os_ver_major, "xsd:int"))
				{	soap_flag_os_ver_major = 0;
					continue;
				}
			if (soap_flag_os_ver_minor && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "os-ver-minor", &a->os_ver_minor, "xsd:int"))
				{	soap_flag_os_ver_minor = 0;
					continue;
				}
			if (soap_flag_os_manufacturer && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__wstring(soap, "os-manufacturer", &a->os_manufacturer, "xsd:wstring"))
				{	soap_flag_os_manufacturer = 0;
					continue;
				}
			if (soap_flag_os_name && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__wstring(soap, "os-name", &a->os_name, "xsd:wstring"))
				{	soap_flag_os_name = 0;
					continue;
				}
			if (soap_flag_os_ver && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__wstring(soap, "os-ver", &a->os_ver, "xsd:wstring"))
				{	soap_flag_os_ver = 0;
					continue;
				}
			if (soap_flag_memory && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__unsignedLong(soap, "memory", &a->memory, "xsd:unsignedLong"))
				{	soap_flag_memory = 0;
					continue;
				}
			if (soap_flag_processor_family && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__wstring(soap, "processor-family", &a->processor_family, "xsd:wstring"))
				{	soap_flag_processor_family = 0;
					continue;
				}
			if (soap_flag_system_name && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__wstring(soap, "system-name", &a->system_name, "xsd:wstring"))
				{	soap_flag_system_name = 0;
					continue;
				}
			if (soap_flag_system_type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__wstring(soap, "system-type", &a->system_type, "xsd:wstring"))
				{	soap_flag_system_type = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_os_type || soap_flag_os_ver_major || soap_flag_os_ver_minor || soap_flag_memory))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct aklwngt__DevInfo *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_aklwngt__DevInfo, 0, sizeof(struct aklwngt__DevInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_aklwngt__string_array(struct soap *soap, struct aklwngt__string_array const*a)
{
	soap_mark_aklwngt__string_array(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_aklwngt__string_array(struct soap *soap, struct aklwngt__string_array const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_aklwngt__string_array))
		for (i = 0; i < a->__size; i++)
		{	soap_embedded(soap, a->__ptr + i, SOAP_TYPE_xsd__string);
			soap_mark_xsd__string(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_aklwngt__string_array(struct soap *soap, struct aklwngt__string_array *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_aklwngt__string_array(struct soap *soap, const struct aklwngt__string_array *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_aklwngt__string_array);
	if (soap_out_aklwngt__string_array(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_aklwngt__string_array(struct soap *soap, const char *tag, int id, const struct aklwngt__string_array *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_aklwngt__string_array);
	if (id < 0)
		return soap->error;
	soap_element_begin_out(soap, tag, id, type);
	for (i = 0; i < n; i++)
	{
		soap_out_xsd__string(soap, "item", -1, &a->__ptr[i], "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct aklwngt__string_array * SOAP_FMAC4 soap_get_aklwngt__string_array(struct soap *soap, struct aklwngt__string_array *p, const char *tag, const char *type)
{
	if ((p = soap_in_aklwngt__string_array(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct aklwngt__string_array * SOAP_FMAC4 soap_in_aklwngt__string_array(struct soap *soap, const char *tag, struct aklwngt__string_array *a, const char *type)
{	int i, j;
	char **p;
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct aklwngt__string_array *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_aklwngt__string_array, sizeof(struct aklwngt__string_array), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_aklwngt__string_array(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (char **)soap_malloc(soap, sizeof(char *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_xsd__string(soap, NULL, a->__ptr + i, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (char **)soap_push_block(soap, sizeof(char *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_xsd__string(soap, NULL, p, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (char **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 0);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct aklwngt__string_array *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_aklwngt__string_array, 0, sizeof(struct aklwngt__string_array), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_param_error(struct soap *soap, struct param_error const*a)
{
	soap_mark_param_error(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_param_error(struct soap *soap, const struct param_error *a)
{
	soap_embedded(soap, &a->code, SOAP_TYPE_xsd__int);
	soap_embedded(soap, &a->module, SOAP_TYPE_xsd__wstring);
	soap_mark_xsd__wstring(soap, &a->module);
	soap_embedded(soap, &a->file, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->file);
	soap_embedded(soap, &a->line, SOAP_TYPE_xsd__int);
	soap_embedded(soap, &a->message, SOAP_TYPE_xsd__wstring);
	soap_mark_xsd__wstring(soap, &a->message);
	soap_embedded(soap, &a->locdata, SOAP_TYPE_PointerToparam_error_loc);
	soap_mark_PointerToparam_error_loc(soap, &a->locdata);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_param_error(struct soap *soap, struct param_error *a)
{
	soap_default_xsd__int(soap, &a->code);
	a->module = NULL;
	a->file = NULL;
	soap_default_xsd__int(soap, &a->line);
	a->message = NULL;
	a->locdata = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_param_error(struct soap *soap, const struct param_error *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_param_error);
	if (soap_out_param_error(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_param_error(struct soap *soap, const char *tag, int id, const struct param_error *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_param_error), type);
	soap_out_xsd__int(soap, "code", -1, &a->code, "");
	soap_out_xsd__wstring(soap, "module", -1, &a->module, "");
	soap_out_xsd__string(soap, "file", -1, &a->file, "");
	soap_out_xsd__int(soap, "line", -1, &a->line, "");
	soap_out_xsd__wstring(soap, "message", -1, &a->message, "");
	soap_out_PointerToparam_error_loc(soap, "locdata", -1, &a->locdata, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct param_error * SOAP_FMAC4 soap_get_param_error(struct soap *soap, struct param_error *p, const char *tag, const char *type)
{
	if ((p = soap_in_param_error(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct param_error * SOAP_FMAC4 soap_in_param_error(struct soap *soap, const char *tag, struct param_error *a, const char *type)
{
	short soap_flag_code = 1, soap_flag_module = 1, soap_flag_file = 1, soap_flag_line = 1, soap_flag_message = 1, soap_flag_locdata = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct param_error *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_param_error, sizeof(struct param_error), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_param_error(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "code", &a->code, "xsd:int"))
				{	soap_flag_code = 0;
					continue;
				}
			if (soap_flag_module && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__wstring(soap, "module", &a->module, "xsd:wstring"))
				{	soap_flag_module = 0;
					continue;
				}
			if (soap_flag_file && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "file", &a->file, "xsd:string"))
				{	soap_flag_file = 0;
					continue;
				}
			if (soap_flag_line && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "line", &a->line, "xsd:int"))
				{	soap_flag_line = 0;
					continue;
				}
			if (soap_flag_message && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__wstring(soap, "message", &a->message, "xsd:wstring"))
				{	soap_flag_message = 0;
					continue;
				}
			if (soap_flag_locdata && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToparam_error_loc(soap, "locdata", &a->locdata, ""))
				{	soap_flag_locdata = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_code || soap_flag_line))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct param_error *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_param_error, 0, sizeof(struct param_error), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	soap_mark_PointerToSOAP_ENV__Code(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_mark_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	soap_mark_PointerToSOAP_ENV__Detail(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_mark_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToaklwngt__event_info_array(struct soap *soap, struct aklwngt__event_info_array *const*a)
{
	soap_mark_PointerToaklwngt__event_info_array(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerToaklwngt__event_info_array(struct soap *soap, struct aklwngt__event_info_array *const*a)
{
	if (*a && !soap_array_reference(soap, *a, (struct soap_array*)&(*a)->__ptr, 1, SOAP_TYPE_aklwngt__event_info_array))
		soap_mark_aklwngt__event_info_array(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToaklwngt__event_info_array(struct soap *soap, struct aklwngt__event_info_array *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToaklwngt__event_info_array);
	if (soap_out_PointerToaklwngt__event_info_array(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToaklwngt__event_info_array(struct soap *soap, const char *tag, int id, struct aklwngt__event_info_array *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_aklwngt__event_info_array);
	if (id < 0)
		return soap->error;
	return soap_out_aklwngt__event_info_array(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct aklwngt__event_info_array ** SOAP_FMAC4 soap_get_PointerToaklwngt__event_info_array(struct soap *soap, struct aklwngt__event_info_array **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToaklwngt__event_info_array(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct aklwngt__event_info_array ** SOAP_FMAC4 soap_in_PointerToaklwngt__event_info_array(struct soap *soap, const char *tag, struct aklwngt__event_info_array **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct aklwngt__event_info_array **)soap_malloc(soap, sizeof(struct aklwngt__event_info_array *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_aklwngt__event_info_array(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct aklwngt__event_info_array **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_aklwngt__event_info_array, sizeof(struct aklwngt__event_info_array), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToaklwngt__command(struct soap *soap, struct aklwngt__command *const*a)
{
	soap_mark_PointerToaklwngt__command(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerToaklwngt__command(struct soap *soap, struct aklwngt__command *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_aklwngt__command))
		soap_mark_aklwngt__command(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToaklwngt__command(struct soap *soap, struct aklwngt__command *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToaklwngt__command);
	if (soap_out_PointerToaklwngt__command(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToaklwngt__command(struct soap *soap, const char *tag, int id, struct aklwngt__command *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_aklwngt__command);
	if (id < 0)
		return soap->error;
	return soap_out_aklwngt__command(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct aklwngt__command ** SOAP_FMAC4 soap_get_PointerToaklwngt__command(struct soap *soap, struct aklwngt__command **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToaklwngt__command(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct aklwngt__command ** SOAP_FMAC4 soap_in_PointerToaklwngt__command(struct soap *soap, const char *tag, struct aklwngt__command **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct aklwngt__command **)soap_malloc(soap, sizeof(struct aklwngt__command *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_aklwngt__command(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct aklwngt__command **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_aklwngt__command, sizeof(struct aklwngt__command), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToaklwngt__sync_info(struct soap *soap, struct aklwngt__sync_info *const*a)
{
	soap_mark_PointerToaklwngt__sync_info(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerToaklwngt__sync_info(struct soap *soap, struct aklwngt__sync_info *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_aklwngt__sync_info))
		soap_mark_aklwngt__sync_info(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToaklwngt__sync_info(struct soap *soap, struct aklwngt__sync_info *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToaklwngt__sync_info);
	if (soap_out_PointerToaklwngt__sync_info(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToaklwngt__sync_info(struct soap *soap, const char *tag, int id, struct aklwngt__sync_info *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_aklwngt__sync_info);
	if (id < 0)
		return soap->error;
	return soap_out_aklwngt__sync_info(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct aklwngt__sync_info ** SOAP_FMAC4 soap_get_PointerToaklwngt__sync_info(struct soap *soap, struct aklwngt__sync_info **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToaklwngt__sync_info(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct aklwngt__sync_info ** SOAP_FMAC4 soap_in_PointerToaklwngt__sync_info(struct soap *soap, const char *tag, struct aklwngt__sync_info **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct aklwngt__sync_info **)soap_malloc(soap, sizeof(struct aklwngt__sync_info *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_aklwngt__sync_info(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct aklwngt__sync_info **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_aklwngt__sync_info, sizeof(struct aklwngt__sync_info), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToparam_error(struct soap *soap, struct param_error *const*a)
{
	soap_mark_PointerToparam_error(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerToparam_error(struct soap *soap, struct param_error *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_param_error))
		soap_mark_param_error(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToparam_error(struct soap *soap, struct param_error *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToparam_error);
	if (soap_out_PointerToparam_error(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToparam_error(struct soap *soap, const char *tag, int id, struct param_error *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_param_error);
	if (id < 0)
		return soap->error;
	return soap_out_param_error(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct param_error ** SOAP_FMAC4 soap_get_PointerToparam_error(struct soap *soap, struct param_error **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToparam_error(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct param_error ** SOAP_FMAC4 soap_in_PointerToparam_error(struct soap *soap, const char *tag, struct param_error **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct param_error **)soap_malloc(soap, sizeof(struct param_error *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_param_error(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct param_error **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_param_error, sizeof(struct param_error), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__unsignedByte(struct soap *soap, unsigned char *const*a)
{
	soap_mark_PointerToxsd__unsignedByte(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerToxsd__unsignedByte(struct soap *soap, unsigned char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__unsignedByte);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__unsignedByte(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__unsignedByte);
	if (soap_out_PointerToxsd__unsignedByte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__unsignedByte(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__unsignedByte);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__unsignedByte(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerToxsd__unsignedByte(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__unsignedByte(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerToxsd__unsignedByte(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (unsigned char **)soap_malloc(soap, sizeof(unsigned char *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__unsignedByte(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__unsignedByte, sizeof(unsigned char), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToaklwngt__event_info(struct soap *soap, struct aklwngt__event_info *const*a)
{
	soap_mark_PointerToaklwngt__event_info(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerToaklwngt__event_info(struct soap *soap, struct aklwngt__event_info *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_aklwngt__event_info))
		soap_mark_aklwngt__event_info(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToaklwngt__event_info(struct soap *soap, struct aklwngt__event_info *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToaklwngt__event_info);
	if (soap_out_PointerToaklwngt__event_info(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToaklwngt__event_info(struct soap *soap, const char *tag, int id, struct aklwngt__event_info *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_aklwngt__event_info);
	if (id < 0)
		return soap->error;
	return soap_out_aklwngt__event_info(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct aklwngt__event_info ** SOAP_FMAC4 soap_get_PointerToaklwngt__event_info(struct soap *soap, struct aklwngt__event_info **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToaklwngt__event_info(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct aklwngt__event_info ** SOAP_FMAC4 soap_in_PointerToaklwngt__event_info(struct soap *soap, const char *tag, struct aklwngt__event_info **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct aklwngt__event_info **)soap_malloc(soap, sizeof(struct aklwngt__event_info *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_aklwngt__event_info(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct aklwngt__event_info **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_aklwngt__event_info, sizeof(struct aklwngt__event_info), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToaklwngt__anyCmd(struct soap *soap, aklwngt__anyCmd *const*a)
{
	soap_mark_PointerToaklwngt__anyCmd(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerToaklwngt__anyCmd(struct soap *soap, aklwngt__anyCmd *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_aklwngt__anyCmd))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToaklwngt__anyCmd(struct soap *soap, aklwngt__anyCmd *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToaklwngt__anyCmd);
	if (soap_out_PointerToaklwngt__anyCmd(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToaklwngt__anyCmd(struct soap *soap, const char *tag, int id, aklwngt__anyCmd *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_aklwngt__anyCmd);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 aklwngt__anyCmd ** SOAP_FMAC4 soap_get_PointerToaklwngt__anyCmd(struct soap *soap, aklwngt__anyCmd **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToaklwngt__anyCmd(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 aklwngt__anyCmd ** SOAP_FMAC4 soap_in_PointerToaklwngt__anyCmd(struct soap *soap, const char *tag, aklwngt__anyCmd **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (aklwngt__anyCmd **)soap_malloc(soap, sizeof(aklwngt__anyCmd *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (aklwngt__anyCmd *)soap_instantiate_aklwngt__anyCmd(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (aklwngt__anyCmd **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_aklwngt__anyCmd, sizeof(aklwngt__anyCmd), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToaklwngt__LicKeyInfo(struct soap *soap, struct aklwngt__LicKeyInfo *const*a)
{
	soap_mark_PointerToaklwngt__LicKeyInfo(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerToaklwngt__LicKeyInfo(struct soap *soap, struct aklwngt__LicKeyInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_aklwngt__LicKeyInfo))
		soap_mark_aklwngt__LicKeyInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToaklwngt__LicKeyInfo(struct soap *soap, struct aklwngt__LicKeyInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToaklwngt__LicKeyInfo);
	if (soap_out_PointerToaklwngt__LicKeyInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToaklwngt__LicKeyInfo(struct soap *soap, const char *tag, int id, struct aklwngt__LicKeyInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_aklwngt__LicKeyInfo);
	if (id < 0)
		return soap->error;
	return soap_out_aklwngt__LicKeyInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct aklwngt__LicKeyInfo ** SOAP_FMAC4 soap_get_PointerToaklwngt__LicKeyInfo(struct soap *soap, struct aklwngt__LicKeyInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToaklwngt__LicKeyInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct aklwngt__LicKeyInfo ** SOAP_FMAC4 soap_in_PointerToaklwngt__LicKeyInfo(struct soap *soap, const char *tag, struct aklwngt__LicKeyInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct aklwngt__LicKeyInfo **)soap_malloc(soap, sizeof(struct aklwngt__LicKeyInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_aklwngt__LicKeyInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct aklwngt__LicKeyInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_aklwngt__LicKeyInfo, sizeof(struct aklwngt__LicKeyInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__string(struct soap *soap, char **const*a)
{
	soap_mark_PointerToxsd__string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerToxsd__string(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__string))
		soap_mark_xsd__string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__string(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__string);
	if (soap_out_PointerToxsd__string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__string(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__string);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerToxsd__string(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerToxsd__string(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__string, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToparam__value(struct soap *soap, param__value *const*a)
{
	soap_mark_PointerToparam__value(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerToparam__value(struct soap *soap, param__value *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_param__value))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToparam__value(struct soap *soap, param__value *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToparam__value);
	if (soap_out_PointerToparam__value(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToparam__value(struct soap *soap, const char *tag, int id, param__value *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_param__value);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 param__value ** SOAP_FMAC4 soap_get_PointerToparam__value(struct soap *soap, param__value **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToparam__value(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 param__value ** SOAP_FMAC4 soap_in_PointerToparam__value(struct soap *soap, const char *tag, param__value **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (param__value **)soap_malloc(soap, sizeof(param__value *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (param__value *)soap_instantiate_param__value(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (param__value **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_param__value, sizeof(param__value), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToparam__node(struct soap *soap, param__node *const*a)
{
	soap_mark_PointerToparam__node(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerToparam__node(struct soap *soap, param__node *const*a)
{
	if (*a && !soap_array_reference(soap, *a, (struct soap_array*)&(*a)->__ptr, 1, SOAP_TYPE_param__node))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToparam__node(struct soap *soap, param__node *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToparam__node);
	if (soap_out_PointerToparam__node(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToparam__node(struct soap *soap, const char *tag, int id, param__node *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_param__node);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 param__node ** SOAP_FMAC4 soap_get_PointerToparam__node(struct soap *soap, param__node **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToparam__node(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 param__node ** SOAP_FMAC4 soap_in_PointerToparam__node(struct soap *soap, const char *tag, param__node **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (param__node **)soap_malloc(soap, sizeof(param__node *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (param__node *)soap_instantiate_param__node(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (param__node **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_param__node, sizeof(param__node), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToparam__entry(struct soap *soap, param__entry *const*a)
{
	soap_mark_PointerToparam__entry(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerToparam__entry(struct soap *soap, param__entry *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_param__entry))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToparam__entry(struct soap *soap, param__entry *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToparam__entry);
	if (soap_out_PointerToparam__entry(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToparam__entry(struct soap *soap, const char *tag, int id, param__entry *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_param__entry);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 param__entry ** SOAP_FMAC4 soap_get_PointerToparam__entry(struct soap *soap, param__entry **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToparam__entry(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 param__entry ** SOAP_FMAC4 soap_in_PointerToparam__entry(struct soap *soap, const char *tag, param__entry **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (param__entry **)soap_malloc(soap, sizeof(param__entry *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (param__entry *)soap_instantiate_param__entry(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (param__entry **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_param__entry, sizeof(param__entry), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__anyType(struct soap *soap, xsd__anyType *const*a)
{
	soap_mark_PointerToxsd__anyType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerToxsd__anyType(struct soap *soap, xsd__anyType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__anyType))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__anyType(struct soap *soap, xsd__anyType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__anyType);
	if (soap_out_PointerToxsd__anyType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__anyType(struct soap *soap, const char *tag, int id, xsd__anyType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__anyType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 xsd__anyType ** SOAP_FMAC4 soap_get_PointerToxsd__anyType(struct soap *soap, xsd__anyType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__anyType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 xsd__anyType ** SOAP_FMAC4 soap_in_PointerToxsd__anyType(struct soap *soap, const char *tag, xsd__anyType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (xsd__anyType **)soap_malloc(soap, sizeof(xsd__anyType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (xsd__anyType *)soap_instantiate_xsd__anyType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__anyType, sizeof(xsd__anyType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToparam_error_loc(struct soap *soap, param_error_loc *const*a)
{
	soap_mark_PointerToparam_error_loc(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerToparam_error_loc(struct soap *soap, param_error_loc *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_param_error_loc))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToparam_error_loc(struct soap *soap, param_error_loc *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToparam_error_loc);
	if (soap_out_PointerToparam_error_loc(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToparam_error_loc(struct soap *soap, const char *tag, int id, param_error_loc *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_param_error_loc);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 param_error_loc ** SOAP_FMAC4 soap_get_PointerToparam_error_loc(struct soap *soap, param_error_loc **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToparam_error_loc(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 param_error_loc ** SOAP_FMAC4 soap_in_PointerToparam_error_loc(struct soap *soap, const char *tag, param_error_loc **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (param_error_loc **)soap_malloc(soap, sizeof(param_error_loc *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (param_error_loc *)soap_instantiate_param_error_loc(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (param_error_loc **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_param_error_loc, sizeof(param_error_loc), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__wstring(struct soap *soap, wchar_t **const*a)
{
	soap_mark_PointerToxsd__wstring(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerToxsd__wstring(struct soap *soap, wchar_t **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__wstring))
		soap_mark_xsd__wstring(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__wstring(struct soap *soap, wchar_t **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__wstring);
	if (soap_out_PointerToxsd__wstring(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__wstring(struct soap *soap, const char *tag, int id, wchar_t **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__wstring);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__wstring(soap, tag, id, *a, type);
}

SOAP_FMAC3 wchar_t *** SOAP_FMAC4 soap_get_PointerToxsd__wstring(struct soap *soap, wchar_t ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__wstring(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 wchar_t *** SOAP_FMAC4 soap_in_PointerToxsd__wstring(struct soap *soap, const char *tag, wchar_t ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (wchar_t ***)soap_malloc(soap, sizeof(wchar_t **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__wstring(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (wchar_t ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__wstring, sizeof(wchar_t *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedByte(struct soap *soap, unsigned char *const*a)
{
	soap_mark_PointerTounsignedByte(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTounsignedByte(struct soap *soap, unsigned char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedByte(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTounsignedByte);
	if (soap_out_PointerTounsignedByte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedByte(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedByte);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedByte(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTounsignedByte(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedByte(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTounsignedByte(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (unsigned char **)soap_malloc(soap, sizeof(unsigned char *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedByte(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedByte, sizeof(unsigned char), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__token(struct soap *soap, char *const*a)
{
	soap_mark_xsd__token(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_xsd__token(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__token);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__token(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__token);
	if (soap_out_xsd__token(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__token(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__token);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__token(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__token(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__token(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__token, 1, 0, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__normalizedString(struct soap *soap, char *const*a)
{
	soap_mark_xsd__normalizedString(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_xsd__normalizedString(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__normalizedString);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__normalizedString(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__normalizedString);
	if (soap_out_xsd__normalizedString(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__normalizedString(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__normalizedString);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__normalizedString(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__normalizedString(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__normalizedString(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__normalizedString, 1, 0, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__string(struct soap *soap, char *const*a)
{
	soap_mark_xsd__string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_xsd__string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__string);
	if (soap_out_xsd__string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__string(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__string, 1, 0, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__wstring(struct soap *soap, wchar_t *const*a)
{
	soap_mark_xsd__wstring(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_xsd__wstring(struct soap *soap, wchar_t *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__wstring);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__wstring(struct soap *soap, wchar_t *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__wstring);
	if (soap_out_xsd__wstring(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__wstring(struct soap *soap, const char *tag, int id, wchar_t *const*a, const char *type)
{
	return soap_outwstring(soap, tag, id, a, type, SOAP_TYPE_xsd__wstring);
}

SOAP_FMAC3 wchar_t ** SOAP_FMAC4 soap_get_xsd__wstring(struct soap *soap, wchar_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__wstring(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 wchar_t * * SOAP_FMAC4 soap_in_xsd__wstring(struct soap *soap, const char *tag, wchar_t **a, const char *type)
{
	return soap_inwstring(soap, tag, a, type, SOAP_TYPE_xsd__wstring, 0, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wstring(struct soap *soap, wchar_t *const*a)
{
	soap_mark_wstring(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_wstring(struct soap *soap, wchar_t *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_wstring);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wstring(struct soap *soap, wchar_t *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wstring);
	if (soap_out_wstring(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstring(struct soap *soap, const char *tag, int id, wchar_t *const*a, const char *type)
{
	return soap_outwstring(soap, tag, id, a, type, SOAP_TYPE_wstring);
}

SOAP_FMAC3 wchar_t ** SOAP_FMAC4 soap_get_wstring(struct soap *soap, wchar_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_wstring(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 wchar_t * * SOAP_FMAC4 soap_in_wstring(struct soap *soap, const char *tag, wchar_t **a, const char *type)
{
	return soap_inwstring(soap, tag, a, type, SOAP_TYPE_wstring, 0, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__positiveInteger(struct soap *soap, char *const*a)
{
	soap_mark_xsd__positiveInteger(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_xsd__positiveInteger(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__positiveInteger);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__positiveInteger(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__positiveInteger);
	if (soap_out_xsd__positiveInteger(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__positiveInteger(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__positiveInteger);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__positiveInteger(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__positiveInteger(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__positiveInteger(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__positiveInteger, 1, 0, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__nonNegativeInteger(struct soap *soap, char *const*a)
{
	soap_mark_xsd__nonNegativeInteger(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_xsd__nonNegativeInteger(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__nonNegativeInteger);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__nonNegativeInteger(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__nonNegativeInteger);
	if (soap_out_xsd__nonNegativeInteger(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__nonNegativeInteger(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__nonNegativeInteger);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__nonNegativeInteger(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__nonNegativeInteger(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__nonNegativeInteger(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__nonNegativeInteger, 1, 0, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__negativeInteger(struct soap *soap, char *const*a)
{
	soap_mark_xsd__negativeInteger(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_xsd__negativeInteger(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__negativeInteger);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__negativeInteger(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__negativeInteger);
	if (soap_out_xsd__negativeInteger(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__negativeInteger(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__negativeInteger);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__negativeInteger(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__negativeInteger(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__negativeInteger(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__negativeInteger, 1, 0, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__nonPositiveInteger(struct soap *soap, char *const*a)
{
	soap_mark_xsd__nonPositiveInteger(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_xsd__nonPositiveInteger(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__nonPositiveInteger);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__nonPositiveInteger(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__nonPositiveInteger);
	if (soap_out_xsd__nonPositiveInteger(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__nonPositiveInteger(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__nonPositiveInteger);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__nonPositiveInteger(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__nonPositiveInteger(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__nonPositiveInteger(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__nonPositiveInteger, 1, 0, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__integer(struct soap *soap, char *const*a)
{
	soap_mark_xsd__integer(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_xsd__integer(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__integer);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__integer(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__integer);
	if (soap_out_xsd__integer(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__integer(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__integer);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__integer(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__integer(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__integer(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__integer, 1, 0, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__decimal(struct soap *soap, char *const*a)
{
	soap_mark_xsd__decimal(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_xsd__decimal(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__decimal);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__decimal(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__decimal);
	if (soap_out_xsd__decimal(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__decimal(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__decimal);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__decimal(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__decimal(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__decimal(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__decimal, 1, 0, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__time(struct soap *soap, char *const*a)
{
	soap_mark_xsd__time(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_xsd__time(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__time);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__time(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__time);
	if (soap_out_xsd__time(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__time(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__time);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__time(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__time(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__time(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__time, 1, 0, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__duration(struct soap *soap, char *const*a)
{
	soap_mark_xsd__duration(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_xsd__duration(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__duration);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__duration(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__duration);
	if (soap_out_xsd__duration(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__duration(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__duration);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__duration(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__duration(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__duration(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__duration, 1, 0, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__dateTime(struct soap *soap, char *const*a)
{
	soap_mark_xsd__dateTime(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_xsd__dateTime(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__dateTime);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__dateTime(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__dateTime);
	if (soap_out_xsd__dateTime(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__dateTime(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__dateTime);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__dateTime(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__dateTime(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__dateTime(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__dateTime, 1, 0, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__date(struct soap *soap, char *const*a)
{
	soap_mark_xsd__date(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_xsd__date(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__date);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__date(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__date);
	if (soap_out_xsd__date(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__date(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__date);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__date(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__date(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__date(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__date, 1, 0, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__anyURI(struct soap *soap, char *const*a)
{
	soap_mark_xsd__anyURI(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_xsd__anyURI(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__anyURI);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyURI(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__anyURI);
	if (soap_out_xsd__anyURI(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__anyURI);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__anyURI(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyURI(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__anyURI(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__anyURI, 1, 0, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	soap_mark__QName(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark__QName(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE__QName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_mark_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1);
}

SOAP_END_NAMESPACE(soap)

/* end of soapC.cpp */
