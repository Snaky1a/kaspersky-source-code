// KLE_SYS.cpp

#define VDW_MAIN
#include "stdafx.h"



// Generated by Driver::Wizard version 1.20

// Defaults and globals used for tracing
	ULONG		defTraceDevice=0;				// Default trace device
	TRACE_LEVEL defTraceOutputLevel;		// Default trace output level
	BREAK_LEVEL defTraceBreakLevel;			// Default trace break level
	KTrace		Tracer("KLE_SYS");// Global driver trace object
//	KTrace		*Tracer;	// Global driver trace object


//	Unload is responsible for releasing any system objects that
//	the driver has allocated. 
//
//	In general, this function must comprehensively ensure that
//	the driver is not unloaded while holding system objects,
//	including memory, or while there are pending events that
//	would cause the system to call the driver. This is best done
//	by deconstructing top level objects, which in turn release
//	objects for which they are responsible.
//
//	This function is called at PASSIVE_LEVEL.
//

KInterlockedCounter InMyOpenClose;
static KSEMAPHORE bSemafore;

BOOL WaitIfBusy()
{
	if(InMyOpenClose.Test())
	{
		LARGE_INTEGER t;
		t=LiNeg(LiNMul(1,10000000UL));
		_Trace(TraceInfo,"KeWaitForSingleObject semaphore: %08X TIMED\n", &bSemafore);
		NTSTATUS stat=KeWaitForSingleObject( &bSemafore,  Executive, KernelMode, TRUE, &t);
		switch(stat)
		{
		case STATUS_SUCCESS:
			break;
		default:
		case STATUS_ALERTED:
		case STATUS_TIMEOUT:
			if(InMyOpenClose.Test())
			{
				return FALSE;	
			}
			goto wait;
		}
		return TRUE;
	}
	
wait:
	_Trace(TraceInfo,"KeWaitForSingleObject semaphore: %08X Infinite\n", &bSemafore);
	KeWaitForSingleObject( &bSemafore,  Executive, KernelMode, FALSE, NULL);
	return TRUE;
}

void ReleaseWait()
{
	KeReleaseSemaphore( &bSemafore ,0,1,0 );
}
	
NTSTATUS BaseDestroy()
{
	NTSTATUS ret=STATUS_SUCCESS;
	
	if(WaitIfBusy()){
		_Trace(TraceInfo,"Base Unloading...\n");
		BAvpLoadBase(0);
		_Trace(TraceInfo,"Base Unloaded\n");
		ReleaseWait();
	}
	
	BAvpDestroy();
	//	VndDestroy();
	return ret;
}

#pragma code_seg("INIT")

NTSTATUS BaseInit()
{
	//	CTN_SHABuffer( NULL, NULL, 1 );
	
	_Trace(TraceInfo,"\n");
	_Trace(TraceInfo,"%s\n",KLE_SYS_Regname);
	_Trace(TraceInfo,"%s\n",KLE_SYS_Version);
	_Trace(TraceInfo,"Compilation: %s\n",KLE_SYS_Compilation);
	
	
	KeInitializeSemaphore( &bSemafore,1,1);
	
	if(!LoadIO()) return STATUS_INSUFFICIENT_RESOURCES;
	AvpCallback = KLE_AvpCallback;
	
	if(!BAvpInit())
		return STATUS_INSUFFICIENT_RESOURCES;
	
	return STATUS_SUCCESS;
}

DECLARE_DRIVER_CLASS(KLE_SYS, NULL)

// Driver Entry routine
//		This routine is called when the driver is loaded.
//		Usually, this is where any devices associated with
//		the driver are created.
//
//		The driver often reads the registry at DriverEntry in
//		order to setup various configurable parameters.
//		
//		Driver::Works makes it easy to use the registry to also
//		control what devices are present and should be created.
//
NTSTATUS KLE_SYS::DriverEntry(PUNICODE_STRING RegistryPath)
{
	NTSTATUS status=STATUS_INSUFFICIENT_RESOURCES;
	KUstring sRegistryPath(0x200,NonPagedPool);
	//return status;
	// Status of device creation
//	DbgPrint("KLE_SYS: DriverEntry\n");
	SetPoolTag(' wen');			// Set default pool tag for all 'new' allocations
								// Under checked build, use POOLMON to view tags

	// Automatically load following variables from registry values
	// The default value is preloaded.  If the appropriate registry
	// value is not found, the default will be left unchanged.

	// Open the driver "Parameters" key
	sRegistryPath.Assign(L"");
	sRegistryPath.Append(RegistryPath->Buffer);
	KRegistryKey Params(sRegistryPath, L"Parameters");
	if (!NT_SUCCESS(Params.LastError()))
	{
		// Error, could not open registry key
		return STATUS_INSUFFICIENT_RESOURCES;
	}

//#if DBG
	// Setup default trace parameters.
	// If not spec'd in registry, trace to both Monitor and Debugger devices.
	defTraceDevice = TRACE_MONITOR | TRACE_DEBUGGER;
	// If not spec'd in registry, output all trace messages.
	defTraceOutputLevel = TraceAlways;
	// If not spec'd in registry, never break on trace messages.
	defTraceBreakLevel = BreakNever;

	Params.QueryValue(L"TraceDevice", (PULONG) &defTraceDevice);
	Params.QueryValue(L"TraceOutputLevel", (PULONG) &defTraceOutputLevel);
	Params.QueryValue(L"TraceBreakLevel", (PULONG) &defTraceBreakLevel);
	Tracer.SetTarget(defTraceDevice);
	Tracer.SetOutputLevel(defTraceOutputLevel);
	Tracer.SetBreakLevel(defTraceBreakLevel);

//#endif


// Create KLE_SYSDevice

	KLE_SYSDevice* pKLE_SYSDevice;
	pKLE_SYSDevice = new (NonPagedPool) KLE_SYSDevice();
	if (pKLE_SYSDevice == NULL)
	{
		_DebugTrace(TraceError, "Error constructing device KLE_SYSDevice\n");
		return STATUS_INSUFFICIENT_RESOURCES;
	}
	status = pKLE_SYSDevice->ConstructorStatus();
	if (!NT_SUCCESS(status))
	{
		// Error returned from a constructor
		_DebugTrace(TraceError, "Error creating device KLE_SYSDevice, status %x\n", status);
		delete pKLE_SYSDevice;
		return status;
	}
	
	status=BaseInit();
	if(!NT_SUCCESS(status))
    {
		_DebugTrace(TraceError, "Failed to INIT");
		BaseDestroy();
		delete pKLE_SYSDevice;
    }

	return status;
}


#pragma code_seg()


VOID KLE_SYS::Unload(VOID)
{
	
	// If you don't need to perform any functions
	// except to call the base class KDriver::Unload(),
	// then this entire routine may be safely deleted.
	
    // Call base class to delete all devices.
	_DebugTrace(TraceInfo, "Unload called\n");
	BaseDestroy();
	KDriver::Unload();
	//	delete Tracer;
}
